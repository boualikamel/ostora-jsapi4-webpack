(function(){(this||window).webpackJsonp.registerAbsMids({"esri/core/tsSupport/makeTemplateObjectHelper":1628,"esri/views/3d/webgl-engine/core/shaderModules/interfaces":1629,"esri/views/draw/support/drawUtils":1667,"esri/views/3d/interactive/manipulatorUtils":1677,"esri/views/3d/webgl-engine/materials/internal/MaterialUtil":1678,"esri/views/3d/webgl-engine/core/shaderLibrary/Slice.glsl":1679,"esri/renderers/support/clickToleranceUtils":1687,"esri/views/3d/webgl-engine/core/shaderLibrary/Transform.glsl":1693,"esri/views/3d/interactive/Manipulator3D":1700,"esri/views/3d/webgl-engine/lib/IdGen":1701,"esri/views/3d/webgl-engine/lib/Geometry":1702,"esri/views/3d/webgl-engine/lib/GeometryUtil":1703,"esri/views/3d/webgl-engine/lib/DefaultVertexAttributeLocations":1704,"esri/views/3d/webgl-engine/lib/GLMaterial":1740,"esri/views/3d/webgl-engine/core/shaderTechnique/ReloadableShaderModule":1741,"esri/views/3d/webgl-engine/core/shaderTechnique/ShaderTechnique":1742,"esri/views/3d/webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration":1743,"esri/views/3d/webgl-engine/core/shaderModules/ShaderBuilder":1744,"esri/views/interactive/dragUtils/dragHandlers":1745,"esri/views/3d/webgl-engine/lib/Material":1778,"esri/views/3d/webgl-engine/materials/renderers/MergedRenderer":1779,"esri/views/3d/interactive/editingTools/manipulatorUtils":1780,"esri/views/3d/interactive/dragUtils/projectScreenToMap":1781,"esri/views/interactive/dragUtils/screenDragToMap":1782,"esri/views/interactive/dragUtils/dragActions":1783,"esri/views/3d/interactive/editingTools":1851,"esri/views/3d/webgl-engine/lib/Object3D":1852,"esri/views/3d/webgl-engine/materials/internal/bufferWriterUtils":1853,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl":1854,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl":1855,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl":1856,"esri/views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl":1857,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl":1858,"esri/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl":1859,"esri/views/interactive/InteractiveToolBase":1860,"esri/views/3d/interactive/editingTools/graphicTransform3D/graphicTransform3DToolConfig":1861,"esri/views/3d/webgl-engine/materials/ColorMaterial":1862,"esri/views/3d/webgl-engine/lib/Layer":1966,"esri/views/3d/webgl-engine/core/shaderLibrary/DiscardOrAdjustAlpha.glsl":1967,"esri/views/3d/webgl-engine/lib/doublePrecisionUtils":1968,"esri/views/3d/webgl-engine/materials/renderers/Instance":1969,"esri/views/3d/webgl-engine/materials/renderers/utils":1970,"esri/views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl":1971,"esri/views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl":1972,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl":1973,"esri/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTextureCoordinates.glsl":1974,"esri/views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl":1975,"esri/views/3d/webgl-engine/core/shaderLibrary/util/DoublePrecision.glsl":1976,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl":1977,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/HighlightData.glsl":1978,"esri/views/3d/webgl-engine/lib/intersectorUtils":1979,"esri/views/3d/webgl-engine/materials/internal/DefaultBufferWriter":1980,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl":1981,"esri/views/3d/webgl-engine/shaders/RibbonLineTechnique":1982,"esri/views/3d/interactive/editingTools/graphicReshape3D/reshapeUtils":1983,"esri/views/3d/interactive/editingTools/graphicMove3D/GraphicMove3DTool":2691,"esri/views/3d/webgl-engine/lib/Camera":2692,"esri/views/3d/webgl-engine/lib/Octree":2693,"esri/views/3d/webgl-engine/lib/GeometryRecord":2694,"esri/views/3d/webgl-engine/lib/HighlightUtils":2695,"esri/views/3d/layers/graphics/graphicUtils":2696,"esri/views/3d/webgl-engine/lib/BoundingInfo":2697,"esri/views/3d/webgl-engine/lib/GeometryData":2698,"esri/views/3d/webgl-engine/materials/DefaultMaterial":2699,"esri/views/3d/webgl-engine/lib/GLMaterialTexture":2700,"esri/views/3d/webgl-engine/lib/DefaultTextureUnits":2701,"esri/views/3d/webgl-engine/lib/AutoDisposable":2702,"esri/views/3d/webgl-engine/lib/screenSizePerspectiveUtils":2703,"esri/views/3d/webgl-engine/materials/renderers/InstancedRenderer":2704,"esri/views/3d/webgl-engine/lib/IntervalUtilities":2705,"esri/views/3d/webgl-engine/lib/ResizableFloat32Array":2706,"esri/views/3d/webgl-engine/materials/WaterGLMaterial":2707,"esri/views/3d/webgl-engine/materials/WaterTechnique":2708,"esri/views/3d/webgl-engine/shaders/WaterSurface.glsl":2709,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl":2710,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/Water.glsl":2711,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl":2712,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl":2713,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/WaterDistortion.glsl":2714,"esri/views/3d/webgl-engine/materials/internal/waterMaterialUtils":2715,"esri/views/3d/support/imageUtils":2716,"esri/views/3d/webgl-engine/shaders/DefaultMaterialTechnique":2717,"esri/views/3d/webgl-engine/core/shaderLibrary/util/TextureAtlasLookup.glsl":2718,"esri/views/3d/webgl-engine/lib/WebGLDriverTest":2719,"esri/views/3d/webgl-engine/shaders/sources/shaderRepository":2720,"esri/views/3d/webgl-engine/shaders/DefaultMaterial.glsl":2721,"esri/views/3d/webgl-engine/collections/Component/Material/shader/DecodeSymbolColor.glsl":2722,"esri/views/3d/webgl-engine/core/shaderLibrary/Offset.glsl":2723,"esri/views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl":2724,"esri/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl":2725,"esri/views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl":2726,"esri/views/3d/webgl-engine/core/shaderLibrary/util/DecodeNormal.glsl":2727,"esri/views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl":2728,"esri/views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl":2729,"esri/views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl":2730,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl":2731,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl":2732,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl":2733,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateMainLighting.glsl":2734,"esri/views/3d/webgl-engine/core/shaderLibrary/shading/Normals.glsl":2735,"esri/views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl":2736,"esri/views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl":2737,"esri/views/interactive/Manipulator3D":2738,"esri/views/3d/webgl-engine/lib/Intersector":2739,"esri/views/3d/interactive/dragUtils/dragAtLocation":2740,"esri/views/3d/webgl-engine/materials/NativeLineMaterial":2741,"esri/views/3d/webgl-engine/shaders/NativeLineTechnique":2742,"esri/views/3d/webgl-engine/shaders/NativeLine.glsl":2743,"esri/views/3d/webgl-engine/materials/RibbonLineMaterial":2744,"esri/views/3d/webgl-engine/materials/VisualVariableMaterialParameters":2745,"esri/views/3d/webgl-engine/shaders/RibbonLine.glsl":2746,"esri/views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl":2747,"esri/views/interactive/GraphicManipulator":2748,"esri/views/support/drapedUtils":2749,"esri/views/interactive/ManipulatorCollection":2750,"esri/views/3d/interactive/editingTools/graphicReshape3D/GraphicReshape3DTool":2751,"esri/views/3d/interactive/editingTools/graphicReshape3D/ReshapeOperation":2752,"esri/views/3d/interactive/editingTools/graphicTransform3D/GraphicTransform3DTool":2753,"esri/views/3d/interactive/editingTools/graphicTransform3D/GraphicScaleRotateTransform":2754,"esri/views/3d/interactive/editingTools/graphicTransform3D/dragUtils":2755,"esri/views/3d/webgl-engine/shaders/ColorMaterialTechnique":2756,"esri/views/3d/webgl-engine/shaders/ColorMaterial.glsl":2757,"esri/views/3d/interactive/editingTools/graphicTransform3D/GraphicXYAxisTransform":2758,"esri/views/3d/interactive/editingTools/graphicTransform3D/GraphicXYTransform":2759,"esri/views/3d/interactive/editingTools/graphicTransform3D/GraphicZTransform":2760})})(),(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{1628:function(e,t,n){var i;void 0===(i=function(){return function(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):(e.raw=t,e)}}.apply(null,[]))||(e.exports=i)},1629:function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=function(e,t){function n(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];for(var i="",r=0;r<t.length;r++)i+=e[r]+t[r];return i+e[e.length-1]}Object.defineProperty(t,"__esModule",{value:!0}),t.glsl=n,(n=t.glsl||(t.glsl={})).int=function(e){return Math.round(e).toString()}}.apply(null,i))||(e.exports=r)},1667:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(80),n(490),n(305)],void 0===(r=function(e,t,X,Y,K){function P(e,t,n,i){if(null==i||e.hasZ||(i=void 0),"point"===e.type)return e.x+=t,e.y+=n,e.hasZ&&null!=i&&(e.z+=i),e;if("multipoint"===e.type){for(var r=e.points,o=0;o<r.length;o++)r[o]=u(r[o],t,n,i);return e}if("extent"===e.type)return e.xmin+=t,e.xmax+=t,e.ymin+=n,e.ymax+=n,null!=i&&(e.zmin+=i,e.zmax+=i),e;for(var a=K.geometryToCoordinates(e),s="polyline"===e.type?e.paths:e.rings,l=0;l<a.length;l++){var c=a[l];for(o=0;o<c.length;o++)c[o]=u(c[o],t,n,i)}return"paths"in e?e.paths=s:e.rings=s,e}function u(e,t,n,i){return J(e,e[0]+t,e[1]+n,null!=e[2]&&null!=i?e[2]+i:void 0)}function J(e,t,n,i){var r=[t,n];return 2<e.length&&r.push(null!=i?i:e[2]),3<e.length&&r.push(e[3]),r}Object.defineProperty(t,"__esModule",{value:!0}),t.move=P,t.cloneMove=function(e,t,n,i,r){var o=e.clone(),a=i.resolution;if("point"===o.type){if(r)P(o,t*a,-n*a);else{var s=i.state.transform,l=i.state.inverseTransform,c=s[0]*o.x+s[2]*o.y+s[4],u=s[1]*o.x+s[3]*o.y+s[5];o.x=l[0]*(c+t)+l[2]*(u+n)+l[4],o.y=l[1]*(c+t)+l[3]*(u+n)+l[5]}return o}if("multipoint"===o.type){if(r)P(o,t*a,-n*a);else for(var d=o.points,p=(s=i.state.transform,l=i.state.inverseTransform,0);p<d.length;p++){var f=d[p],h=s[0]*f[0]+s[2]*f[1]+s[4],v=s[1]*f[0]+s[3]*f[1]+s[5];c=l[0]*(h+t)+l[2]*(v+n)+l[4],u=l[1]*(h+t)+l[3]*(v+n)+l[5];d[p]=J(f,c,u,void 0)}return o}if("extent"===o.type){if(r)P(o,t*a,-n*a);else{s=i.state.transform,l=i.state.inverseTransform;var m=s[0]*o.xmin+s[2]*o.ymin+s[4],g=s[1]*o.xmin+s[3]*o.ymin+s[5],y=s[0]*o.xmax+s[2]*o.ymax+s[4],b=s[1]*o.xmax+s[3]*o.ymax+s[5];o.xmin=l[0]*(m+t)+l[2]*(g+n)+l[4],o.ymin=l[1]*(m+t)+l[3]*(g+n)+l[5],o.xmax=l[0]*(y+t)+l[2]*(b+n)+l[4],o.ymax=l[1]*(y+t)+l[3]*(b+n)+l[5]}return o}if(r)P(o,t*a,-n*a);else{for(var _=K.geometryToCoordinates(o),x=(d="polyline"===o.type?o.paths:o.rings,s=i.state.transform,l=i.state.inverseTransform,0);x<_.length;x++){var S=_[x];for(p=0;p<S.length;p++){f=S[p],h=s[0]*f[0]+s[2]*f[1]+s[4],v=s[1]*f[0]+s[3]*f[1]+s[5],c=l[0]*(h+t)+l[2]*(v+n)+l[4],u=l[1]*(h+t)+l[3]*(v+n)+l[5];S[p]=J(f,c,u,void 0)}}"paths"in o?o.paths=d:o.rings=d}return o},t.scale=function(e,t,n,i){if("point"===e.type){var r=e.x,o=e.y,a=i?i[0]:r,s=i?i[1]:o,l=e.clone(),c=(r-a)*t+a,u=(o-s)*n+s;return l.x=c,l.y=u,l}if("multipoint"===e.type){for(var d=K.geometryToCoordinates(e),p=X.create(),f=Y.getRingsOrPathsBounds(p,[d]),h=f[0],v=f[1],m=f[2],g=f[3],y=i?i[0]:(h+m)/2,b=i?i[1]:(g+v)/2,_=e.clone(),x=_.points,S=0;S<x.length;S++){c=((r=(Z=x[S])[0])-y)*t+y,u=((o=Z[1])-b)*n+b;x[S]=J(Z,c,u,void 0)}return _}if("extent"===e.type){var P=e.xmin,w=e.xmax,A=e.ymin,C=e.ymax,O=i?i[0]:(P+w)/2,M=i?i[1]:(C+A)/2,D=e.clone();if(D.xmin=(P-O)*t+O,D.ymax=(C-M)*n+M,D.xmax=(w-O)*t+O,D.ymin=(A-M)*n+M,D.xmin>D.xmax){var T=D.xmin,R=D.xmax;D.xmin=R,D.xmax=T}if(D.ymin>D.ymax){var I=D.ymin,z=D.ymax;D.ymin=z,D.ymax=I}return D}for(var L=K.geometryToCoordinates(e),E=X.create(),V=Y.getRingsOrPathsBounds(E,L),N=V[0],j=V[1],F=V[2],G=V[3],H=i?i[0]:(N+F)/2,B=i?i[1]:(G+j)/2,U=e.clone(),k="polyline"===U.type?U.paths:U.rings,q=0;q<L.length;q++){var W=L[q];for(S=0;S<W.length;S++){var Z;c=((r=(Z=W[S])[0])-H)*t+H,u=((o=Z[1])-B)*n+B;k[q][S]=J(Z,c,u,void 0)}}return"paths"in U?U.paths=k:U.rings=k,U},t.getScaleRatio=function(e,t,n,i,r,o){var a=Math.sqrt((n-e)*(n-e)+(i-t)*(i-t));return Math.sqrt((r-e)*(r-e)+(o-t)*(o-t))/a},t.getRotationAngle=function(e,t,n,i,r,o){var a=180*Math.atan2(t-i,e-n)/Math.PI;return 180*Math.atan2(t-o,e-r)/Math.PI-a}}.apply(null,i))||(e.exports=r)},1677:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(12),n(484),n(118),n(486),n(2696),n(1646),n(1702),n(1703),n(2699),n(2738)],void 0===(r=function(e,t,r,s,l,o,a,c,i,u,d,p){function f(e,t){var n=1!==t,i=new d({diffuse:e,transparent:n,writeDepth:!n,cullFace:2,opacity:t,castShadows:!1,softwareInstanced:!0},"manipulator");return i.renderOccluded=4,i}function h(e,t,n,i){var r=l.vec3.normalize(c.sv3d.get(),e),o=l.vec3.normalize(c.sv3d.get(),t),a=l.vec3.cross(c.sv3d.get(),r,o);return i[0]=r[0],i[1]=r[1],i[2]=r[2],i[3]=0,i[4]=o[0],i[5]=o[1],i[6]=o[2],i[7]=0,i[8]=a[0],i[9]=a[1],i[10]=a[2],i[11]=0,i[12]=n[0],i[13]=n[1],i[14]=n[2],i[15]=1,i}Object.defineProperty(t,"__esModule",{value:!0}),t.createManipulatorMaterial=f,t.createSphereManipulator=function(e,t,n){return new p.Manipulator3D({view:e,renderObjects:[{geometry:new i(u.createSphereGeometry(1,32,32),"manipulator"),material:f(t,n)}]})},t.calculateInputRotationTransform=function(e,t,n,i){var r=l.vec3.subtract(c.sv3d.get(),e,n),o=h(r,l.vec3.cross(c.sv3d.get(),i,r),n,c.sm4d.get());s.mat4.invert(o,o);var a=l.vec3.transformMat4(c.sv3d.get(),t,o);return Math.atan2(a[1],a[0])},t.calculateTranslateRotateFromBases=h,t.placeManipulatorAtGraphic=function(e,t){var n=e.view.getViewForGraphic(t),i=r.isSome(n)&&"computeAttachmentOrigin"in n?n.computeAttachmentOrigin(t,e.view.spatialReference):null;r.isSome(i)?e.elevationAlignedLocation=i:function(e,t){if(!r.isNone(t)){var n=a.computeCentroid(t);r.isNone(n)||(e.location=o.hydrateGeometry(n))}}(e,t.geometry)}}.apply(null,i))||(e.exports=r)},1678:function(i,r,o){(function(e){var t,n;t=[o.dj.c(i.i),r,o(5),o(33),o(12),o(484),o(514),o(1633),o(118),o(150),o(1660),o(492),o(1673),o(1968),o(2703),o(1642)],void 0===(n=function(e,n,i,A,ne,r,t,o,s,a,l,g,y,c,u,d){function b(e,t,n,i,r,o,a,s,l){var c,u,d;if(a)return function(e,t,n,i,r,o,a,s,l){for(var c,u,d,p=o.data,f=o.offsetIdx,h=o.strideIdx,v=e[0],m=e[1],g=e[2],y=t[0],b=t[1],_=t[2],x=y-v,S=b-m,P=_-g,w=n;w<i;++w){var A=a[w],C=3*A,O=f+h*r[C++],M=p[O++],D=p[O++],T=p[O];O=f+h*r[C++];var R=p[O++],I=p[O++],z=p[O];O=f+h*r[C];var L=p[O++],E=p[O++],V=p[O];ne.isSome(s)&&(c=s.applyToVertex(M,D,T),M=c[0],D=c[1],T=c[2],u=s.applyToVertex(R,I,z),R=u[0],I=u[1],z=u[2],d=s.applyToVertex(L,E,V),L=d[0],E=d[1],V=d[2]);var N=R-M,j=I-D,F=z-T,G=L-M,H=E-D,B=V-T,U=S*B-H*P,k=P*G-B*x,q=x*H-G*S,W=N*U+j*k+F*q;if(!(Math.abs(W)<=re)){var Z=v-M,X=m-D,Y=g-T,K=Z*U+X*k+Y*q;if(0<W){if(K<0||W<K)continue}else if(0<K||K<W)continue;var J=X*F-j*Y,Q=Y*N-F*Z,$=Z*j-N*X,ee=x*J+S*Q+P*$;if(0<W){if(ee<0||W<K+ee)continue}else if(0<ee||K+ee<W)continue;var te=(G*J+H*Q+B*$)/W;0<=te&&l(te,ie(N,j,F,G,H,B,oe),A)}}}(e,t,n,i,r,o,a,s,l);for(var p=o.data,f=o.offsetIdx,h=o.strideIdx,v=e[0],m=e[1],g=e[2],y=t[0]-v,b=t[1]-m,_=t[2]-g,x=n,S=3*n;x<i;++x){var P=f+h*r[S++],w=p[P++],A=p[P++],C=p[P];P=f+h*r[S++];var O=p[P++],M=p[P++],D=p[P];P=f+h*r[S++];var T=p[P++],R=p[P++],I=p[P];ne.isSome(s)&&(w=(c=s.applyToVertex(w,A,C))[0],A=c[1],C=c[2],O=(u=s.applyToVertex(O,M,D))[0],M=u[1],D=u[2],T=(d=s.applyToVertex(T,R,I))[0],R=d[1],I=d[2]);var z=O-w,L=M-A,E=D-C,V=T-w,N=R-A,j=I-C,F=b*j-N*_,G=_*V-j*y,H=y*N-V*b,B=z*F+L*G+E*H;if(!(Math.abs(B)<=re)){var U=v-w,k=m-A,q=g-C,W=U*F+k*G+q*H;if(0<B){if(W<0||B<W)continue}else if(0<W||W<B)continue;var Z=k*E-L*q,X=q*z-E*U,Y=U*L-z*k,K=y*Z+b*X+_*Y;if(0<B){if(K<0||B<W+K)continue}else if(0<K||W+K<B)continue;var J=(V*Z+N*X+j*Y)/B;0<=J&&l(J,ie(z,L,E,V,N,j,oe),x)}}}function ie(e,t,n,i,r,o,a){return s.vec3.set(m,e,t,n),s.vec3.set(w,i,r,o),s.vec3.cross(a,m,w),s.vec3.normalize(a,a),a}function _(e,t,n){return s.vec3.set(n,1/(t[0]-e[0]),1/(t[1]-e[1]),1/(t[2]-e[2]))}function x(e,t,n,i){return p(e,t,n,i,1/0)}function p(e,t,n,i,r){var o=(e[0]-i-t[0])*n[0],a=(e[3]+i-t[0])*n[0],s=Math.min(o,a),l=Math.max(o,a),c=(e[1]-i-t[1])*n[1],u=(e[4]+i-t[1])*n[1];if((l=Math.min(l,Math.max(c,u)))<0)return!1;if((s=Math.max(s,Math.min(c,u)))>l)return!1;var d=(e[2]-i-t[2])*n[2],p=(e[5]+i-t[2])*n[2];return!((l=Math.min(l,Math.max(d,p)))<0)&&!((s=Math.max(s,Math.min(d,p)))>l)&&s<r}function f(e,t,n,i){return u.scale(e,n,t,i)}function h(e){var t=[];return e.forEach(function(e){return t.push(e)}),t}Object.defineProperty(n,"__esModule",{value:!0});var v=o.mat4f64.create(),S=g.create(),C=d.VertexAttrConstants;n.intersectTriangleGeometry=function(e,t,n,i,r,o,a){var s=t&&t.componentVisibilities,l=n.tolerance;if(1<e.componentCount)!function(e,t,n,i,r,o,a){var s=_(n,i,P),l=e.componentCount,c=e.componentOffsets,u=e.getIndices(C.POSITION),d=e.getAttribute(C.POSITION),p=e.boundingInfo;if(!p||(g.setMin(S,p.getBBMin()),g.setMax(S,p.getBBMax()),ne.isSome(o)&&o.applyToAABB(S),x(S,n,s,r)))for(var f=0;f<l;f++)if(!t||y.getVisibility(t,f)){if(e.getComponentAABB){var h=e.getComponentAABB(f,S);if(ne.isSome(o)&&o.applyToAABB(h),!x(h,n,s,r))continue}var v=c[f]/3,m=c[f+1]/3;b(n,i,v,m,u,d,void 0,o,a)}}(e,s,i,r,l,o,a);else if(!s||y.getVisibility(s,0))if(e.boundingInfo)d.assert("triangle"===e.data.primitiveType),function e(t,n,i,r,o,a){var s=_(n,i,P);if(g.setMin(S,t.getBBMin()),g.setMax(S,t.getBBMax()),ne.isSome(o)&&o.applyToAABB(S),x(S,n,s,r)){var l=t.getPrimitiveIndices(),c=t.getIndices(),u=t.getPosition(),d=l?l.length:c.length/3;if(z<d){var p=t.getChildren();if(void 0!==p){for(var f=0;f<8;++f)void 0!==p[f]&&e(p[f],n,i,r,o,a);return}}b(n,i,0,d,c,u,l,o,a)}}(e.boundingInfo,i,r,l,o,a);else{var c=e.getIndices(C.POSITION),u=e.getAttribute(C.POSITION);b(i,r,0,c.length/3,c,u,void 0,o,a)}};var P=a.vec3f64.create(),re=Math.pow(2,-52),oe=a.vec3f64.create();n.intersectTriangles=b;var m=a.vec3f64.create(),w=a.vec3f64.create();n.computeNormal=ie,n.computeInvDir=_,n.intersectAabbInvDir=x,n.intersectAabbInvDirBefore=p,n.transformToWorld=function(e,t,n){return l.vec4.set(n,e[0]-t[0],e[1]-t[1],e[2]-t[2],1)},n.transformToView=function(e,t,n,i){return r.mat4.translate(v,n,t),n=v,l.vec4.transformMat4(i,e,n)},n.transformToProjection=function(e,t,n,i){return i[0]=e[0]+n[0],i[1]=e[1]+n[1],i[2]=e[2]+n[2],i[3]=e[3],l.vec4.transformMat4(i,i,t)},n.transformToNDC=function(e,t){return l.vec4.scale(t,e,1/Math.abs(e[3]))},n.applyScreenSizePerspectiveScale=f,n.verticalOffsetAtDistance=function(e,t,n,i,r){var o=(n.screenLength||0)*e.pixelRatio;r&&(o=f(o,t,i,r));var a=o*Math.tan(.5*e.fovY)/(.5*e.fullHeight);return A.clamp(a*t,n.minWorldLength||0,null!=n.maxWorldLength?n.maxWorldLength:1/0)},n.acquireIfNotUndefined=function(e,t,n){if(void 0!==e)return t.acquire(e,n)},n.releaseIfNotUndefined=function(e,t){void 0!==e&&t.release(e)};var O=t.mat4f32.create();n.bindView=function(e,t,n){r.mat4.translate(O,t,e),n.setUniform3fv("localOrigin",e),n.setUniformMatrix4fv("view",O)},n.bindCamPos=function(e,t,n){n.setUniform3f("camPos",t[3]-e[0],t[7]-e[1],t[11]-e[2])};var M=a.vec3f64.create(),D=a.vec3f64.create();n.bindViewOriginDouble=function(e,t){c.encodeDoubleArraySplit(e,M,D,3),t.setUniform3fv("viewOriginHi",M),t.setUniform3fv("viewOriginLo",D)};var T,R=a.vec3f64.create();function I(e){return(e.shadowMappingEnabled?1:0)|(e.ssaoEnabled?2:0)}n.bindSlicePlane=function(e,t,n){s.vec3.subtract(R,t.origin,e),n.setUniform3fv("slicePlaneOrigin",R),n.setUniform3fv("slicePlaneBasis1",t.basis1),n.setUniform3fv("slicePlaneBasis2",t.basis2)},n.bindVerticalOffset=function(e,t,n){if(e){var i=(o=e,a=t.fovY,s=t.viewport[3],void 0===l&&(l=L),l.screenLength=o.screenLength,l.perDistance=Math.tan(.5*a)/(.5*s),l.minWorldLength=o.minWorldLength,l.maxWorldLength=o.maxWorldLength,l),r=t.pixelRatio||1;n.setUniform4f("verticalOffset",i.screenLength*r,i.perDistance,i.minWorldLength,i.maxWorldLength)}var o,a,s,l},n.bindHighlightRendering=function(e,t,n){e.bindTexture(t.highlightDepthTexture,5),n.setUniform1i("depthTex",5),n.setUniform4f("highlightViewportPixelSz",0,0,1/t.viewport[2],1/t.viewport[3])},n.bindScreenSizePerspective=function(e,t,n){if(void 0===n&&(n="screenSizePerspectiveAlignment"),e){var i=e.parameters,r=e.paddingPixelsOverride;t.setUniform4f(n,i.divisor,i.offset,i.minPixelSize,r)}},n.copyParameters=function e(t,n){var i=n?e(n):{};for(var r in t){var o=t[r];o&&o.forEach&&(o=h(o)),null==o&&r in i||(i[r]=o)}return i},n.updateParameters=function(e,t){var n=!1;for(var i in t){var r=t[i];void 0!==r&&(n=!0,Array.isArray(r)?e[i]=r.slice():e[i]=r)}return n},(T=n.BindParametersMap||(n.BindParametersMap={})).create=function(e,t){for(var n=[],i=0;i<2;i++)for(var r=0;r<2;r++){var o=I({shadowMappingEnabled:1===i,ssaoEnabled:1===r}),a=I({shadowMappingEnabled:1===i,ssaoEnabled:1===r&&e.receiveSSAO});n[o]=n[a]||t({receiveShadows:1===i,receiveSSAO:1===r&&e.receiveSSAO})}return{programs:n.filter(function(e){return null!=e}),byParameter:n}},T.lookup=function(e,t){return e.byParameter[I(t)]},T.programs=function(e){return e.programs},n.intersectDrapedRenderLineGeometry=function(e,t,n,i,r){if(t.options.selectionMode){for(var o=e.getAttribute(C.POSITION).data,a=e.getAttribute(C.SIZE),s=a&&a.data[0],l=n[0],c=n[1],u=((s+i)/2+4)*e.pixelRatio,d=Number.MAX_VALUE,p=0;p<o.length-5;p+=3){var f=o[p],h=o[p+1],v=l-f,m=c-h,g=o[p+3]-f,y=o[p+4]-h,b=g*v+y*m,_=g*g+y*y,x=A.clamp(b/_,0,1),S=g*x-v,P=y*x-m,w=S*S+P*P;w<d&&(d=w)}d<u*u&&r()}},n.colorMixModes={multiply:1,ignore:2,replace:3,tint:4};var z=1e3,L={screenLength:0,perDistance:0,minWorldLength:0,maxWorldLength:0};n.defaultPBRMaterialParameters={roughnessFactor:.6,metallicFactor:0,reflectanceFactor:.2},n.defaultPBRTreeMaterialParameters={roughnessFactor:1,metallicFactor:0,reflectanceFactor:.2},n.getDefaultPBRMaterialParameters=function(e,t){return i({usePBR:e},t?n.defaultPBRTreeMaterialParameters:n.defaultPBRMaterialParameters)}}.apply(null,t))||(i.exports=n)}).call(this,require("jquery"))},1679:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(118),n(150),n(1629)],void 0===(r=function(e,t,n,r,i,o){function a(e,t){t.slicePlaneEnabled?(e.extensions.add("GL_OES_standard_derivatives"),e.fragment.uniforms.add("slicePlaneOrigin","vec3"),e.fragment.uniforms.add("slicePlaneBasis1","vec3"),e.fragment.uniforms.add("slicePlaneBasis2","vec3"),e.fragment.code.add(o.glsl(l=l||n(["\n      struct SliceFactors {\n        float front;\n        float side0;\n        float side1;\n        float side2;\n        float side3;\n      };\n\n      SliceFactors calculateSliceFactors(vec3 pos) {\n        vec3 rel = pos - slicePlaneOrigin;\n\n        vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);\n        float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);\n\n        float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);\n        float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);\n\n        float basis1Dot = dot(slicePlaneBasis1, rel);\n        float basis2Dot = dot(slicePlaneBasis2, rel);\n\n        return SliceFactors(\n          dot(slicePlaneNormal, pos) + slicePlaneW,\n          -basis1Dot - basis1Len2,\n          basis1Dot - basis1Len2,\n          -basis2Dot - basis2Len2,\n          basis2Dot - basis2Len2\n        );\n      }\n\n      bool sliceByFactors(SliceFactors factors) {\n        return factors.front < 0.0\n          && factors.side0 < 0.0\n          && factors.side1 < 0.0\n          && factors.side2 < 0.0\n          && factors.side3 < 0.0;\n      }\n\n      bool sliceByPlane(vec3 pos) {\n        return sliceByFactors(calculateSliceFactors(pos));\n      }\n\n      vec4 applySliceHighlight(vec4 color, vec3 pos) {\n        SliceFactors factors = calculateSliceFactors(pos);\n\n        if (sliceByFactors(factors)) {\n          return color;\n        }\n\n        const float HIGHLIGHT_WIDTH = 1.0;\n        const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);\n\n        factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);\n        factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);\n        factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);\n        factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);\n        factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);\n\n        float highlightFactor = (1.0 - step(0.5, factors.front))\n          * (1.0 - step(0.5, factors.side0))\n          * (1.0 - step(0.5, factors.side1))\n          * (1.0 - step(0.5, factors.side2))\n          * (1.0 - step(0.5, factors.side3));\n\n        return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);\n      }\n      #define rejectBySlice(_pos_) sliceByPlane(_pos_)\n      #define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }\n      "],["\n      struct SliceFactors {\n        float front;\n        float side0;\n        float side1;\n        float side2;\n        float side3;\n      };\n\n      SliceFactors calculateSliceFactors(vec3 pos) {\n        vec3 rel = pos - slicePlaneOrigin;\n\n        vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);\n        float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);\n\n        float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);\n        float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);\n\n        float basis1Dot = dot(slicePlaneBasis1, rel);\n        float basis2Dot = dot(slicePlaneBasis2, rel);\n\n        return SliceFactors(\n          dot(slicePlaneNormal, pos) + slicePlaneW,\n          -basis1Dot - basis1Len2,\n          basis1Dot - basis1Len2,\n          -basis2Dot - basis2Len2,\n          basis2Dot - basis2Len2\n        );\n      }\n\n      bool sliceByFactors(SliceFactors factors) {\n        return factors.front < 0.0\n          && factors.side0 < 0.0\n          && factors.side1 < 0.0\n          && factors.side2 < 0.0\n          && factors.side3 < 0.0;\n      }\n\n      bool sliceByPlane(vec3 pos) {\n        return sliceByFactors(calculateSliceFactors(pos));\n      }\n\n      vec4 applySliceHighlight(vec4 color, vec3 pos) {\n        SliceFactors factors = calculateSliceFactors(pos);\n\n        if (sliceByFactors(factors)) {\n          return color;\n        }\n\n        const float HIGHLIGHT_WIDTH = 1.0;\n        const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);\n\n        factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);\n        factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);\n        factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);\n        factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);\n        factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);\n\n        float highlightFactor = (1.0 - step(0.5, factors.front))\n          * (1.0 - step(0.5, factors.side0))\n          * (1.0 - step(0.5, factors.side1))\n          * (1.0 - step(0.5, factors.side2))\n          * (1.0 - step(0.5, factors.side3));\n\n        return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);\n      }\n      #define rejectBySlice(_pos_) sliceByPlane(_pos_)\n      #define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }\n      "]))),t.sliceHighlightDisabled?e.fragment.code.add(o.glsl(c=c||n(["\n        #define highlightSlice(_color_, _pos_) (_color_)\n      "],["\n        #define highlightSlice(_color_, _pos_) (_color_)\n      "]))):e.fragment.code.add(o.glsl(u=u||n(["\n      #define highlightSlice(_color_, _pos_) applySliceHighlight(_color_, _pos_)\n    "],["\n      #define highlightSlice(_color_, _pos_) applySliceHighlight(_color_, _pos_)\n    "])))):e.fragment.code.add(o.glsl(d=d||n(["\n      #define rejectBySlice(_pos_) false\n      #define discardBySlice(_pos_) {}\n      #define highlightSlice(_color_, _pos_) (_color_)\n    "],["\n      #define rejectBySlice(_pos_) false\n      #define discardBySlice(_pos_) {}\n      #define highlightSlice(_color_, _pos_) (_color_)\n    "])))}var s;Object.defineProperty(t,"__esModule",{value:!0}),t.Slice=a,(s=a=t.Slice||(t.Slice={})).bindUniformsWithOrigin=function(e,t,n){s.bindUniforms(e,t,n.slicePlane,n.origin)},s.bindUniforms=function(e,t,n,i){t.slicePlaneEnabled&&(i?(r.vec3.subtract(p,n.origin,i),e.setUniform3fv("slicePlaneOrigin",p)):e.setUniform3fv("slicePlaneOrigin",n.origin),e.setUniform3fv("slicePlaneBasis1",n.basis1),e.setUniform3fv("slicePlaneBasis2",n.basis2))};var l,c,u,d,p=i.vec3f64.create()}.apply(null,i))||(e.exports=r)},1687:function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=function(e,t){function r(e,t){return t&&t.xoffset?Math.max(e,Math.abs(t.xoffset)):t&&t.yoffset?Math.max(e,Math.abs(t.yoffset)):e}function s(e,t){return"number"==typeof e?e:e&&e.stops&&e.stops.length?function(e){for(var t=0,n=0,i=0;i<e.length;i++){var r=e[i].size;"number"==typeof r&&(t+=r,n++)}return t/n}(e.stops):t}Object.defineProperty(t,"__esModule",{value:!0}),t.calculateTolerance=function(e){if(!e)return 6;var t="visualVariables"in e?function(i,e){if(!e)return i;var t=e.filter(function(e){return"size"===e.type}).map(function(e){var t=e.maxSize,n=e.minSize;return(s(t,i)+s(n,i))/2}),n=0,r=t.length;if(0===r)return i;for(var o=0;o<r;o++)n+=t[o];var a=Math.floor(n/r);return Math.max(a,i)}(6,e.visualVariables):6;if("simple"===e.type)return r(t,e.symbol);if("unique-value"===e.type){var n=t;return e.uniqueValueInfos.forEach(function(e){n=r(n,e.symbol)}),n}if("class-breaks"!==e.type)return e.type,t;var i=t;return e.classBreakInfos.forEach(function(e){i=r(i,e.symbol)}),i}}.apply(null,i))||(e.exports=r)},1693:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(484),n(514),n(1629)],void 0===(r=function(e,t,n,i,r,o){function a(e,t){t.linearDepth?e.vertex.code.add(o.glsl(s=s||n(["\n    vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {\n      vec4 eye = view * vec4(pos, 1.0);\n      depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\n      return proj * eye;\n    }\n    "],["\n    vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {\n      vec4 eye = view * vec4(pos, 1.0);\n      depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\n      return proj * eye;\n    }\n    "]))):e.vertex.code.add(o.glsl(l=l||n(["\n    vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {\n      // Make sure the order of operations is the same as in transformPositionWithDepth.\n      return proj * (view * vec4(pos, 1.0));\n    }\n    "],["\n    vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {\n      // Make sure the order of operations is the same as in transformPositionWithDepth.\n      return proj * (view * vec4(pos, 1.0));\n    }\n    "])))}Object.defineProperty(t,"__esModule",{value:!0}),t.Transform=a,(a=t.Transform||(t.Transform={})).bindUniforms=function(e,t){i.mat4.translate(c,t.view,t.origin),e.setUniform3fv("localOrigin",t.origin),e.setUniformMatrix4fv("view",c)};var s,l,c=r.mat4f32.create()}.apply(null,i))||(e.exports=r)},1700:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(0),n(5),n(28),n(34),n(54),n(12),n(15),n(214),n(1654),n(484),n(1633),n(48),n(118),n(150),n(80),n(486),n(1650),n(211),n(1646),n(2692),n(1966),n(1852)],void 0===(r=function(e,t,n,i,r,O,o,a,M,D,s,l,c,T,R,u,d,p,I,f,z,h,v,m){function g(e){return 0!==e[12]||0!==e[13]||0!==e[14]}Object.defineProperty(t,"__esModule",{value:!0});var y=(b.prototype.destroy=function(){this._removeResourcesFromStage(),this._engineResources=null,this.view=null,this.camera=null},Object.defineProperty(b.prototype,"elevationInfo",{get:function(){return this._elevationInfo},set:function(e){this._elevationInfo=e,this._elevationAlignedLocationDirty=!0,this._updateEngineObject()},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"hideOnGrab",{get:function(){return this._hideOnGrab},set:function(e){this._hideOnGrab!==e&&(this._hideOnGrab=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"visible",{get:function(){return this._visible},set:function(e){e!==this._visible&&(this._visible=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"radius",{get:function(){return this._radius},set:function(e){e!==this._radius&&(this._radius=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"worldSized",{get:function(){return this._worldSized},set:function(e){e!==this._worldSized&&(this._worldSized=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"modelTransform",{get:function(){return this._modelTransform},set:function(e){g(e)&&(this._screenLocationDirty=!0),l.mat4.copy(this._modelTransform,e),this._updateEngineObject()},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"renderLocation",{get:function(){return this._renderLocationDirty&&(this._renderLocationDirty=!1,this.view.renderCoordsHelper.toRenderCoords(this.elevationAlignedLocation,this._renderLocation),this.worldOriented?(this._worldFrame||(this._worldFrame=c.mat4f64.create()),f.computeLinearTransformation(this.view.renderSpatialReference,this._renderLocation,this._worldFrame,this.view.renderSpatialReference),this._worldFrame[12]=0,this._worldFrame[13]=0,this._worldFrame[14]=0):this._worldFrame&&(this._worldFrame=null)),this._renderLocation},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"location",{get:function(){return this._location},set:function(e){p.clonePoint(e,this._location),this._renderLocationDirty=!0,this._screenLocationDirty=!0,this._elevationAlignedLocationDirty=!0,this._updateEngineObject()},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"elevationAlignedLocation",{get:function(){return this._elevationAlignedLocationDirty?(this._evaluateElevationAlignment(),this._updateElevationAlignedLocation(),this._elevationAlignedLocation):this.elevationAlignedLocation},set:function(e){p.clonePoint(e,this._location),this._evaluateElevationAlignment(),this._location.z-=this._elevation.offset,this._updateElevationAlignedLocation(),this._updateEngineObject()},enumerable:!0,configurable:!0}),b.prototype._updateElevationAlignedLocation=function(){this._elevationAlignedLocation.x=this.location.x,this._elevationAlignedLocation.y=this.location.y;var e=a.isSome(this._elevation.override)?this._elevation.override:this.location.z||0;this._elevationAlignedLocation.z=e+this._elevation.offset,this._elevationAlignedLocation.spatialReference=this.location.spatialReference,this._renderLocationDirty=!0,this._screenLocationDirty=!0},Object.defineProperty(b.prototype,"grabbing",{get:function(){return this._grabbing},set:function(e){e!==this._grabbing&&(this._grabbing=e,this._setFocused(this._hovering||this._grabbing),this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"hovering",{get:function(){return this._hovering},set:function(e){e!==this._hovering&&(this._hovering=e,this._setFocused(this._hovering||this._grabbing),this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"selected",{get:function(){return this._selected},set:function(e){e!==this._selected&&(this._selected=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"state",{get:function(){return this._state},set:function(e){e!==this._state&&(this._state=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),b.prototype._setFocused=function(e){e!==this._focused&&(this._focused=e,this.events.emit("focus",{action:!0===e?"focus":"unfocus"}))},Object.defineProperty(b.prototype,"focused",{get:function(){return this._focused},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"screenLocation",{get:function(){return this.ensureScreenLocation(),this._screenLocation},enumerable:!0,configurable:!0}),b.prototype.ensureScreenLocation=function(){if(this._screenLocationDirty){var e;if(this._screenLocation.pixelSize=this.camera.computeScreenPixelSizeAt(this.renderLocation),this._screenLocationDirty=!1,g(this._modelTransform)){var t=this._calculateModelTransformOffset(x);e=R.vec3.add(t,t,this.renderLocation)}else e=this.renderLocation;this.camera.projectPoint(e,this._screenLocation.renderScreenPointArray),this.camera.renderToScreen(this._screenLocation.renderScreenPointArray,this._screenLocation.screenPointArray)}},b.prototype.intersectionDistance=function(e,t){if(!this.visible)return null;var n=M.screenPointObjectToArray(e,L),i=this._getCollisionRadius(t),r=-1*this.collisionPriority;switch(this.collisionType.type){case"point":if(T.vec2.squaredDistance(this.screenLocation.screenPointArray,n)<i*i)return this.screenLocation.renderScreenPointArray[2]+r;break;case"line":for(var o=this.collisionType.paths,a=this._getWorldToScreenObjectScale(),s=this._calculateObjectTransform(a,j),l=i*this.screenLocation.pixelSize,c=I.ray.fromScreen(this.camera,n,V),u=0,d=o;u<d.length;u++)if(0!==(A=d[u]).length)for(var p=R.vec3.transformMat4(G,A[0],s),f=1;f<A.length;f++){var h=R.vec3.transformMat4(H,A[f],s);if(null!=(C=I.lineSegment.closestRayDistance2(I.lineSegment.fromPoints(p,h,E),c))&&C<l*l){var v=R.vec3.add(z.sv3d.get(),p,h);R.vec3.scale(v,v,.5);var m=M.castRenderScreenPointArray(z.sv3d.get());return this.camera.projectPoint(v,m),m[2]+r}R.vec3.copy(p,h)}break;case"disc":var g=this.collisionType.direction,y=(a=this._getWorldToScreenObjectScale(),s=this._calculateObjectTransform(a,j),l=i*this.screenLocation.pixelSize,c=I.ray.fromScreen(this.camera,n,V),D.mat3.fromMat4(N,s)),b=R.vec3.transformMat3(U,g,y),_=this._calculateModelTransformPosition(k);I.plane.fromPositionAndNormal(_,b,F);var x=B;if(I.plane.intersectRay(F,c,x)&&R.vec3.squaredDistance(x,_)<l*l)return this.screenLocation.renderScreenPointArray[2]+r;break;case"ribbon":var S=this.collisionType;if(o=S.paths,g=S.direction,a=this._getWorldToScreenObjectScale(),s=this._calculateObjectTransform(a,j),l=i*this.camera.computeScreenPixelSizeAt(this.renderLocation),c=I.ray.fromScreen(this.camera,n,V),y=D.mat3.fromMat4(N,s),b=R.vec3.transformMat3(U,g,y),_=this._calculateModelTransformPosition(k),I.plane.fromPositionAndNormal(_,b,F),x=B,!I.plane.intersectRay(F,c,x))break;for(var P=0,w=o;P<w.length;P++){var A;if(0!==(A=w[P]).length)for(p=R.vec3.transformMat4(G,A[0],s),f=1;f<A.length;f++){var C;if(h=R.vec3.transformMat4(H,A[f],s),null!=(C=I.lineSegment.distance2(I.lineSegment.fromPoints(p,h,E),x))&&C<l*l)return v=R.vec3.add(z.sv3d.get(),p,h),R.vec3.scale(v,v,.5),m=M.castRenderScreenPointArray(z.sv3d.get()),this.camera.projectPoint(v,m),m[2]+r;R.vec3.copy(p,h)}}break;default:O.neverReached(this.collisionType)}return null},b.prototype.attach=function(e){if(void 0===e&&(e={manipulator3D:{}}),this.view._stage){var t=e.manipulator3D;if(this._engineLayerId=t.engineLayerId,a.isNone(this._engineLayerId)){var n=new v("manipulator-3d",{isPickable:!1});this.view._stage.add(0,n),this.view._stage.addToViewContent([n.id]),this._engineLayerId=n.id,t.engineLayerId=n.id}t.engineLayerReferences=(t.engineLayerReferences||0)+1,this._materialIdReferences=t.materialIdReferences,a.isNone(this._materialIdReferences)&&(this._materialIdReferences=new Map,t.materialIdReferences=this._materialIdReferences),this.camera.copyFrom(this.view.state.camera),this._attached=!0,this._updateEngineObject(),f.canProject(this._location.spatialReference,this.view.spatialReference)||(this.location=new r.Point({x:0,y:0,z:0,spatialReference:this.view.spatialReference}))}},b.prototype.detach=function(e){void 0===e&&(e={manipulator3D:{}});var t=e.manipulator3D;t.engineLayerReferences--;var n=0===t.engineLayerReferences;n&&(t.engineLayerId=null),this._removeResourcesFromStage(n),this._engineResources=null,this._engineLayerId=null,this._materialIdReferences=null,this._attached=!1},b.prototype.onViewChange=function(){this.camera.copyFrom(this.view.state.camera),this._screenLocationDirty=!0,this._updateEngineObject()},b.prototype.onElevationChange=function(e){d.containsPointObject(e.extent,this.location)&&(this._elevationAlignedLocationDirty=!0,this._updateEngineObject())},b.prototype._evaluateElevationAlignment=function(e){if(void 0===e&&(e=this.location),a.isNone(this.elevationInfo))return!1;var t=null,n=0;switch(this.elevationInfo.mode){case"on-the-ground":t=this.view.elevationProvider.getElevation(e,"ground")||0;break;case"relative-to-ground":n=(this.view.elevationProvider.getElevation(e,"ground")||0)+(this.elevationInfo.offset||0);break;case"relative-to-scene":n=(this.view.elevationProvider.getElevation(e,"scene")||0)+(this.elevationInfo.offset||0);break;case"absolute-height":n=this.elevationInfo.offset||0}return(n!==this._elevation.offset||t!==this._elevation.override)&&(this._elevation.offset=n,this._elevation.override=t,!0)},b.prototype._updateEngineObject=function(){if(this._attached){if(!1===this.visible)return void this._removeResourcesFromStage();var e=this._getWorldToScreenObjectScale(),t=j;if(!0===this.autoScaleRenderObjects){var n=this._getFocusedSize(this._radius,this.focused)*e;this._calculateObjectTransform(n,t)}else this._calculateObjectTransform(e,t);for(var i=this._ensureEngineResources().objectsByState,r=(this.focused?2:1)|(this.selected?8:4),o=this.hideOnGrab&&this.grabbing,a=0,s=i;a<s.length;a++){var l=s[a],c=l.stateMask,u=l.objects;if(o)for(var d=0,p=u;d<p.length;d++)(b=p[d]).hideAllComponents();else{var f=!(0!=(15&c))||(r&c)==(15&c),h=!(0!=(65520&c))||(this.state&c)==(65520&c);if(f&&h)for(var v=0,m=u;v<m.length;v++)(b=m[v]).unhideAllComponents(),b.objectTransformation=t;else for(var g=0,y=u;g<y.length;g++){var b;(b=y[g]).hideAllComponents()}}}}},b.prototype._ensureEngineResources=function(){if(a.isNone(this._engineResources)){var e=this.view._stage.getContent(0,a.expect(this._engineLayerId)),n=[],i=new Set;this.renderObjects.forEach(function(e){var t=e.material;i.has(t)||(n.push(t),i.add(t))});var c=new Map;this.renderObjects.forEach(function(e){var t,n,i,r,o,a=new m({idHint:"manipulator"});t=a,i=(n=e).geometry,r=n.material,o=n.transform,Array.isArray(i)?i.forEach(function(e){return t.addGeometry(e,r,o)}):t.addGeometry(i,r,o);var s=e.stateMask||0,l=c.get(s)||[];l.push(a),c.set(s,l)});var r=[];c.forEach(function(e,t){r.push({stateMask:t,objects:e})}),this._engineResources={objectsByState:r,layer:e,materials:n}}return this._addResourcesToStage(),this._engineResources},b.prototype._addResourcesToStage=function(){var i=this;if(!this._engineResourcesAddedToStage&&!a.isNone(this._engineResources)){var e=this._engineResources,t=e.objectsByState,n=e.layer;e.materials.forEach(function(e){var t=a.expect(i._materialIdReferences),n=t.get(e.id)||0;0===n&&i.view._stage.add(3,e),t.set(e.id,n+1)}),t.forEach(function(e){e.objects.forEach(function(e){n.addObject(e),i.view._stage.add(1,e)})}),this._engineResourcesAddedToStage=!0}},b.prototype._removeResourcesFromStage=function(e){var i=this;if(void 0===e&&(e=!1),this._engineResourcesAddedToStage&&!a.isNone(this._engineResources)){var t=this._engineResources,n=t.objectsByState,r=t.layer,o=t.materials;n.forEach(function(e){e.objects.forEach(function(e){r.removeObject(e),i.view._stage.remove(1,e.id)})}),o.forEach(function(e){var t=a.expect(i._materialIdReferences),n=t.get(e.id);1===n?(i.view._stage.remove(3,e.id),t.delete(e.id)):t.set(e.id,n-1)}),e&&this.view._stage.remove(0,r.id),this._engineResourcesAddedToStage=!1}},b.prototype._getCollisionRadius=function(e){return this._getFocusedSize(this.radius,!0)*("touch"===e?this.touchMultiplier:1)},b.prototype._getFocusedSize=function(e,t){return e*(t?this.focusMultiplier:1)},b.prototype._getWorldToScreenObjectScale=function(){return this._worldSized?1:this.screenLocation.pixelSize},b.prototype._calculateModelTransformPosition=function(e){var t=this._getWorldToScreenObjectScale(),n=this._calculateObjectTransform(t,_);return R.vec3.set(e,n[12],n[13],n[14])},b.prototype._calculateModelTransformOffset=function(e){var t=this._calculateModelTransformPosition(e);return R.vec3.subtract(e,t,this.renderLocation)},b.prototype._calculateObjectTransform=function(e,t){return l.mat4.set(t,e,0,0,0,0,e,0,0,0,0,e,0,0,0,0,1),l.mat4.multiply(t,t,this._modelTransform),this._worldFrame&&l.mat4.multiply(t,t,this._worldFrame),t[12]+=this.renderLocation[0],t[13]+=this.renderLocation[1],t[14]+=this.renderLocation[2],t[15]=1,t},b);function b(e){for(var t in this.camera=new h.default,this._elevation={offset:0,override:0},this._hideOnGrab=!1,this.collisionType={type:"point"},this.collisionPriority=0,this.renderObjects=[],this.autoScaleRenderObjects=!0,this._visible=!0,this._radius=10,this._worldSized=!1,this.focusMultiplier=2,this.touchMultiplier=2.5,this.worldOriented=!1,this._modelTransform=c.mat4f64.create(),this._worldFrame=null,this._renderLocation=u.vec3f64.create(),this._renderLocationDirty=!0,this._elevationAlignedLocation=new r.Point,this._elevationAlignedLocationDirty=!0,this.interactive=!0,this.selectable=!1,this.cursor=null,this._grabbing=!1,this.dragging=!1,this._hovering=!1,this._selected=!1,this._state=0,this._focused=!1,this.events=new o({target:this}),this._screenLocation={screenPointArray:M.createScreenPointArray(),renderScreenPointArray:M.createRenderScreenPointArray3(),pixelSize:0},this._screenLocationDirty=!0,this._engineResourcesAddedToStage=!1,this._engineResources=null,this._attached=!1,this._engineLayerId=null,this._materialIdReferences=null,this._location=new r.Point({x:0,y:0,z:0,spatialReference:e.view.spatialReference}),e)this[t]=e[t];this.view.state&&this.view.state.camera&&this.camera.copyFrom(this.view.state.camera)}t.Manipulator3D=y;var L=M.createScreenPointArray(),E=I.lineSegment.create(),V=I.ray.create(),N=s.mat3f64.create(),_=c.mat4f64.create(),j=c.mat4f64.create(),F=I.plane.create(),G=u.vec3f64.create(),H=u.vec3f64.create(),B=u.vec3f64.create(),U=u.vec3f64.create(),k=u.vec3f64.create(),x=u.vec3f64.create()}.apply(null,i))||(e.exports=r)},1701:function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=function(e,t){Object.defineProperty(t,"__esModule",{value:!0});var n=(i.prototype.gen=function(e){return null==e&&(e="a"),e+"_"+this._count++},i);function i(){this._count=0}t.IdGen=n}.apply(null,i))||(e.exports=r)},1702:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(2697),n(1673),n(1721),n(1701),n(1642),n(1642)],void 0===(r=function(e,t,a,n,s,i,l,x){return Object.defineProperty(r.prototype,"id",{get:function(){return this._id},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"data",{get:function(){return this._data},enumerable:!0,configurable:!0}),r.prototype.getIndices=function(e){return this.data.getIndices(e)},Object.defineProperty(r.prototype,"indexCount",{get:function(){return this.data.indexCount},enumerable:!0,configurable:!0}),r.prototype.getAttribute=function(e){return this.data.getAttribute(e)},Object.defineProperty(r.prototype,"componentCount",{get:function(){return n.componentCount(this.data.componentOffsets)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"componentOffsets",{get:function(){return this.data.componentOffsets},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"vertexCount",{get:function(){return this.data.indexCount},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"faceCount",{get:function(){return this.data.indexCount/3},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"boundingInfo",{get:function(){return null==this._boundingInfo&&(this._boundingInfo=this._calculateBoundingInfo()),this._boundingInfo},enumerable:!0,configurable:!0}),r.prototype.computeAttachmentOrigin=function(e){return"triangle"===this.data.primitiveType?this.computeAttachmentOriginTriangles(e):this.computeAttachmentOriginPoints(e)},r.prototype.computeAttachmentOriginTriangles=function(e){var t=this.getIndices(x.VertexAttrConstants.POSITION),n=this.getAttribute(x.VertexAttrConstants.POSITION);return s.computeAttachmentOriginTriangles(n,t,e)},r.prototype.computeAttachmentOriginPoints=function(e){var t=this.getIndices(x.VertexAttrConstants.POSITION),n=this.getAttribute(x.VertexAttrConstants.POSITION);return s.computeAttachmentOriginPoints(n,t,e)},r.prototype.invalidateBoundingInfo=function(){this._boundingInfo=null,this._componentAABBs=null},r.prototype.getComponentAABB=function(e,t){null==this._componentAABBs&&(this._componentAABBs=this._computeComponentAABBs());for(var n=0;n<6;n++)t[n]=this._componentAABBs[6*e+n];return t},r.prototype._computeComponentAABBs=function(){for(var e=this.componentCount,t=new Float32Array(6*e),n=0;n<e;n++)this._calculateAABB(n,t,6*n);return t},r.prototype._calculateAABB=function(e,t,n){for(var i=this.data.getIndices(x.VertexAttrConstants.POSITION),r=this.data.getAttribute(x.VertexAttrConstants.POSITION),o=this.data.componentOffsets,a=o.length?o[e]:0,s=o.length?o[e+1]:i.length,l=1/0,c=1/0,u=1/0,d=-1/0,p=-1/0,f=-1/0,h=r.offsetIdx,v=r.strideIdx,m=a;m<s;m++){var g=h+v*i[m],y=r.data[g],b=r.data[g+1],_=r.data[g+2];l=Math.min(l,y),c=Math.min(c,b),u=Math.min(u,_),d=Math.max(d,y),p=Math.max(p,b),f=Math.max(f,_)}t[n]=l,t[n+1]=c,t[n+2]=u,t[n+3]=d,t[n+4]=p,t[n+5]=f},r.prototype._calculateBoundingInfo=function(){var e=this.data.getIndices(x.VertexAttrConstants.POSITION),t=this.data.getAttribute(x.VertexAttrConstants.POSITION),n="triangle"===this.data.primitiveType?3:1;if(0===e.length){e=new Uint32Array(n);for(var i=0;i<n;++i)e[i]=i}var r=e.length;l.assert(r%n==0,"Indexing error: "+r.toFixed(0)+" not divisible by "+n.toFixed(0));var o=s.generateDefaultIndexArray(r/n);return new a(o,n,e,t)},r.__idGen=new i.IdGen,r;function r(e,t,n){this.singleUse=!1,this._boundingInfo=null,this._componentAABBs=null,this._id=r.__idGen.gen(t),this._data=e,this._boundingInfo=n}}.apply(null,i))||(e.exports=r)},1703:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(118),n(1684),n(150),n(1650),n(548),n(2698),n(1642)],void 0===(r=function(e,t,q,W,Z,X,p,Y,K){var n,i,r,o,a,s,l,c,u,d,P=p.Vec3Compact;function f(e,t,n,i,r){return!(Math.abs(q.vec3.dot(t,e))>r||(q.vec3.cross(n,e,t),q.vec3.normalize(n,n),q.vec3.cross(i,n,e),q.vec3.normalize(i,i),0))}function J(e,t,n,i,r,o,a){return f(e,t,r,o,a)||f(e,n,r,o,a)||f(e,i,r,o,a)}!function(e){for(var o=[[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5]],a=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],s=[0,0,1,0,1,1,0,1],l=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],c=new Array(36),t=0;t<6;t++)for(var n=0;n<6;n++)c[6*t+n]=t;var u=new Array(36);for(t=0;t<6;t++)u[6*t+0]=0,u[6*t+1]=1,u[6*t+2]=2,u[6*t+3]=2,u[6*t+4]=3,u[6*t+5]=0;e.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);for(var t=new Float32Array(24),n=0;n<8;n++)t[3*n]=o[n][0]*e[0],t[3*n+1]=o[n][1]*e[1],t[3*n+2]=o[n][2]*e[2];var i={};i[K.VertexAttrConstants.POSITION]=new Uint32Array(l),i[K.VertexAttrConstants.NORMAL]=new Uint32Array(c),i[K.VertexAttrConstants.UV0]=new Uint32Array(u);var r={};return r[K.VertexAttrConstants.POSITION]={size:3,data:t},r[K.VertexAttrConstants.NORMAL]={size:3,data:new Float32Array(a)},r[K.VertexAttrConstants.UV0]={size:2,data:new Float32Array(s)},new Y.GeometryData(r,i)}}(n=n||{}),r=i=i||{},o=[[-.5,0,-.5],[.5,0,-.5],[.5,0,.5],[-.5,0,.5],[0,-.5,0],[0,.5,0]],a=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],s=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],l=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7],r.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);for(var t=new Float32Array(18),n=0;n<6;n++)t[3*n]=o[n][0]*e[0],t[3*n+1]=o[n][1]*e[1],t[3*n+2]=o[n][2]*e[2];var i={};i[K.VertexAttrConstants.POSITION]=new Uint32Array(s),i[K.VertexAttrConstants.NORMAL]=new Uint32Array(l);var r={};return r[K.VertexAttrConstants.POSITION]={size:3,data:t},r[K.VertexAttrConstants.NORMAL]={size:3,data:new Float32Array(a)},new Y.GeometryData(r,i)},function(e){var t=W.vec3f32.fromValues(-.5,0,-.5),n=W.vec3f32.fromValues(.5,0,-.5),i=W.vec3f32.fromValues(0,0,.5),r=W.vec3f32.fromValues(0,.5,0),o=W.vec3f32.create(),a=W.vec3f32.create(),s=W.vec3f32.create(),l=W.vec3f32.create(),c=W.vec3f32.create();q.vec3.subtract(o,t,r),q.vec3.subtract(a,t,n),q.vec3.cross(s,o,a),q.vec3.normalize(s,s),q.vec3.subtract(o,n,r),q.vec3.subtract(a,n,i),q.vec3.cross(l,o,a),q.vec3.normalize(l,l),q.vec3.subtract(o,i,r),q.vec3.subtract(a,i,t),q.vec3.cross(c,o,a),q.vec3.normalize(c,c);var u=[t,n,i,r],d=[0,-1,0,s[0],s[1],s[2],l[0],l[1],l[2],c[0],c[1],c[2]],p=[0,1,2,3,1,0,3,2,1,3,0,2],f=[0,0,0,1,1,1,2,2,2,3,3,3];e.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);for(var t=new Float32Array(12),n=0;n<4;n++)t[3*n]=u[n][0]*e[0],t[3*n+1]=u[n][1]*e[1],t[3*n+2]=u[n][2]*e[2];var i={};i[K.VertexAttrConstants.POSITION]=new Uint32Array(p),i[K.VertexAttrConstants.NORMAL]=new Uint32Array(f);var r={};return r[K.VertexAttrConstants.POSITION]={size:3,data:t},r[K.VertexAttrConstants.NORMAL]={size:3,data:new Float32Array(d)},new Y.GeometryData(r,i)}}(c=c||{}),(d=u=u||{}).createBoxGeometry=n.createGeometry,d.createDiamondGeometry=i.createGeometry,d.createTetrahedronGeometry=c.createGeometry,d.createSphereGeometry=function(e,t,n,i,r,o,a){e=e||50,i=void 0!==i?i:-Math.PI,r=void 0!==r?r:2*Math.PI,o=void 0!==o?o:.5*-Math.PI,a=void 0!==a?a:Math.PI;for(var s=Math.max(3,Math.floor(t)||8),l=Math.max(2,Math.floor(n)||6),c=(s+1)*(l+1),u=new Float32Array(3*c),d=new Float32Array(3*c),p=new Float32Array(2*c),f=[],h=0,v=0;v<=l;v++){for(var m=[],g=v/l,y=o+g*a,b=Math.cos(y),_=0;_<=s;_++){var x=_/s,S=i+x*r,P=Math.cos(S)*b,w=Math.sin(y),A=-Math.sin(S)*b;u[3*h]=P*e,u[3*h+1]=w*e,u[3*h+2]=A*e,d[3*h]=P,d[3*h+1]=w,d[3*h+2]=A,p[2*h]=x,p[2*h+1]=g,m.push(h),++h}f.push(m)}var C=new Uint32Array(2*s*(l-1)*3);for(v=h=0;v<l;v++)for(_=0;_<s;_++){var O=f[v][_],M=f[v][_+1],D=f[v+1][_+1],T=f[v+1][_];0===v?(C[h++]=O,C[h++]=D,C[h++]=T):v===l-1?(C[h++]=O,C[h++]=M,C[h++]=D):(C[h++]=O,C[h++]=M,C[h++]=D,C[h++]=D,C[h++]=T,C[h++]=O)}K.assert(h===C.length);var R={};R[K.VertexAttrConstants.POSITION]=C,R[K.VertexAttrConstants.NORMAL]=C,R[K.VertexAttrConstants.UV0]=C;var I={};return I[K.VertexAttrConstants.POSITION]={size:3,data:u},I[K.VertexAttrConstants.NORMAL]={size:3,data:d},I[K.VertexAttrConstants.UV0]={size:2,data:p},new Y.GeometryData(I,R)},d.createPolySphereGeometry=function(o,e,t){function n(e,t){var n;t<e&&(e=(n=[t,e])[0],t=n[1]);var i=e.toString()+"."+t.toString();if(c[i])return c[i];var r=a.length;return a.length+=3,P.add(a,3*e,a,3*t,a,r),P.scale(a,r,o/P.length(a,r)),r/=3,c[i]=r}var a,i,r=o;if(t)a=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],i=new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1]);else{var s=r*(1+Math.sqrt(5))/2;a=[-r,s,0,r,s,0,-r,-s,0,r,-s,0,0,-r,s,0,r,s,0,-r,-s,0,r,-s,s,0,-r,s,0,r,-s,0,-r,-s,0,r],i=new Uint32Array([0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1])}for(var l=0;l<a.length;l+=3)P.scale(a,l,o/P.length(a,l));var c={};for(l=0;l<e;l++){for(var u=i.length,d=new Uint32Array(4*u),p=0;p<u;p+=3){var f=i[p],h=i[p+1],v=i[p+2],m=n(f,h),g=n(h,v),y=n(v,f),b=4*p;d[b]=f,d[1+b]=m,d[2+b]=y,d[3+b]=h,d[4+b]=g,d[5+b]=m,d[6+b]=v,d[7+b]=y,d[8+b]=g,d[9+b]=m,d[10+b]=g,d[11+b]=y}i=d,c={}}var _=new Float32Array(a);for(l=0;l<_.length;l+=3)P.normalize(_,l);var x={};x[K.VertexAttrConstants.POSITION]=i,x[K.VertexAttrConstants.NORMAL]=i;var S={};return S[K.VertexAttrConstants.POSITION]={size:3,data:new Float32Array(a)},S[K.VertexAttrConstants.NORMAL]={size:3,data:_},new Y.GeometryData(S,x)},d.createPointGeometry=function(e,t,n,i,r,o,a,s){var l=t?new Float64Array([t[0],t[1],t[2]]):new Float32Array([0,0,0]),c=e?new Float32Array([e[0],e[1],e[2]]):new Float32Array([0,0,1]),u=o?new Float32Array(o):new Float32Array([0,0]),d=n?new Uint8Array([255*n[0],255*n[1],255*n[2],3<n.length?255*n[3]:255]):new Uint8Array([255,255,255,255]),p=null!=i&&2===i.length?new Float32Array(i):new Float32Array([1,1]),f={};if(f[K.VertexAttrConstants.POSITION]={size:3,data:l},f[K.VertexAttrConstants.NORMAL]={size:3,data:c},f[K.VertexAttrConstants.UV0]={size:u.length,data:u},f[K.VertexAttrConstants.COLOR]={size:4,data:d},f[K.VertexAttrConstants.SIZE]={size:2,data:p},null!=r){var h=new Float32Array([r[0],r[1],r[2],r[3]]);f[K.VertexAttrConstants.AUXPOS1]={size:4,data:h}}if(null!=a){var v=new Float32Array([a[0],a[1],a[2],a[3]]);f[K.VertexAttrConstants.AUXPOS2]={size:4,data:v}}return null!=s?(Y.GeometryData.call(s,f,Y.GeometryData.DefaultIndices,Y.GeometryData.DefaultOffsets,"point"),s):new Y.GeometryData(f,Y.GeometryData.DefaultIndices,Y.GeometryData.DefaultOffsets,"point")},d.updatePointGeometry=function(e,t,n,i,r,o,a,s){var l,c=s.vertexAttributes;return null!=e&&((l=c[K.VertexAttrConstants.NORMAL].data)[0]=e[0],l[1]=e[1],l[2]=e[2]),null!=t&&((l=c[K.VertexAttrConstants.POSITION].data)[0]=t[0],l[1]=t[1],l[2]=t[2]),null!=n&&((l=c[K.VertexAttrConstants.COLOR].data)[0]=n[0],l[1]=n[1],l[2]=n[2],l[3]=n[3]),null!=i&&((l=c[K.VertexAttrConstants.SIZE].data)[0]=i[0],l[1]=i[1]),null!=r&&((l=c[K.VertexAttrConstants.AUXPOS1].data)[0]=r[0],l[1]=r[1],l[2]=r[2],l[3]=r[3]),null!=o&&((l=c[K.VertexAttrConstants.UV0].data)[0]=o[0],l[1]=o[1]),null!=a&&((l=c[K.VertexAttrConstants.AUXPOS2].data)[0]=a[0],l[1]=a[1],l[2]=a[2],l[3]=a[3]),s},d.createPointArrayGeometry=function(e,t){for(var n=new Float32Array(3*e.length),i=new Float32Array(t?3*e.length:3),r=new Uint32Array(e.length),o=new Uint32Array(e.length),a=0;a<e.length;a++)n[3*a]=e[a][0],n[3*a+1]=e[a][1],n[3*a+2]=e[a][2],t&&(i[3*a]=t[a][0],i[3*a+1]=t[a][1],i[3*a+2]=t[a][2]),o[r[a]=a]=0;t||(i[0]=0,i[1]=1,i[2]=0);var s=new Float32Array(2);s[0]=0,s[1]=0;var l={};l[K.VertexAttrConstants.POSITION]=r,l[K.VertexAttrConstants.NORMAL]=t?r:o,l[K.VertexAttrConstants.UV0]=o;var c={};return c[K.VertexAttrConstants.POSITION]={size:3,data:n},c[K.VertexAttrConstants.NORMAL]={size:3,data:i},c[K.VertexAttrConstants.UV0]={size:2,data:s},new Y.GeometryData(c,l,Y.GeometryData.DefaultOffsets,"point")},d.createTriangleGeometry=function(){var e=new Float32Array([0,0,0,0,0,100,100,0,0]),t=new Uint32Array([0,1,2]),n=new Float32Array([0,1,0]),i=new Uint32Array([0,0,0]),r=new Float32Array([0,0]),o=new Uint32Array([0,0,0]),a={};a[K.VertexAttrConstants.POSITION]=t,a[K.VertexAttrConstants.NORMAL]=i,a[K.VertexAttrConstants.UV0]=o;var s={};return s[K.VertexAttrConstants.POSITION]={size:3,data:e},s[K.VertexAttrConstants.NORMAL]={size:3,data:n},s[K.VertexAttrConstants.UV0]={size:2,data:r},new Y.GeometryData(s,a)},d.createSquareGeometry=function(e){var t=new Float32Array(12);if(e)for(var n=0;n<4;n++)for(var i=0;i<3;i++)t[3*n+i]=e[n][i];else t[0]=-1,t[1]=-1,t[2]=0,t[3]=1,t[4]=-1,t[5]=0,t[6]=1,t[7]=1,t[8]=0,t[9]=-1,t[10]=1,t[11]=0;var r=new Uint32Array([0,1,2,2,3,0]),o=new Float32Array([0,0,1]),a=new Uint32Array([0,0,0,0,0,0]),s=new Float32Array([0,0,1,0,1,1,0,1]),l=new Uint8Array([255,255,255,255]),c={};c[K.VertexAttrConstants.POSITION]=r,c[K.VertexAttrConstants.NORMAL]=a,c[K.VertexAttrConstants.UV0]=r,c[K.VertexAttrConstants.COLOR]=a;var u={};return u[K.VertexAttrConstants.POSITION]={size:3,data:t},u[K.VertexAttrConstants.NORMAL]={size:3,data:o},u[K.VertexAttrConstants.UV0]={size:2,data:s},u[K.VertexAttrConstants.COLOR]={size:4,data:l},new Y.GeometryData(u,c)},d.createConeGeometry=function(e,t,n,i,r,o){void 0===r&&(r=!0),void 0===o&&(o=!0);var a=0,s=t,l=e,c=W.vec3f32.fromValues(0,a,0),u=W.vec3f32.fromValues(0,a+l,0),d=W.vec3f32.fromValues(0,-1,0),p=W.vec3f32.fromValues(0,1,0);i&&(a=l,u=W.vec3f32.fromValues(0,0,0),c=W.vec3f32.fromValues(0,a,0),d=W.vec3f32.fromValues(0,1,0),p=W.vec3f32.fromValues(0,-1,0));var f=[u,c],h=[d,p],v=n+2,m=Math.sqrt(l*l+s*s);if(i)for(var g=n-1;0<=g;g--){var y=g*(2*Math.PI/n),b=W.vec3f32.fromValues(Math.cos(y)*s,a,Math.sin(y)*s);f.push(b);var _=W.vec3f32.fromValues(l*Math.cos(y)/m,-s/m,l*Math.sin(y)/m);h.push(_)}else for(g=0;g<n;g++){y=g*(2*Math.PI/n),b=W.vec3f32.fromValues(Math.cos(y)*s,a,Math.sin(y)*s);f.push(b);_=W.vec3f32.fromValues(l*Math.cos(y)/m,s/m,l*Math.sin(y)/m);h.push(_)}var x=new Uint32Array(2*(n+2)*3),S=new Uint32Array(2*(n+2)*3),P=0,w=0;if(r){for(g=3;g<f.length;g++)x[P++]=1,x[P++]=g-1,x[P++]=g,S[w++]=0,S[w++]=0,S[w++]=0;x[P++]=f.length-1,x[P++]=2,x[P++]=1,S[w++]=0,S[w++]=0,S[w++]=0}if(o){for(g=3;g<f.length;g++)x[P++]=g,x[P++]=g-1,x[P++]=0,S[w++]=g,S[w++]=g-1,S[w++]=1;x[P++]=0,x[P++]=2,x[P++]=f.length-1,S[w++]=1,S[w++]=2,S[w++]=h.length-1}var A=new Float32Array(3*v);for(g=0;g<v;g++)A[3*g]=f[g][0],A[3*g+1]=f[g][1],A[3*g+2]=f[g][2];var C=new Float32Array(3*v);for(g=0;g<v;g++)C[3*g]=h[g][0],C[3*g+1]=h[g][1],C[3*g+2]=h[g][2];var O={};O[K.VertexAttrConstants.POSITION]=x,O[K.VertexAttrConstants.NORMAL]=S;var M={};return M[K.VertexAttrConstants.POSITION]={size:3,data:A},M[K.VertexAttrConstants.NORMAL]={size:3,data:C},new Y.GeometryData(M,O)},d.createCylinderGeometry=function(e,t,n,i,r,o){var a=i?W.vec3f32.clone(i):W.vec3f32.fromValues(1,0,0),s=r?W.vec3f32.clone(r):W.vec3f32.fromValues(0,0,0),l=void 0===o||o,c=W.vec3f32.create();q.vec3.normalize(c,a);var u=W.vec3f32.create();q.vec3.scale(u,c,Math.abs(e));var d=W.vec3f32.create();q.vec3.scale(d,u,-.5),q.vec3.add(d,d,s);var p=W.vec3f32.fromValues(0,1,0);Math.abs(1-q.vec3.dot(c,p))<.2&&q.vec3.set(p,0,0,1);var f=W.vec3f32.create();q.vec3.cross(f,c,p),q.vec3.normalize(f,f),q.vec3.cross(p,f,c);var h=2*n+(l?2:0),v=n+(l?2:0),m=new Float32Array(3*h),g=new Float32Array(3*v),y=new Float32Array(2*h),b=new Uint32Array(3*n*(l?4:2)),_=new Uint32Array(3*n*(l?4:2));function x(e,t,n){b[e]=t,_[e]=n}l&&(m[3*(h-2)+0]=d[0],m[3*(h-2)+1]=d[1],m[3*(h-2)+2]=d[2],y[2*(h-2)]=0,m[3*(h-1)+(y[2*(h-2)+1]=0)]=m[3*(h-2)+0]+u[0],m[3*(h-1)+1]=m[3*(h-2)+1]+u[1],m[3*(h-1)+2]=m[3*(h-2)+2]+u[2],y[2*(h-1)]=1,y[2*(h-1)+1]=1,g[3*(v-2)+0]=-c[0],g[3*(v-2)+1]=-c[1],g[3*(v-2)+2]=-c[2],g[3*(v-1)+0]=c[0],g[3*(v-1)+1]=c[1],g[3*(v-1)+2]=c[2]);for(var S=0,P=W.vec3f32.create(),w=W.vec3f32.create(),A=0;A<n;A++){var C=A*(2*Math.PI/n);q.vec3.scale(P,p,Math.sin(C)),q.vec3.scale(w,f,Math.cos(C)),q.vec3.add(P,P,w),g[3*A+0]=P[0],g[3*A+1]=P[1],g[3*A+2]=P[2],q.vec3.scale(P,P,t),q.vec3.add(P,P,d),m[3*A+0]=P[0],m[3*A+1]=P[1],m[3*A+2]=P[2],y[2*A+0]=A/n,m[3*(A+n)+(y[2*A+1]=0)]=m[3*A+0]+u[0],m[3*(A+n)+1]=m[3*A+1]+u[1],m[3*(A+n)+2]=m[3*A+2]+u[2],y[2*(A+n)+0]=A/n;var O=(A+(y[2*A+1]=1))%n;x(S++,A,A),x(S++,A+n,A),x(S++,O,O),x(S++,O,O),x(S++,A+n,A),x(S++,O+n,O)}if(l){for(A=0;A<n;A++){O=(A+1)%n;x(S++,h-2,v-2),x(S++,A,v-2),x(S++,O,v-2)}for(A=0;A<n;A++){O=(A+1)%n;x(S++,A+n,v-1),x(S++,h-1,v-1),x(S++,O+n,v-1)}}var M={};M[K.VertexAttrConstants.POSITION]=b,M[K.VertexAttrConstants.NORMAL]=_,M[K.VertexAttrConstants.UV0]=b;var D={};return D[K.VertexAttrConstants.POSITION]={size:3,data:m},D[K.VertexAttrConstants.NORMAL]={size:3,data:g},D[K.VertexAttrConstants.UV0]={size:2,data:y},new Y.GeometryData(D,M)},d.createTubeGeometry=function(e,t,n,i,r){n=n||10,i=null==i||i,K.assert(1<e.length);for(var o=[],a=[],s=0;s<n;s++){o.push([0,-s-1,-(s+1)%n-1]);var l=s/n*2*Math.PI;a.push([Math.cos(l)*t,Math.sin(l)*t])}return d.createPathExtrusionGeometry(a,e,[[0,0,0]],o,i,r)},d.createPathExtrusionGeometry=function(e,t,n,i,r,o){void 0===o&&(o=W.vec3f32.fromValues(0,0,0));var a=e.length,s=new Float32Array(t.length*a*3+(6*n.length||0)),l=new Float32Array(t.length*a+(2*n.length||0)),c=new Float32Array(t.length*a*3+(n?6:0)),u=(t.length-1)*a*6+3*i.length*2,d=new Uint32Array(u),p=new Uint32Array(u),f=0,h=0,v=0,m=0,g=0,y=W.vec3f32.create(),b=W.vec3f32.create(),_=W.vec3f32.create(),x=W.vec3f32.create(),S=W.vec3f32.create(),P=W.vec3f32.create(),w=W.vec3f32.create(),A=Z.vec3f64.create(),C=W.vec3f32.create(),O=W.vec3f32.create(),M=W.vec3f32.create(),D=W.vec3f32.create(),T=W.vec3f32.create(),R=X.plane.create();q.vec3.set(C,0,1,0),q.vec3.subtract(b,t[1],t[0]),q.vec3.normalize(b,b),r?(q.vec3.add(A,t[0],o),q.vec3.normalize(_,A)):q.vec3.set(_,0,0,1),J(b,_,C,C,S,_,Q),q.vec3.copy(x,_),q.vec3.copy(D,S);for(var I=0;I<n.length;I++)q.vec3.scale(P,S,n[I][0]),q.vec3.scale(A,_,n[I][2]),q.vec3.add(P,P,A),q.vec3.add(P,P,t[0]),s[f++]=P[0],s[f++]=P[1],s[f++]=P[2],l[v++]=0;for(c[h++]=-b[0],c[h++]=-b[1],c[h++]=-b[2],I=0;I<i.length;I++)d[m++]=0<i[I][0]?i[I][0]:-i[I][0]-1+n.length,d[m++]=0<i[I][1]?i[I][1]:-i[I][1]-1+n.length,d[m++]=0<i[I][2]?i[I][2]:-i[I][2]-1+n.length,p[g++]=0,p[g++]=0,p[g++]=0;for(var z=n.length,L=n.length-1,E=0;E<t.length;E++){var V=!1;0<E&&(q.vec3.copy(y,b),E<t.length-1?(q.vec3.subtract(b,t[E+1],t[E]),q.vec3.normalize(b,b)):V=!0,q.vec3.add(O,y,b),q.vec3.normalize(O,O),q.vec3.add(M,t[E-1],x),X.plane.fromPositionAndNormal(t[E],O,R),X.plane.intersectRay(R,X.ray.wrap(M,y),A)?(q.vec3.subtract(A,A,t[E]),q.vec3.normalize(_,A),q.vec3.cross(S,O,_),q.vec3.normalize(S,S)):J(O,x,D,C,S,_,Q),q.vec3.copy(x,_),q.vec3.copy(D,S)),r&&(q.vec3.add(A,t[E],o),q.vec3.normalize(T,A));for(var N=0;N<a;N++)if(q.vec3.scale(P,S,e[N][0]),q.vec3.scale(A,_,e[N][1]),q.vec3.add(P,P,A),q.vec3.normalize(w,P),c[h++]=w[0],c[h++]=w[1],c[h++]=w[2],l[v++]=r?q.vec3.dot(P,T):P[2],q.vec3.add(P,P,t[E]),s[f++]=P[0],s[f++]=P[1],s[f++]=P[2],!V){var j=(N+1)%a;d[m++]=z+N,d[m++]=z+a+N,d[m++]=z+j,d[m++]=z+j,d[m++]=z+a+N,d[m++]=z+a+j;for(var F=0;F<6;F++)p[g++]=d[m-6+F]-L}z+=a}var G=t[t.length-1];for(I=0;I<n.length;I++)q.vec3.scale(P,S,n[I][0]),q.vec3.scale(A,_,n[I][1]),q.vec3.add(P,P,A),q.vec3.add(P,P,G),s[f++]=P[0],s[f++]=P[1],s[f++]=P[2],l[v++]=0;var H=h/3;c[h++]=b[0],c[h++]=b[1],c[h++]=b[2];var B=z-a;for(I=0;I<i.length;I++)d[m++]=0<=i[I][0]?z+i[I][0]:-i[I][0]-1+B,d[m++]=0<=i[I][2]?z+i[I][2]:-i[I][2]-1+B,d[m++]=0<=i[I][1]?z+i[I][1]:-i[I][1]-1+B,p[g++]=H,p[g++]=H,p[g++]=H;var U={};U[K.VertexAttrConstants.POSITION]=d,U[K.VertexAttrConstants.NORMAL]=p;var k={};return k[K.VertexAttrConstants.POSITION]={size:3,data:s},k.zOffset={size:1,data:l},k[K.VertexAttrConstants.NORMAL]={size:3,data:c},new Y.GeometryData(k,U)},d.createPolylineGeometry=function(e,t){K.assert(1<e.length,"createPolylineGeometry(): polyline needs at least 2 points"),K.assert(3===e[0].length,"createPolylineGeometry(): malformed vertex"),K.assert(void 0===t||t.length===e.length,"createPolylineGeometry: need same number of points and normals"),K.assert(void 0===t||3===t[0].length,"createPolylineGeometry(): malformed normal");for(var n=new Float32Array(3*e.length),i=new Uint32Array(2*(e.length-1)),r=0,o=0,a=0;a<e.length;a++){for(var s=0;s<3;s++)n[r++]=e[a][s];0<a&&(i[o++]=a-1,i[o++]=a)}var l={},c={};if(l[K.VertexAttrConstants.POSITION]=i,c[K.VertexAttrConstants.POSITION]={size:3,data:n},t){var u=new Float32Array(3*t.length),d=0;for(a=0;a<e.length;a++)for(s=0;s<3;s++)u[d++]=t[a][s];l[K.VertexAttrConstants.NORMAL]=i,c[K.VertexAttrConstants.NORMAL]={size:3,data:u}}return new Y.GeometryData(c,l,Y.GeometryData.DefaultOffsets,"line")},d.createExtrudedTriangle=function(e,t,n,i){for(var r,o,a=new Float32Array(18),s=[[-t,0,i/2],[n,0,i/2],[0,e,i/2],[-t,0,-i/2],[n,0,-i/2],[0,e,-i/2]],l=0;l<6;l++)a[3*l]=s[l][0],a[3*l+1]=s[l][1],a[3*l+2]=s[l][2];var c=((r={})[K.VertexAttrConstants.POSITION]=new Uint32Array([0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5]),r),u=((o={})[K.VertexAttrConstants.POSITION]={size:3,data:a},o);return new Y.GeometryData(u,c)},d.transformInPlace=function(e,t){for(var n=e.vertexAttributes[K.VertexAttrConstants.POSITION].data,i=0;i<n.length;i+=3){var r=n[i],o=n[i+1],a=n[i+2];q.vec3.set(h,r,o,a),q.vec3.transformMat4(h,h,t),n[i]=h[0],n[i+1]=h[1],n[i+2]=h[2]}},d.addVertexColors=function(e,t){var n=t||[1,1,1,1],i=new Uint8Array(4);i[0]=255*n[0],i[1]=255*n[1],i[2]=255*n[2],i[3]=255*(3<n.length?n[3]:1);var r={},o=e.getVertexAttr();for(var a in o)r[a]=o[a];r[K.VertexAttrConstants.COLOR]={size:4,data:i};var s={};for(var a in e.indices)s[a]=e.indices[a];var l=s[K.VertexAttrConstants.POSITION].length;return s[K.VertexAttrConstants.COLOR]=new Uint32Array(l),new Y.GeometryData(r,s,e.componentOffsets,e.primitiveType)},d.addNormals=function(e){for(var t=e.getVertexAttr(),n=e.indices,i=p.Vec3Compact.subtract,r=n.position.length/3,o=new Float32Array(3*r),a=t.position.data,s=0,l=n.position,c=new Uint32Array(l.length),u=0;u<l.length;u+=3){i(a,3*l[u],a,3*l[u+2],v,0),i(a,3*l[u],a,3*l[u+1],h,0),q.vec3.cross(h,h,v),q.vec3.normalize(h,h);var d=s/3;o[s++]=h[0],o[s++]=h[1],o[s++]=h[2],c[u]=d,c[u+1]=d,c[u+2]=d}t[K.VertexAttrConstants.NORMAL]={size:3,data:o,offsetIdx:0,strideIdx:3},n[K.VertexAttrConstants.NORMAL]=c},d.cgToGIS=function(e,t){void 0===t&&(t=e);var n=e.getVertexAttr(),i=n.position.data,r=n.normal.data,o=t.getVertexAttr(),a=o.position.data,s=o.normal.data;if(r)for(var l=0;l<r.length;l+=3){var c=r[l+1];s[l+1]=-r[l+2],s[l+2]=c}if(i)for(l=0;l<i.length;l+=3){c=i[l+1];a[l+1]=-i[l+2],a[l+2]=c}return t},d.makeOrthoBasisDirUp=f,d.makeOrthoBasisDirUpFallback=J;var Q=.99619469809,h=W.vec3f32.create(),v=W.vec3f32.create();return u}.apply(null,i))||(e.exports=r)},1704:function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.Default3D={position:0,normal:1,normalCompressed:1,uv0:2,color:3,instanceColor:3,size:4,tangent:4,auxpos1:5,symbolColor:5,componentIndex:5,auxpos2:6,featureAttribute:6,instanceFeatureAttribute:6,region:7,model:8,modelNormal:12,modelOriginHi:11,modelOriginLo:15}}.apply(null,i))||(e.exports=r)},1740:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1),n(0),n(2),n(2702)],void 0===(r=function(e,t,n,i,r,o){Object.defineProperty(t,"__esModule",{value:!0});var a,s=(a=r.declared(o.AutoDisposable),n(l,a),l.prototype.isVisible=function(){return this.material.isVisible()},l.prototype.isVisibleInPass=function(e){return this.material.isVisibleInPass(e)},l.prototype.getPrograms=function(){return[this.getProgram()]},l.prototype.getDrawMode=function(){return 4},l.prototype.ensureResources=function(e){return 0},l.prototype.ensureAttributeLocations=function(e){this.getProgram().assertCompatibleVertexAttributeLocations(e)},i([r.subclass("esri.views.3d.webgl-engine.lib.GLMaterial")],l));function l(e){var t=a.call(this)||this;return t.material=e.material,t.programRep=e.programRep,t.techniqueRep=e.techniqueRep,t}t.GLMaterial=s}.apply(null,i))||(e.exports=r)},1741:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(4)],void 0===(r=function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0});var n=(r.prototype.get=function(){return this._module},r.prototype.reload=function(){var n=this,e=this._moduleRequire.toUrl(this._relativePath);return e=e.slice(e.indexOf("esri/")),this._recursivelyInvalidateModuleCache(e),i.create(function(t){n._moduleRequire([n._relativePath],function(e){n._module=e,t()})})},r.prototype._recursivelyInvalidateModuleCache=function(e){if(-1!==e.search("shader")||-1!==e.search("shading")){var t=this._moduleRequire.modules,n=t[e];if(n){var i=n.deps;delete t[e];for(var r=0,o=i;r<o.length;r++){var a=o[r];"esri"===a.pid&&this._recursivelyInvalidateModuleCache(a.mid)}}}},r);function r(e,t,n){this._relativePath=t,this._moduleRequire=n,this._module=e}t.ReloadableShaderModule=n}.apply(null,i))||(e.exports=r)},1742:function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=function(e,t){Object.defineProperty(t,"__esModule",{value:!0});var n=(i.prototype.dispose=function(){this._program&&(this._commonUniformStore.unsubscribeProgram(this._program),this._program.dispose(),this._program=null)},i.prototype.reload=function(e){this._program&&(this._commonUniformStore.unsubscribeProgram(this._program),this._program.dispose()),this._program=this.initializeProgram(e),this._commonUniformStore.subscribeProgram(this._program)},Object.defineProperty(i.prototype,"program",{get:function(){return this._program},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"pipeline",{get:function(){return this._pipeline},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"key",{get:function(){return this._config.key},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"configuration",{get:function(){return this._config},enumerable:!0,configurable:!0}),i.prototype.bindPass=function(e,t,n){},i.prototype.bindMaterial=function(e,t){},i.prototype.bindDraw=function(e){},i);function i(e,t){this._commonUniformStore=e.commonUniformStore,this._config=function(e){var t=e.__proto__.__configurationParameters,n={};n.key=e.key;for(var i=0,r=t;i<r.length;i++){var o=r[i];n[o]=e[o]}return n}(t),this._program=this.initializeProgram(e),this._commonUniformStore.subscribeProgram(this._program),this._pipeline=this.initializePipeline(e)}t.ShaderTechnique=n}.apply(null,i))||(e.exports=r)},1743:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(33)],void 0===(r=function(e,t,c){Object.defineProperty(t,"__esModule",{value:!0});function n(){this.key=0}t.ShaderTechniqueConfiguration=n,t.parameter=function(l){return void 0===l&&(l={}),function(e,t){var n=e;n.__configurationParameters=n.__configurationParameters||[],n.__configurationParameters.push(t);var i="_"+t;void 0===n.__configurationParameters__offset&&(n.__configurationParameters__offset=0);var r=n.__configurationParameters__offset,o=l.count||2,a=Math.ceil(c.log2(o)),s=(1<<a)-1<<r;if(n.__configurationParameters__offset+=a,32<=n.__configurationParameters__offset)throw new Error("ShaderTechniqueConfiguration is too complex, requiring more than 32 bits to encode.\n      Either the configuration must be simplified, or this restriction must be relaxed.(Currently used: "+n.__configurationParameters__offset+")");Object.defineProperty(n,t,{get:function(){return this[i]},set:function(e){this.key=this.key&~s|e<<r&s,this[i]=e}})}}}.apply(null,i))||(e.exports=r)},1744:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(63),n(3)],void 0===(r=function(e,t,n,i){Object.defineProperty(t,"__esModule",{value:!0});var r=i.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder"),o=(a.prototype.include=function(e,t){this._includedModules.has(e)?this._includedModules.get(e)!==t&&r.error("Trying to include shader module multiple times with different sets of options."):(this._includedModules.set(e,t),"shaderModule"in e?e.shaderModule(this,t):e(this,t))},a.prototype.generateSource=function(e){var t=this.extensions.generateSource(e),n=this.attributes.generateSource(e),i=this.varyings.generateSource(),r="vertex"===e?this.vertex:this.fragment,o=r.uniforms.generateSource(),a=r.code.generateSource(),s="vertex"===e?v:h,l=this.defines.generateSource().concat(r.defines.generateSource());return"\n"+t.join("\n")+"\n\n"+l.join("\n")+"\n\n"+s+"\n\n"+o.join("\n")+"\n\n"+n.join("\n")+"\n\n"+i.join("\n")+"\n\n"+a.join("\n")},a);function a(){this.vertex=new c,this.fragment=new c,this.attributes=new u,this.varyings=new d,this.extensions=new p,this.defines=new f,this._includedModules=new Map}t.ShaderBuilder=o;var s=(x.prototype.add=function(e,t,n){var i=e+"_"+t+"_"+n;return this._set.has(i)||(this._entries.push([e,t,n]),this._set.add(i)),this},x.prototype.generateSource=function(){return this._entries.map(function(e){return"uniform "+e[1]+" "+e[0]+((t=e[2])?"["+t+"]":"")+";";var t})},x),l=(_.prototype.add=function(e){this._entries.push(e)},_.prototype.generateSource=function(){return this._entries},_),c=function(){this.uniforms=new s,this.code=new l,this.defines=new f},u=(b.prototype.add=function(e,t){this._entries.push([e,t])},b.prototype.generateSource=function(e){return"fragment"===e?[]:this._entries.map(function(e){return"attribute "+e[1]+" "+e[0]+";"})},b),d=(y.prototype.add=function(e,t){this._entries.push([e,t])},y.prototype.generateSource=function(){return this._entries.map(function(e){return"varying "+e[1]+" "+e[0]+";"})},y),p=(g.prototype.add=function(e){this._entries.add(e)},g.prototype.generateSource=function(e){var t="vertex"===e?g.WHITELIST_VERTEX:g.WHITELIST_FRAGMENT;return n.valuesOfSet(this._entries).filter(function(e){return 0<=t.indexOf(e)}).map(function(e){return"#extension "+e+" : enable"})},g.WHITELIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"],g.WHITELIST_VERTEX=[],g),f=(m.prototype.addInt=function(e,t){var n=t%1==0?t.toFixed(0):t.toString();this._entries.set(e,n)},m.prototype.addFloat=function(e,t){var n=t%1==0?t.toFixed(1):t.toString();this._entries.set(e,n)},m.prototype.generateSource=function(){return n.pairsOfMap(this._entries).map(function(e){return"#define "+e[0]+" "+e[1]})},m),h="#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump sampler2D;\n#endif",v="precision highp float;\nprecision highp sampler2D;";function m(){this._entries=new Map}function g(){this._entries=new Set}function y(){this._entries=new Array}function b(){this._entries=new Array}function _(){this._entries=new Array}function x(){this._entries=new Array,this._set=new Set}}.apply(null,i))||(e.exports=r)},1745:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(12),n(52)],void 0===(r=function(e,t,a,s){function l(n,i,r){var o=null;return n.events.on("drag",function(e){if("start"===e.action&&(o=i(n,e)),!a.isNone(o)){var t=o(e);a.isSome(t)&&r(t),"end"===e.action&&(o=null)}})}function r(e,t,n){for(var i=[],r=0,o=e;r<o.length;r++){var a=o[r];i.push(l(a,t,n))}return s.handlesGroup(i)}Object.defineProperty(t,"__esModule",{value:!0}),t.createManipulatorDragHandler=l,t.createManipulatorDragHandlerOneOf=function(e,n,t){var i=null;return r(e,function(e,t){return a.isSome(i)?null:i=n(e,t)},function(e){return"end"===e.action&&(i=null),t(e)})},t.createManipulatorDragHandlerMany=r}.apply(null,i))||(e.exports=r)},1778:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1701)],void 0===(r=function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var i=(r.prototype.update=function(e){return!1},Object.defineProperty(r.prototype,"parentStage",{get:function(){return this._parentStage},enumerable:!0,configurable:!0}),r.prototype.addParentStage=function(e){this._parentStage=e},r.prototype.removeParentStage=function(){this._parentStage=null},Object.defineProperty(r.prototype,"visible",{get:function(){return this._visible},set:function(e){e!==this._visible&&(this._visible=e,this.notifyDirty("matChanged"))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"renderOccluded",{get:function(){return this._renderOccluded},set:function(e){e!==this._renderOccluded&&(this._renderOccluded=e,this.notifyDirty("matChanged"))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"renderPriority",{get:function(){return this._renderPriority},set:function(e){e!==this._renderPriority&&(this._renderPriority=e,this.notifyDirty("matChanged"))},enumerable:!0,configurable:!0}),r.prototype.isVisibleInPass=function(e){return!0},r.prototype.isVisible=function(){return this._visible},r.prototype.notifyDirty=function(e){this.parentStage&&this.parentStage.notifyDirty(this,e)},r._idGen=new n.IdGen,r);function r(e){this.supportsEdges=!1,this._parentStage=null,this._visible=!0,this._renderOccluded=1,this._renderPriority=0,this.id=r._idGen.gen(e)}t.Material=i}.apply(null,i))||(e.exports=r)},1779:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(484),n(1633),n(1764),n(1704),n(2705),n(2706),n(1642),n(2707),n(1969),n(1970),n(328),n(507),n(329)],void 0===(r=function(e,t,m,d,i,r,o,a,w,n,g,y,s,l,c){function u(a,s,e,t){function n(e,t){var n=e.origin,i=a.get(n.id),r=l.get(n.id);null==r&&(r={optimalCount:null==i?0:i.optimalCount,sparseCount:null==i?0:i.buffer.size,toAdd:[],toRemove:[],origin:n.vec3},l.set(n.id,r));var o=s.elementCount(e.data)*c;t?(r.optimalCount+=o,r.sparseCount+=o,r.toAdd.push(e)):(r.optimalCount-=o,r.toRemove.push(e))}for(var l=new Map,c=s.vertexBufferLayout.stride/4,i=0,r=e;i<r.length;i++){n(r[i],!0)}for(var o=0,u=t;o<u.length;o++){n(u[o],!1)}return l}var p=(h.prototype.dispose=function(){y.releaseMaterials(this._material,this._materialRep)},Object.defineProperty(h.prototype,"isEmpty",{get:function(){return 0===this._dataByOrigin.size},enumerable:!0,configurable:!0}),Object.defineProperty(h.prototype,"hasHighlights",{get:function(){return 0<this._highlightCount},enumerable:!0,configurable:!0}),h.prototype.hasWater=function(){var t=!1;return this._glMaterials.forEach(function(e){t=t||e instanceof n.WaterGLMaterial}),t},h.prototype.renderPriority=function(){return this._material.renderPriority},h.prototype.modify=function(e){var t=this,n=f;n.clear(),this.updateGeometries(e.toUpdate,n),this.addAndRemoveGeometries(e.toAdd,e.toRemove,n),this.updateHighlightCount(),n.forEach(function(e){return t.updateDisplayedIndexRanges(e)})},h.prototype.addAndRemoveGeometries=function(e,t,y){var b=this,n=this._bufferWriter,_=n.vertexBufferLayout,x=_.stride/4,S=this._dataByOrigin,P=u(S,n,e,t);P.forEach(function(e,t){P.delete(t);var n=e.optimalCount,i=e.sparseCount,r=S.get(t);if(null==r&&(w.assert(0<n),r=b.createData(_,n,e.origin),S.set(t,r)),0===n)return r.vao.dispose(!0),r.vao=null,void S.delete(t);var o=n<e.sparseCount/2,a=o?n:i,s=A,l=r.buffer.size,c=r.buffer.array,u=r.buffer.resize(a,!1);o||u?b.removeAndRebuild(r,e.toRemove,x,c,s):0<e.toRemove.length?(b.removeByErasing(r,e.toRemove,x,s),0<e.toAdd.length&&(s.end=l)):(s.begin=l,s.end=l);var d=C;w.setMatrixTranslation3(d,-e.origin[0],-e.origin[1],-e.origin[2]),b.append(r,e.toAdd,x,d,s);var p=r.vao.vertexBuffers.geometry;if(p.byteSize!==r.buffer.array.buffer.byteLength)p.setData(r.buffer.array);else{var f=s.begin,h=s.end;if(f<h){var v=r.buffer.array,m=4*f,g=4*h;p.setSubData(v,m,m,g)}}(s.updatedDisplayedIndexRange||r.displayedIndexRanges)&&y.add(r)})},h.prototype.updateGeometries=function(e,t){for(var n=this._bufferWriter,i=n.vertexBufferLayout.stride/4,r=0,o=e;r<o.length;r++){var a=o[r],s=a.updateType,l=a.renderGeometry,c=this._dataByOrigin.get(l.origin.id),u=c&&c.instances.get(l.uniqueName);if(!u)return;if(1&s&&(u.displayedIndexRange=y.generateRenderGeometryVisibleIndexRanges(l),t.add(c)),17&s&&(u.highlightedIndexRanges=y.generateRenderGeometryHighlightRanges(l),c.highlightCount=null),6&s){var d=c.buffer.array,p=c.vao;y.calculateTransformRelToOrigin(l,b,_),n.write({transformation:b,invTranspTransformation:_},l.data,n.vertexBufferLayout.createView(d.buffer),u.from),w.assert(u.from+n.elementCount(l.data)===u.to,"material VBO layout has changed"),p.vertexBuffers.geometry.setSubData(d,u.from*i*4,u.from*i*4,u.to*i*4)}}},h.prototype.updateDisplayedIndexRanges=function(t){t.displayedIndexRanges=[];var n=!0;t.instances.forEach(function(e){e.displayedIndexRange?(t.displayedIndexRanges.push.apply(t.displayedIndexRanges,o.offsetIntervals(e.displayedIndexRange,e.from)),n=!1):t.displayedIndexRanges.push([e.from,e.to-1])}),t.displayedIndexRanges=n?null:o.mergeIntervals(t.displayedIndexRanges)},h.prototype.updateHighlightCount=function(){var n=this;this._highlightCount=0,this._dataByOrigin.forEach(function(e){if(null==e.highlightCount){var t=0;e.instances.forEach(function(e){e.highlightedIndexRanges&&++t}),e.highlightCount=t}n._highlightCount+=e.highlightCount})},h.prototype.updateLogic=function(e){return this._material.update(e)},h.prototype.render=function(e,t,n,i){var r=this,o=this._rctx,a=this._glMaterials.get(t.pass),s=4===t.pass,l=e;if(2===t.pass&&null===l&&(l=19),!a||1===a.ensureResources(o)||null!=l&&!a.beginSlot(l)||s&&0===this._highlightCount)return!1;a.bind(o,n);var c=a.getProgram();c.setUniformMatrix4fv("model",d.mat4f64.IDENTITY),c.hasUniform("modelNormal")&&c.setUniformMatrix4fv("modelNormal",d.mat4f64.IDENTITY);var u=!1;return this._dataByOrigin.forEach(function(e){s&&0===e.highlightCount||(n.origin=e.origin,a.bindView(n),u=s?r.renderHighlightPass(a,e,i)||u:r.renderDefaultPass(a,e,i)||u)}),a.release(),u},h.prototype.renderDefaultPass=function(e,t,n){var i=this._rctx,r=e.getDrawMode(),o=t.displayedIndexRanges;if(o&&0===o.length)return!1;if(e.ensureAttributeLocations(t.vao),i.bindVAO(t.vao),o)y.drawArraysFaceRange(i,o,0,r,n);else{var a=4*t.buffer.size/l.getStride(t.vao.layout.geometry);y.drawArrays(i,r,0,a,n)}return!0},h.prototype.renderHighlightPass=function(e,t,a){var s=this._rctx,l=e.getDrawMode(),n=t.vao;e.ensureAttributeLocations(n),s.bindVAO(n);var c=!1;return t.instances.forEach(function(e){var t=e.highlightedIndexRanges;if(t&&0!==t.length)for(var n=0;n<t.length;n++){var i=t[n],r=i.range?i.range[0]+e.from:e.from,o=i.range?i.range[1]-i.range[0]+1:e.to-e.from;y.drawArrays(s,l,r,o,a),c=!0}}),c},h.prototype.createData=function(e,t,n){return{instances:new Map,vao:new c(this._rctx,this._vertexAttributeLocations,{geometry:i.glLayout(e)},{geometry:s.createVertex(this._rctx,35044)}),buffer:new a.ResizableFloat32Array(t),optimalCount:0,origin:n,highlightCount:0}},h.prototype.removeAndRebuild=function(e,t,r,o,n){for(var i=0,a=t;i<a.length;i++){var s=a[i].uniqueName,l=e.instances.get(s);e.optimalCount-=(l.to-l.from)*r,e.instances.delete(s)}var c=0,u=e.buffer.array;n.begin=0,n.end=0;var d=-1,p=-1,f=0;e.instances.forEach(function(e){var t=e.from*r,n=e.to*r,i=n-t;d!==p&&p!==t?(u.set(o.subarray(d,p),f),f+=p-d,d=t):-1===d&&(d=t),p=n,e.from=c/r,c+=i,e.to=c/r}),d!==p&&u.set(o.subarray(d,p),f),n.end=c},h.prototype.removeByErasing=function(e,t,n,i){i.begin=1/0,i.end=-1/0;for(var r=-1,o=-1,a=0,s=t;a<s.length;a++){var l=s[a].uniqueName,c=e.instances.get(l),u=c.from*n,d=c.to*n;r!==o&&o!==u?(e.buffer.erase(r,o),r=u):-1===r&&(r=u),o=d,e.instances.delete(l),e.optimalCount-=d-u,u<i.begin&&(i.begin=u),d>i.end&&(i.end=d)}r!==o&&e.buffer.erase(r,o)},h.prototype.append=function(e,t,n,i,r){r.updatedDisplayedIndexRange=!1;for(var o=this._bufferWriter,a=0,s=t;a<s.length;a++){var l=s[a],c=l.data;m.mat4.multiply(b,i,l.transformation),m.mat4.invert(_,b),m.mat4.transpose(_,_);var u=r.end;o.write({transformation:b,invTranspTransformation:_},c,o.vertexBufferLayout.createView(e.buffer.array.buffer),r.end/n);var d=o.elementCount(c)*n,p=u+d;w.assert(null==e.instances.get(l.uniqueName));var f=y.generateRenderGeometryVisibleIndexRanges(l),h=y.generateRenderGeometryHighlightRanges(l);h&&(e.highlightCount=null);var v=new g(l.name,u/n,p/n,f,h,void 0,void 0,l.idx);e.instances.set(l.uniqueName,v),f&&(r.updatedDisplayedIndexRange=!0),e.optimalCount+=d,r.end+=d}},Object.defineProperty(h.prototype,"test",{get:function(){return{material:this._material}},enumerable:!0,configurable:!0}),h),A={updatedDisplayedIndexRange:!1,begin:0,end:0},C=d.mat4f64.create(),b=d.mat4f64.create(),_=d.mat4f64.create(),f=new Set;function h(e,t,n,i){void 0===i&&(i=r.Default3D),this.type="MergedRenderer",this._dataByOrigin=new Map,this._highlightCount=0,this._rctx=e,this._vertexAttributeLocations=i,this._material=n,this._materialRep=t,this._glMaterials=y.acquireMaterials(this._material,this._materialRep),this._bufferWriter=n.createBufferWriter()}return p}.apply(null,i))||(e.exports=r)},1780:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(12),n(484),n(1633),n(150),n(1661),n(1668),n(504),n(1700),n(1677),n(2740),n(1781),n(1702),n(1703),n(2741),n(2744),n(2748),n(1782)],void 0===(r=function(e,t,i,h,v,m,g,y,b,_,x,r,o,S,P,w,A,n,a){function C(e,t){return"on-the-ground"!==t.mode&&!(i.isNone(e.geometry)||!e.geometry.hasZ)}Object.defineProperty(t,"__esModule",{value:!0}),t.createGraphicMoveXYManipulator=function(e,t){return new n.GraphicManipulator({graphic:t,view:e,selectable:!0,cursor:"move"})},t.createGraphicMoveXYScreenDragToMap=function(e,t,n){return a.createXYConstrainedFromProject(o.createForGraphic(e,t.graphic,n.start),i.expect(t.graphic.geometry).spatialReference)},t.canMoveZ=C,t.createGraphicMoveZManipulator=function(e){var t=e.graphic,n=e.view;if(!b.enableEditing3D())return null;var i=y.getGraphicEffectiveElevationInfo(t);if(!C(t,i))return null;var r=[m.vec3f64.fromValues(0,0,0),m.vec3f64.fromValues(0,0,90)],o=new S(P.createPolylineGeometry(r),"move-z"),a=P.createConeGeometry(20,5,16,!1),s=new S(a),l=[m.vec3f64.fromValues(0,0,0),m.vec3f64.fromValues(0,0,110)],c=v.mat4f64.create();h.mat4.translate(c,c,[0,0,90]),h.mat4.rotateX(c,c,Math.PI/2);var u=v.mat4f64.create();function d(e){return 1<e?((n=new A({color:f,width:e},"move-z")).renderOccluded=4,n):((t=new w({color:f},"move-z")).renderOccluded=4,t);var t,n}h.mat4.translate(u,u,[0,0,90]),h.mat4.rotateX(u,u,Math.PI/2),h.mat4.scale(u,u,[1.2,1.2,1]);var p=m.vec3f64.fromValues(0,.5,.9),f=g.vec4f64.fromValues(p[0],p[1],p[2],1);return new _.Manipulator3D({view:n,renderObjects:[{geometry:o,material:d(1),stateMask:1},{geometry:s,transform:c,material:x.createManipulatorMaterial(p,1),stateMask:1},{geometry:o,material:d(2),stateMask:2},{geometry:s,transform:u,material:x.createManipulatorMaterial(p,1),stateMask:2}],collisionType:{type:"line",paths:[l]},autoScaleRenderObjects:!1,worldSized:!1,radius:4,selectable:!1,cursor:"ns-resize",elevationInfo:i,worldOriented:null==e.worldOriented||e.worldOriented,visible:!!t.visible})},t.createGraphicMoveZScreenDragToMap=function(e,t){var n=a.createZConstrainedFromProject(o.createCameraAlignedWorldUp(e,t.elevationAlignedLocation),t.location.spatialReference);return r.dragAtLocation(e,n,t.elevationAlignedLocation)}}.apply(null,i))||(e.exports=r)},1781:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(28),n(33),n(15),n(118),n(150),n(1668),n(1650),n(211),n(1761),n(1720)],void 0===(r=function(e,t,p,f,h,v,n,i,m,r,g,y){function o(i){return function(e,t){var n=i.toMap(e);return n&&r.pointToPoint(n,n,t)?n:null}}function a(i,r){var o=h.createScreenPointArray(),a=y.create(),s=n.vec3f64.create();return function(e,t){h.screenPointObjectToArray(e,o),y.fromScreenAtEye(i.state.camera,o,a);var n=i.renderCoordsHelper.intersectManifoldClosestSilhouette(a,r,s);return i.renderCoordsHelper.fromRenderCoords(n,t)}}Object.defineProperty(t,"__esModule",{value:!0}),t.createForGraphic=function(e,t,n){switch(i.getGraphicEffectiveElevationMode(t)){case"on-the-ground":return o(e);case"absolute-height":return a(e,e.toMap(n,{include:[t]}).z);default:return null}},t.createForGraphicAtLocation=function(e,t,n){switch(i.getGraphicEffectiveElevationMode(t)){case"on-the-ground":return o(e);case"absolute-height":return a(e,n.z);default:return null}},t.createOnTheGround=o,t.createAbsoluteHeight=a,t.createCameraAlignedWorldUp=function(r,e){var o=n.vec3f64.create();if(!r.renderCoordsHelper.toRenderCoords(e,o))return null;var a=v.vec3.length(o),s=n.vec3f64.create();r.renderCoordsHelper.worldUpAtPosition(o,s);var l=g.create(),c=h.createScreenPointArray(),u=n.vec3f64.create(),d=y.create();return function(e,t){var n=r.state.camera,i=v.vec3.cross(l,s,v.vec3.subtract(u,o,n.eye));return v.vec3.cross(i,i,s),g.fromPositionAndNormal(o,i,l),y.fromScreenAtEye(n,h.screenPointObjectToArray(e,c),d),g.intersectRay(l,d,u)?(v.vec3.subtract(u,u,o),m.vector.projectPoint(s,u,u),"global"!==r.viewingMode||v.vec3.length(u)*f.sign(v.vec3.dot(s,u))<.001-a&&v.vec3.subtract(u,v.vec3.scale(u,s,.001),o),v.vec3.add(u,u,o),r.renderCoordsHelper.fromRenderCoords(u,new p.Point,t)):null}}}.apply(null,i))||(e.exports=r)},1782:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(5),n(12)],void 0===(r=function(e,n,u,m){function i(o,a,s){if(m.isNone(o))return null;var l=null,c=0,u=0,d=0;return function(e){"start"===e.action&&(l=o(e.start,s),d=u=c=0);var t=c,n=u,i=d,r=o(e.screenPoint,s);return m.isSome(l)&&m.isSome(r)&&(t=1&a?r.x-l.x:0,n=2&a?r.y-l.y:0,i=4&a?r.z-l.z:0),{action:e.action,deltaX:c=t,deltaY:u=n,deltaZ:d=i,spatialReference:s}}}Object.defineProperty(n,"__esModule",{value:!0}),n.createFromProject=i,n.createMapAxisConstrainedScreenToMapDrag=function(s,e,l){if(m.isNone(s))return null;var t=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);if(0===t)return null;var c=e[0]/t,u=e[1]/t,d=e[2]/t,p=null,f=0,h=0,v=0;return function(e){"start"===e.action&&(p=s(e.start,l),v=h=f=0);var t=f,n=h,i=v,r=s(e.screenPoint,l);if(m.isSome(p)&&m.isSome(r)){t=r.x-p.x,n=r.y-p.y,i=r.z-p.z;var o=t*c+n*u+i*d;t=o*c,n=o*u,i=o*d}var a={action:e.action,deltaX:t,deltaY:n,deltaZ:i,previousDeltaX:f,previousDeltaY:h,previousDeltaZ:v,spatialReference:l};return f=t,h=n,v=i,a}},n.createXYConstrainedFromProject=function(e,t){return i(e,n.horizontalDegreesOfFreedom,t)},n.createZConstrainedFromProject=function(e,t){return i(e,n.verticalDegreesOfFreedom,t)},n.withHistoryInfo=function(a){if(m.isNone(a))return a;var s=0,l=0,c=0;return function(e){var t=a(e);if(m.isNone(t))return null;"start"===e.action&&(c=l=s=0);var n=t.deltaX-s,i=t.deltaY-l,r=t.deltaZ-c,o=u({},t,{deltaDeltaX:n,deltaDeltaY:i,deltaDeltaZ:r});return s=t.deltaX,l=t.deltaY,c=t.deltaZ,o}},n.withScreenHistoryInfo=function(o){if(m.isNone(o))return o;var a=0,s=0;return function(e){var t=o(e);if(m.isNone(t))return null;"start"===e.action&&(a=e.start.x,s=e.start.y);var n=e.screenPoint.x-a,i=e.screenPoint.y-s,r=u({},t,{screenDeltaDeltaX:n,screenDeltaDeltaY:i});return a=e.screenPoint.x,s=e.screenPoint.y,r}},n.horizontalDegreesOfFreedom=3,n.verticalDegreesOfFreedom=4}.apply(null,i))||(e.exports=r)},1783:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(12),n(44),n(1667)],void 0===(r=function(e,t,l,c,u){function n(r,o){var a=null,s=l.isSome(r[o])?r[o].spatialReference:null;return function(e){if("start"===e.action&&l.isSome(r[o])&&(n=r[o],i=e.spatialReference,a=l.isNone(n)||"mesh"===n.type?null:n.spatialReference.equals(i)?n.clone():c.canProject(n,i)?c.project(n,i):null),!l.isNone(a)){var t=u.move(a.clone(),e.deltaX,e.deltaY,e.deltaZ);t.spatialReference.equals(s)?r[o]=t:r[o]=c.project(t,s)}var n,i}}function i(e){return n(e,"geometry")}Object.defineProperty(t,"__esModule",{value:!0}),t.createGeometryDragAction=n,t.createGraphicDragAction=i,t.createGraphicDragActionMany=function(e){var n=e.map(i);return function(t){return n.forEach(function(e){return e(t)})}}}.apply(null,i))||(e.exports=r)},1851:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(2691),n(2751),n(2753)],void 0===(r=function(e,t,n,i,r){Object.defineProperty(t,"__esModule",{value:!0}),t.GraphicMove3DTool=n.GraphicMove3DTool,t.GraphicReshape3DTool=i.GraphicReshape3DTool,t.GraphicTransform3DTool=r.GraphicTransform3DTool}.apply(null,i))||(e.exports=r)},1852:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(11),n(484),n(1633),n(118),n(150),n(500),n(1673),n(2694),n(2695),n(1701),n(1642)],void 0===(r=function(e,t,n,i,s,f,h,v,l,c,o,r,a){var u,d=a.assert,p=(Object.defineProperty(_.prototype,"geometryRecords",{get:function(){return this._geometryRecords},enumerable:!0,configurable:!0}),Object.defineProperty(_.prototype,"geometries",{get:function(){return this._geometries},enumerable:!0,configurable:!0}),Object.defineProperty(_.prototype,"objectTransformation",{get:function(){return this._objectTransformation},set:function(e){i.mat4.copy(this._objectTransformation,e),this._invalidateBoundingVolume(),this._notifyDirty("objTransformation")},enumerable:!0,configurable:!0}),_.prototype.dispose=function(){for(var e=0,t=this._geometryRecords;e<t.length;e++){var n=t[e];c.pool.release(n)}this._geometryRecords=null,this._geometries=null},_.prototype._initializeGeometryRecords=function(e,t,n,i){if(!Array.isArray(e))return this._geometryRecords=[],void(this._geometries=[]);d(t.length===e.length,"Object3D: materials don't match geometries"),d(n.length===e.length,"Object3D: transformations don't match geometries"),this._geometryRecords=new Array(e.length),this._geometries=e.slice();for(var r=0;r<e.length;r++)this._geometryRecords[r]=c.pool.acquire(e[r],t[r],s.mat4f64.clone(n[r]),{},i&&i[r]);this._hasVolatileTransformation=!1},Object.defineProperty(_.prototype,"parentLayer",{get:function(){return this._parentLayer},set:function(e){d(null==this._parentLayer||null==e,"Object3D can only be added to a single Layer"),this._parentLayer=e},enumerable:!0,configurable:!0}),_.prototype.getNumGeometryRecords=function(){return this._geometryRecords.length},_.prototype.findGeometryRecords=function(e){for(var t=[],n=0;n<this._geometries.length;n++)this._geometries[n]===e&&t.push(this._geometryRecords[n]);return t},_.prototype.getGeometryRecord=function(e){return d(0<=e&&e<this._geometryRecords.length,"Object3d.getGeometryDataByIndex: index out of range"),this._geometryRecords[e]},_.prototype.addGeometry=function(e,t,n,i,r,o){n=n?s.mat4f64.clone(n):s.mat4f64.IDENTITY,this._geometries.push(e);var a=c.pool.acquire(e,t,n,i||{},r,o);return this._geometryRecords.push(a),this._hasVolatileTransformation=this._geometryRecords.some(function(e){return!!e.shaderTransformation}),this._notifyDirty("objGeometryAdded",a),this._invalidateBoundingVolume(),this._allComponentsHiddenDirty=!0,this._allComponentsVisibleDirty=!0,a},_.prototype.removeGeometry=function(e){var t=this._geometryRecords.splice(e,1)[0];return c.pool.release(t),this._hasVolatileTransformation=this._geometryRecords.some(function(e){return!!e.shaderTransformation}),this._geometries.splice(e,1),this._notifyDirty("objGeometryRemoved",t),this._invalidateBoundingVolume(),this._allComponentsHiddenDirty=!0,this._allComponentsVisibleDirty=!0,t},_.prototype.removeAllGeometries=function(){for(;0<this.getNumGeometryRecords();)this.removeGeometry(0)},_.prototype.geometryVertexAttrsUpdated=function(e){this._notifyDirty("vertexAttrsUpdated",this._geometryRecords[e]),this._invalidateBoundingVolume()},_.prototype.areAllComponentsHidden=function(){if(this._allComponentsHiddenDirty){this._allComponentsHiddenDirty=!1,this._allComponentsHidden=!0;for(var e=0,t=this._geometryRecords;e<t.length;e++){var n=t[e],i=n.instanceParameters.componentVisibilities,r=n.geometry.data.componentOffsets;if(!l.isAllHidden(i,r)){this._allComponentsHidden=!1;break}}}return this._allComponentsHidden},_.prototype.areAllComponentsVisible=function(){if(this._allComponentsVisibleDirty){this._allComponentsVisibleDirty=!1,this._allComponentsVisible=!0;for(var e=0,t=this._geometryRecords;e<t.length;e++){var n=t[e],i=n.instanceParameters.componentVisibilities,r=n.geometry.data.componentOffsets;if(!l.isAllVisible(i,r)){this._allComponentsVisible=!1;break}}}return this._allComponentsVisible},_.prototype.hasComponents=function(){for(var e=!1,t=0;t<this._geometries.length;t++){var n=this._geometries[t];if(e=l.hasComponents(n.data.componentOffsets))break}return e},_.prototype.setComponentVisibility=function(e,t,n){var i=e.geometry,r=e.instanceParameters.componentVisibilities,o=i.data.componentOffsets,a=l.updateVisibility(r,o,t,n);e.instanceParameters.componentVisibilities=a,this._notifyDirty("visibilityChanged",e),this._allComponentsHiddenDirty=!0,this._allComponentsVisibleDirty=!0},_.prototype.setHidden=function(e,t){e.instanceParameters.hidden=!!t,this._notifyDirty("visibilityChanged",e)},_.prototype.isHidden=function(e){return!!e.instanceParameters.hidden},_.prototype.getComponentVisibility=function(e,t){var n=e.instanceParameters.componentVisibilities;return l.getVisibility(n,t)},_.prototype.hideAllComponents=function(){if(this._allComponentsHiddenDirty||!this._allComponentsHidden){for(var e=0,t=this._geometryRecords;e<t.length;e++){var n=t[e],i=n.instanceParameters.componentVisibilities,r=l.hideAllComponents(i);n.instanceParameters.componentVisibilities=r}this._notifyDirty("visibilityChanged"),this._allComponentsHiddenDirty=!1,this._allComponentsVisibleDirty=!1,this._allComponentsHidden=!0,this._allComponentsVisible=!1}},_.prototype.unhideAllComponents=function(){if(this._allComponentsVisibleDirty||!this._allComponentsVisible){for(var e=0,t=this._geometryRecords;e<t.length;e++){var n=t[e],i=n.instanceParameters.componentVisibilities,r=l.unhideAllComponents(i);n.instanceParameters.componentVisibilities=r}this._notifyDirty("visibilityChanged"),this._allComponentsHiddenDirty=!1,this._allComponentsVisibleDirty=!1,this._allComponentsHidden=!1,this._allComponentsVisible=!0}},_.prototype._setComponentHighlight=function(e,t,n,i){var r=e.instanceParameters.componentHighlights,o=l.addHighlight(r,t,n,i);e.instanceParameters.componentHighlights=o},_.prototype.setComponentHighlight=function(e,t,n){var i=o.generateHighlightId();return this._setComponentHighlight(e,t,n,i),this._notifyDirty("componentHighlightChanged"),i},_.prototype.highlightAllComponents=function(e){for(var t=o.generateHighlightId(),n=0,i=this._geometryRecords;n<i.length;n++){var r=i[n];this._setComponentHighlight(r,null,e,t)}return this._notifyDirty("componentHighlightChanged"),t},_.prototype.removeHighlights=function(e){for(var t=0,n=this._geometryRecords;t<n.length;t++){var i=n[t].instanceParameters,r=i.componentHighlights,o=l.removeHighlight(r,e);i.componentHighlights=o}this._notifyDirty("componentHighlightChanged")},_.prototype.getComponentFromTriangleNr=function(e,t){d(0<=e&&e<this._geometryRecords.length,"Object3d.getComponentFromTriangleNr: index out of range");var n=this._geometryRecords[e].geometry.data.componentOffsets;return l.componentFind(n,3*t)},_.prototype.setGeometryTransformation=function(e,t){d(0<=e&&e<this._geometryRecords.length,"Object3d.setGeometryTransformation: index out of range");var n=this._geometryRecords[e];c.pool.release(n);var i=c.pool.acquire(n.geometry,n.material,s.mat4f64.clone(t),n.instanceParameters);this._geometryRecords[e]=i,this._notifyDirty("objGeometryReplaced",[n,i]),this._invalidateBoundingVolume()},_.prototype.getCombinedStaticTransformation=function(e,t){return t=t||s.mat4f64.create(),i.mat4.multiply(t,this.objectTransformation,e.getStaticTransformation()),t},_.prototype.getCombinedShaderTransformation=function(e,t){return t=t||s.mat4f64.create(),i.mat4.multiply(t,this.objectTransformation,e.getShaderTransformation()),t},_.prototype.hasVolativeTransformation=function(){return this._hasVolatileTransformation},_.prototype.getMetadata=function(){return this.metadata},_.prototype.getBBMin=function(e){return this._validateBoundingVolume(),e?this._bvObjectSpace.bbMin:this._bvWorldSpace.bbMin},_.prototype.getBBMax=function(e){return this._validateBoundingVolume(),e?this._bvObjectSpace.bbMax:this._bvWorldSpace.bbMax},_.prototype.getCenter=function(e){return this._validateBoundingVolume(),e?this._bvObjectSpace.center:this._bvWorldSpace.center},_.prototype.getBSRadius=function(e){return this._validateBoundingVolume(),e?this._bvObjectSpace.bsRadius:this._bvWorldSpace.bsRadius},_.prototype._validateBoundingVolume=function(){if(this._bvDirty||this._hasVolatileTransformation){this._bvObjectSpace.init(),this._bvWorldSpace.init();for(var e=0;e<this._geometryRecords.length;++e){var t=this._geometries[e],n=this._geometryRecords[e],i=t.boundingInfo;this._calculateTransformedBoundingVolume(i,this._bvObjectSpace,n.getShaderTransformation()),this._calculateTransformedBoundingVolume(i,this._bvWorldSpace,this.getCombinedShaderTransformation(n))}f.vec3.lerp(this._bvObjectSpace.center,this._bvObjectSpace.bbMin,this._bvObjectSpace.bbMax,.5),f.vec3.lerp(this._bvWorldSpace.center,this._bvWorldSpace.bbMin,this._bvWorldSpace.bbMax,.5);var r=h.vec3f64.create(),o=h.vec3f64.create(),a=v.maxScale(this.objectTransformation);for(e=0;e<this._geometryRecords.length;++e){t=this._geometries[e];var s=this._geometryRecords[e].getShaderTransformation(),l=v.maxScale(s);i=t.boundingInfo,f.vec3.transformMat4(r,i.getCenter(),s);var c=f.vec3.distance(r,this._bvObjectSpace.center),u=i.getBSRadius()*l;this._bvObjectSpace.bsRadius=Math.max(this._bvObjectSpace.bsRadius,c+u),f.vec3.transformMat4(o,r,this.objectTransformation);var d=f.vec3.distance(o,this._bvWorldSpace.center),p=u*a;this._bvWorldSpace.bsRadius=Math.max(this._bvWorldSpace.bsRadius,d+p)}this._bvDirty=!1}},_.prototype._calculateTransformedBoundingVolume=function(e,t,n){var i=e.getBBMin(),r=e.getBBMax(),o=h.vec3f64.clone(i),a=h.vec3f64.clone(r);f.vec3.transformMat4(o,o,n),f.vec3.transformMat4(a,a,n);for(var s=0;s<3;++s)t.bbMin[s]=Math.min(t.bbMin[s],o[s],a[s]),t.bbMax[s]=Math.max(t.bbMax[s],o[s],a[s]);for(s=0;s<3;++s){f.vec3.copy(o,i),f.vec3.copy(a,r),o[s]=r[s],a[s]=i[s],f.vec3.transformMat4(o,o,n),f.vec3.transformMat4(a,a,n);for(var l=0;l<3;++l)t.bbMin[l]=Math.min(t.bbMin[l],o[l],a[l]),t.bbMax[l]=Math.max(t.bbMax[l],o[l],a[l])}},_.prototype._invalidateBoundingVolume=function(){this._bvDirty=!0,this._parentLayer&&this._parentLayer.notifyObjectBBChanged(this,{center:this._bvWorldSpace.center,radius:this._bvWorldSpace.bsRadius})},_.prototype._notifyDirty=function(e,t,n,i){if(this._parentLayer){n=n||1;var r=i||this;this._parentLayer.notifyDirty(e,t,n,r)}},Object.defineProperty(_.prototype,"test",{get:function(){var t=this;return{hasGeometry:function(e){return-1<t._geometries.indexOf(e)},getGeometryIndex:function(e){return t._geometries.indexOf(e)}}},enumerable:!0,configurable:!0}),_._idGen=new r.IdGen,_),m=(b.prototype.isEmpty=function(){return this.bbMax[0]<this.bbMin[0]&&this.bbMax[1]<this.bbMin[1]&&this.bbMax[2]<this.bbMin[2]},b),g=(n(y,u=m),y.prototype.init=function(){f.vec3.set(this.bbMin,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),f.vec3.set(this.bbMax,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),f.vec3.set(this.center,0,0,0),this.bsRadius=0},y.prototype.getCenter=function(){return this.center},y.prototype.getBSRadius=function(){return this.bsRadius},y);function y(){var e=u.call(this)||this;return e.center=h.vec3f64.create(),e.bsRadius=0,e}function b(){this.bbMin=h.vec3f64.fromValues(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.bbMax=h.vec3f64.fromValues(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}function _(e){void 0===e&&(e={}),this._objectTransformation=s.mat4f64.create(),this._bvObjectSpace=new g,this._bvWorldSpace=new g,this._bvDirty=!0,this._hasVolatileTransformation=!1,this._allComponentsHiddenDirty=!0,this._allComponentsVisibleDirty=!0,this.id=_._idGen.gen(e.idHint),this.castShadow=null==e.castShadow||e.castShadow,this.metadata=e.metadata,this.metadata&&this.metadata.isElevationSource&&(this.metadata.lastValidElevationBB=new m),this.objectTransformation=s.mat4f64.create(),this._initializeGeometryRecords(e.geometries,e.materials,e.transformations,e.origins)}return p}.apply(null,i))||(e.exports=r)},1853:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1763),n(1642)],void 0===(r=function(e,t,y,b){function _(e,t,n,i,r){var o=n.typedBuffer,a=n.typedBufferStride,s=e.length;if(i*=a,null==r||1===r)for(var l=0;l<s;++l){var c=2*e[l];o[i]=t[c],o[i+1]=t[c+1],i+=a}else for(l=0;l<s;++l){c=2*e[l];for(var u=0;u<r;++u)o[i]=t[c],o[i+1]=t[c+1],i+=a}}function x(e,t,n,i,r){var o=n.typedBuffer,a=n.typedBufferStride,s=e.length;if(i*=a,null==r||1===r)for(var l=0;l<s;++l){var c=3*e[l];o[i]=t[c],o[i+1]=t[c+1],o[i+2]=t[c+2],i+=a}else for(l=0;l<s;++l){c=3*e[l];for(var u=0;u<r;++u)o[i]=t[c],o[i+1]=t[c+1],o[i+2]=t[c+2],i+=a}}function S(e,t,n,i,r){var o=n.typedBuffer,a=n.typedBufferStride,s=e.length;if(i*=a,null==r||1===r)for(var l=0;l<s;++l){var c=4*e[l];o[i]=t[c],o[i+1]=t[c+1],o[i+2]=t[c+2],o[i+3]=t[c+3],i+=a}else for(l=0;l<s;++l){c=4*e[l];for(var u=0;u<r;++u)o[i]=t[c],o[i+1]=t[c+1],o[i+2]=t[c+2],o[i+3]=t[c+3],i+=a}}function P(e,t,n,i,r,o){if(n){var a=n,s=i.typedBuffer,l=i.typedBufferStride,c=e.length;if(r*=l,null==o||1===o)for(var u=0;u<c;++u){var d=t[h=3*e[u]],p=t[h+1],f=t[h+2];s[r]=a[0]*d+a[4]*p+a[8]*f+a[12],s[r+1]=a[1]*d+a[5]*p+a[9]*f+a[13],s[r+2]=a[2]*d+a[6]*p+a[10]*f+a[14],r+=l}else for(u=0;u<c;++u){d=t[h=3*e[u]],p=t[h+1],f=t[h+2];for(var h,v=a[0]*d+a[4]*p+a[8]*f+a[12],m=a[1]*d+a[5]*p+a[9]*f+a[13],g=a[2]*d+a[6]*p+a[10]*f+a[14],y=0;y<o;++y)s[r]=v,s[r+1]=m,s[r+2]=g,r+=l}}else x(e,t,i,r,o)}function w(e,t,n,i,r,o){if(n){var a=n,s=i.typedBuffer,l=i.typedBufferStride,c=e.length;if(r*=l,null==o||1===o)for(var u=0;u<c;++u){var d=t[h=3*e[u]],p=t[h+1],f=t[h+2];s[r]=a[0]*d+a[4]*p+a[8]*f,s[r+1]=a[1]*d+a[5]*p+a[9]*f,s[r+2]=a[2]*d+a[6]*p+a[10]*f,r+=l}else for(u=0;u<c;++u){d=t[h=3*e[u]],p=t[h+1],f=t[h+2];for(var h,v=a[0]*d+a[4]*p+a[8]*f,m=a[1]*d+a[5]*p+a[9]*f,g=a[2]*d+a[6]*p+a[10]*f,y=0;y<o;++y)s[r]=v,s[r+1]=m,s[r+2]=g,r+=l}}else x(e,t,i,r,o)}function A(e,t,n,i,r,o){var a=i.typedBuffer,s=i.typedBufferStride,l=e.length;if(r*=s,null==o||1===o){if(4===n)for(var c=0;c<l;++c){var u=4*e[c];a[r]=t[u],a[r+1]=t[u+1],a[r+2]=t[u+2],a[r+3]=t[u+3],r+=s}else if(3===n)for(c=0;c<l;++c){u=3*e[c];a[r]=t[u],a[r+1]=t[u+1],a[r+2]=t[u+2],a[r+3]=255,r+=s}}else if(4===n)for(c=0;c<l;++c){u=4*e[c];for(var d=0;d<o;++d)a[r]=t[u],a[r+1]=t[u+1],a[r+2]=t[u+2],a[r+3]=t[u+3],r+=s}else if(3===n)for(c=0;c<l;++c)for(u=3*e[c],d=0;d<o;++d)a[r]=t[u],a[r+1]=t[u+1],a[r+2]=t[u+2],a[r+3]=255,r+=s}Object.defineProperty(t,"__esModule",{value:!0}),t.writeBufferVec2=_,t.writeBufferVec3=x,t.writeBufferVec4=S,t.writeBufferMat3f=function(e,t,n,i){var r=n.typedBuffer,o=n.typedBufferStride,a=e.length;i*=o;for(var s=0;s<a;++s){for(var l=9*e[s],c=0;c<9;++c)r[i+c]=t[l+c];i+=o}},t.writeBufferMat4f=function(e,t,n,i){var r=n.typedBuffer,o=n.typedBufferStride,a=e.length;i*=o;for(var s=0;s<a;++s){for(var l=16*e[s],c=0;c<16;++c)r[i+c]=t[l+c];i+=o}},t.writePosition=P,t.writeNormal=w,t.writeColor=A,t.writeMultipliedColor=function(e,t,n,i,r,o,a){var s=r.typedBuffer,l=r.typedBufferStride,c=e.length;if(o*=l,null==a||1===a){if(4===n)for(var u=0;u<c;++u){var d=4*e[u];s[o]=t[d]*i[0],s[o+1]=t[d+1]*i[1],s[o+2]=t[d+2]*i[2],s[o+3]=t[d+3]*i[3],o+=l}else if(3===n){var p=255*i[3];for(u=0;u<c;++u){d=3*e[u];s[o]=t[d]*i[0],s[o+1]=t[d+1]*i[1],s[o+2]=t[d+2]*i[2],s[o+3]=p,o+=l}}}else if(4===n)for(u=0;u<c;++u){d=4*e[u];for(var f=0;f<a;++f)s[o]=t[d]*i[0],s[o+1]=t[d+1]*i[1],s[o+2]=t[d+2]*i[2],s[o+3]=t[d+3]*i[3],o+=l}else if(3===n)for(p=255*i[3],u=0;u<c;++u)for(d=3*e[u],f=0;f<a;++f)s[o]=t[d]*i[0],s[o+1]=t[d+1]*i[1],s[o+2]=t[d+2]*i[2],s[o+3]=p,o+=l},t.writeDefaultAttributes=function(e,t,n,i,r,o){for(var a=0,s=t.fieldNames;a<s.length;a++){var l=s[a],c=e.vertexAttr[l],u=e.indices[l];if(c&&u)switch(l){case b.VertexAttrConstants.POSITION:b.assert(3===c.size);var d=r.getField(l,y.BufferViewVec3f);d&&P(u,c.data,n,d,o);break;case b.VertexAttrConstants.NORMAL:b.assert(3===c.size);var p=r.getField(l,y.BufferViewVec3f);p&&w(u,c.data,i,p,o);break;case b.VertexAttrConstants.UV0:b.assert(2===c.size);var f=r.getField(l,y.BufferViewVec2f);f&&_(u,c.data,f,o);break;case b.VertexAttrConstants.REGION:b.assert(4===c.size);var h=r.getField(l,y.BufferViewVec4u16);h&&S(u,c.data,h,o);break;case b.VertexAttrConstants.COLOR:b.assert(3===c.size||4===c.size);var v=r.getField(l,y.BufferViewVec4u8);v&&A(u,c.data,c.size,v,o);break;case b.VertexAttrConstants.SYMBOLCOLOR:b.assert(3===c.size||4===c.size);var m=r.getField(l,y.BufferViewVec4u8);m&&A(u,c.data,c.size,m,o);break;case b.VertexAttrConstants.TANGENT:b.assert(4===c.size);var g=r.getField(l,y.BufferViewVec4f);g&&S(u,c.data,g,o)}}}}.apply(null,i))||(e.exports=r)},1854:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1972),n(1629)],void 0===(r=function(e,t,n,i,r){function o(e){e.include(i.RgbaFloatEncoding),e.fragment.uniforms.add("depthTex","sampler2D"),e.fragment.uniforms.add("shadowMapNum","int"),e.fragment.uniforms.add("shadowMapDistance","vec4"),e.fragment.uniforms.add("shadowMapMatrix","mat4",4),e.fragment.uniforms.add("depthHalfPixelSz","float"),e.fragment.code.add(r.glsl(a=a||n(["\n    float readShadowMap(const in vec3 _vpos, float _linearDepth) {\n      float halfPixelSize = depthHalfPixelSz;\n      vec4 distance = shadowMapDistance;\n      float depth = _linearDepth;\n\n      //choose correct cascade\n      int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\n\n      if (i >= shadowMapNum) { return 0.0; }\n\n      mat4 mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];\n\n      vec4 lv = mat * vec4(_vpos, 1.0);\n      lv.xy /= lv.w;\n\n      // vertex completely outside? -> no shadow\n      vec3 lvpos = 0.5 * lv.xyz + vec3(0.5);\n      if (lvpos.z >= 1.0) { return 0.0; }\n      if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\n\n      // calc coord in cascade texture\n      vec2 uv = vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\n\n      float texSize = 0.5 / halfPixelSize;\n\n      // filter, offset by half pixels\n      vec2 st = fract((vec2(halfPixelSize) + uv) * texSize);\n\n      float s00 = rgba2float(texture2D(depthTex, uv + vec2(-halfPixelSize, -halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s10 = rgba2float(texture2D(depthTex, uv + vec2(halfPixelSize, -halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s11 = rgba2float(texture2D(depthTex, uv + vec2(halfPixelSize, halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s01 = rgba2float(texture2D(depthTex, uv + vec2(-halfPixelSize, halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n\n      return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n    }\n  "],["\n    float readShadowMap(const in vec3 _vpos, float _linearDepth) {\n      float halfPixelSize = depthHalfPixelSz;\n      vec4 distance = shadowMapDistance;\n      float depth = _linearDepth;\n\n      //choose correct cascade\n      int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\n\n      if (i >= shadowMapNum) { return 0.0; }\n\n      mat4 mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];\n\n      vec4 lv = mat * vec4(_vpos, 1.0);\n      lv.xy /= lv.w;\n\n      // vertex completely outside? -> no shadow\n      vec3 lvpos = 0.5 * lv.xyz + vec3(0.5);\n      if (lvpos.z >= 1.0) { return 0.0; }\n      if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\n\n      // calc coord in cascade texture\n      vec2 uv = vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\n\n      float texSize = 0.5 / halfPixelSize;\n\n      // filter, offset by half pixels\n      vec2 st = fract((vec2(halfPixelSize) + uv) * texSize);\n\n      float s00 = rgba2float(texture2D(depthTex, uv + vec2(-halfPixelSize, -halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s10 = rgba2float(texture2D(depthTex, uv + vec2(halfPixelSize, -halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s11 = rgba2float(texture2D(depthTex, uv + vec2(halfPixelSize, halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s01 = rgba2float(texture2D(depthTex, uv + vec2(-halfPixelSize, halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n\n      return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n    }\n  "])))}var a;Object.defineProperty(t,"__esModule",{value:!0}),t.ReadShadowMap=o,(o=t.ReadShadowMap||(t.ReadShadowMap={})).bindUniforms=function(e,t){t.shadowMappingEnabled&&t.shadowMap.bindView(e,t.origin)}}.apply(null,i))||(e.exports=r)},1855:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(2713),n(1856),n(1629)],void 0===(r=function(e,t,i,r,o,a){var s,l,c,u,d,p,f,h,v,m,g;Object.defineProperty(t,"__esModule",{value:!0}),t.PhysicallyBasedRendering=function(e,t){var n=e.fragment.code;e.include(o.PiUtils),t.usePBRforWater?(n.add(a.glsl(s=s||i(["\n    struct PBRShadingWater\n    {\n        float NdotL;   // cos angle between normal and light direction\n        float NdotV;   // cos angle between normal and view direction\n        float NdotH;   // cos angle between normal and half vector\n        float VdotH;   // cos angle between view direction and half vector\n        float LdotH;   // cos angle between light direction and half vector\n        float VdotN;   // cos angle between view direction and normal vector\n    };\n\n    float dtrExponent = ",";\n    "],["\n    struct PBRShadingWater\n    {\n        float NdotL;   // cos angle between normal and light direction\n        float NdotV;   // cos angle between normal and view direction\n        float NdotH;   // cos angle between normal and half vector\n        float VdotH;   // cos angle between view direction and half vector\n        float LdotH;   // cos angle between light direction and half vector\n        float VdotN;   // cos angle between view direction and normal vector\n    };\n\n    float dtrExponent = ",";\n    "]),t.useCustomDTRExponentForWater?"2.2":"2.0")),n.add(a.glsl(l=l||i(["\n    vec3 fresnelReflection(float angle, vec3 f0, float f90) {\n      return f0 + (f90 - f0) * pow(1.0 - angle, 5.0);\n    }\n    "],["\n    vec3 fresnelReflection(float angle, vec3 f0, float f90) {\n      return f0 + (f90 - f0) * pow(1.0 - angle, 5.0);\n    }\n    "]))),n.add(a.glsl(c=c||i(["\n    float normalDistributionWater(float NdotH, float roughness)\n    {\n      float r2 = roughness * roughness;\n      float NdotH2 = NdotH * NdotH;\n      float denom = pow((NdotH2 * (r2 - 1.0) + 1.0), dtrExponent) * PI;\n      return r2 / denom;\n    }\n    "],["\n    float normalDistributionWater(float NdotH, float roughness)\n    {\n      float r2 = roughness * roughness;\n      float NdotH2 = NdotH * NdotH;\n      float denom = pow((NdotH2 * (r2 - 1.0) + 1.0), dtrExponent) * PI;\n      return r2 / denom;\n    }\n    "]))),n.add(a.glsl(u=u||i(["\n    float geometricOcclusionKelemen(float LoH)\n    {\n        return 0.25 / (LoH * LoH);\n    }\n    "],["\n    float geometricOcclusionKelemen(float LoH)\n    {\n        return 0.25 / (LoH * LoH);\n    }\n    "]))),n.add(a.glsl(d=d||i(["\n    vec3 brdfWater(in PBRShadingWater props, float roughness, vec3 F0, float F0Max)\n    {\n      vec3  F = fresnelReflection(props.VdotH, F0, F0Max);\n      float D = normalDistributionWater(props.NdotH, roughness);\n      float V = geometricOcclusionKelemen(props.LdotH);\n      return (D * V) * F;\n    }\n\n    vec3 tonemapACES(const vec3 x) {\n      return (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);\n    }\n    "],["\n    vec3 brdfWater(in PBRShadingWater props, float roughness, vec3 F0, float F0Max)\n    {\n      vec3  F = fresnelReflection(props.VdotH, F0, F0Max);\n      float D = normalDistributionWater(props.NdotH, roughness);\n      float V = geometricOcclusionKelemen(props.LdotH);\n      return (D * V) * F;\n    }\n\n    vec3 tonemapACES(const vec3 x) {\n      return (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);\n    }\n    "])))):t.usePBR&&(e.include(r.AnalyticalSkyModel),n.add(a.glsl(p=p||i(["\n    struct PBRShadingInfo\n    {\n        float NdotL;                  // cos angle between normal and light direction\n        float NdotV;                  // cos angle between normal and view direction\n        float NdotH;                  // cos angle between normal and half vector\n        float VdotH;                  // cos angle between view direction and half vector\n        float LdotH;                  // cos angle between view light direction and half vector\n        float NdotNG;                 // cos angle between normal and normal of the ground\n        float RdotNG;                 // cos angle between view direction reflected of the normal and normal of the ground\n        float NdotAmbDir;             // cos angle between view direction and the fill light in ambient illumination\n        float NdotH_Horizon;          // cos angle between normal and half vector defined with horizon illumination\n        vec3 skyRadianceToSurface;         // integrated radiance of the sky based on the surface roughness (used for specular reflection)\n        vec3 groundRadianceToSurface;      // integrated radiance of the ground based on the surface roughness (used for specular reflection)\n        vec3 skyIrradianceToSurface;       // irradiance of the sky (used for diffuse reflection)\n        vec3 groundIrradianceToSurface;    // irradiance of the ground (used for diffuse reflection)\n\n        float averageAmbientRadiance;      // average ambient radiance used to deduce black level in gamut mapping\n        float ssao;                   // ssao coefficient\n        vec3 groundReflectance;       // reflectance of the ground\n        vec3 albedoLinear;            // linear color of the albedo\n        vec3 f0;                      // fresnel value at normal incident light\n        vec3 f90;                     // fresnel value at 90o of incident light\n\n        vec3 diffuseColor;            // diffuse color of the material used in environment illumination\n        float metalness;              // metalness of the material\n        float roughness;              // roughness of the material\n    };\n    "],["\n    struct PBRShadingInfo\n    {\n        float NdotL;                  // cos angle between normal and light direction\n        float NdotV;                  // cos angle between normal and view direction\n        float NdotH;                  // cos angle between normal and half vector\n        float VdotH;                  // cos angle between view direction and half vector\n        float LdotH;                  // cos angle between view light direction and half vector\n        float NdotNG;                 // cos angle between normal and normal of the ground\n        float RdotNG;                 // cos angle between view direction reflected of the normal and normal of the ground\n        float NdotAmbDir;             // cos angle between view direction and the fill light in ambient illumination\n        float NdotH_Horizon;          // cos angle between normal and half vector defined with horizon illumination\n        vec3 skyRadianceToSurface;         // integrated radiance of the sky based on the surface roughness (used for specular reflection)\n        vec3 groundRadianceToSurface;      // integrated radiance of the ground based on the surface roughness (used for specular reflection)\n        vec3 skyIrradianceToSurface;       // irradiance of the sky (used for diffuse reflection)\n        vec3 groundIrradianceToSurface;    // irradiance of the ground (used for diffuse reflection)\n\n        float averageAmbientRadiance;      // average ambient radiance used to deduce black level in gamut mapping\n        float ssao;                   // ssao coefficient\n        vec3 groundReflectance;       // reflectance of the ground\n        vec3 albedoLinear;            // linear color of the albedo\n        vec3 f0;                      // fresnel value at normal incident light\n        vec3 f90;                     // fresnel value at 90o of incident light\n\n        vec3 diffuseColor;            // diffuse color of the material used in environment illumination\n        float metalness;              // metalness of the material\n        float roughness;              // roughness of the material\n    };\n    "]))),n.add(a.glsl(f=f||i(["\n    const float fillLightIntensity = 0.25;              // intensity of the directional ambient component\n    const float horizonLightDiffusion = 0.4;            // diffusion value describing the area and smoothness of the horizon light\n    const vec3  skyTransmittance = vec3(0.9, 0.9, 1.0);  // bluish transmittance of the sky\n    const float additionalAmbientIrradianceFactor = 0.02;// Additional irradiance factor - making everything brighter and more colorful\n    "],["\n    const float fillLightIntensity = 0.25;              // intensity of the directional ambient component\n    const float horizonLightDiffusion = 0.4;            // diffusion value describing the area and smoothness of the horizon light\n    const vec3  skyTransmittance = vec3(0.9, 0.9, 1.0);  // bluish transmittance of the sky\n    const float additionalAmbientIrradianceFactor = 0.02;// Additional irradiance factor - making everything brighter and more colorful\n    "]))),n.add(a.glsl(h=h||i(["\n    float normalDistribution(float NdotH, float roughness)\n    {\n        float a = NdotH * roughness;\n        float b = roughness / (1.0 - NdotH * NdotH + a * a);\n        return b * b * INV_PI;\n    }\n    "],["\n    float normalDistribution(float NdotH, float roughness)\n    {\n        float a = NdotH * roughness;\n        float b = roughness / (1.0 - NdotH * NdotH + a * a);\n        return b * b * INV_PI;\n    }\n    "]))),n.add(a.glsl(v=v||i(["\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n    const vec2 c2 = vec2(-1.04, 1.04);\n\n    vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {\n        vec4 r = roughness * c0 + c1;\n        float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;\n        return c2 * a004 + r.zw;\n    }\n    "],["\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n    const vec2 c2 = vec2(-1.04, 1.04);\n\n    vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {\n        vec4 r = roughness * c0 + c1;\n        float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;\n        return c2 * a004 + r.zw;\n    }\n    "]))),n.add(a.glsl(m=m||i(["\n    vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {\n      vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);\n      vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);\n\n      // From diffuse illumination calculate reflected color\n      vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;\n\n      // From specular illumination calculate reflected color\n      vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);\n      vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;\n      vec3 specularComponent = specularColor * indirectSpecular;\n\n      return (diffuseComponent + specularComponent);\n    }\n    "],["\n    vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {\n      vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);\n      vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);\n\n      // From diffuse illumination calculate reflected color\n      vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;\n\n      // From specular illumination calculate reflected color\n      vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);\n      vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;\n      vec3 specularComponent = specularColor * indirectSpecular;\n\n      return (diffuseComponent + specularComponent);\n    }\n    "]))),n.add(a.glsl(g=g||i(["\n    float gamutMapChanel(float x, vec2 p){\n      return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );\n    }\n\n    // Because of the fresnel refletion the image might be too bright we apply black level soft compression gamut mapping\n    vec3 blackLevelSoftCompression(vec3 inColor, PBRShadingInfo inputs){\n      vec3 outColor;\n      // based on the average ambient radiance we approximate the black level for a specific time of a day\n      // p.x - the deduced black level\n      // p.y - the value to which we map the black level (around 1/3 of the black level)\n      vec2 p = vec2(0.02 * (inputs.averageAmbientRadiance), 0.0075 * (inputs.averageAmbientRadiance));\n      // gamut map individual color changels\n      outColor.x = gamutMapChanel(inColor.x, p) ;\n      outColor.y = gamutMapChanel(inColor.y, p) ;\n      outColor.z = gamutMapChanel(inColor.z, p) ;\n\n      return outColor;\n    }\n    "],["\n    float gamutMapChanel(float x, vec2 p){\n      return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );\n    }\n\n    // Because of the fresnel refletion the image might be too bright we apply black level soft compression gamut mapping\n    vec3 blackLevelSoftCompression(vec3 inColor, PBRShadingInfo inputs){\n      vec3 outColor;\n      // based on the average ambient radiance we approximate the black level for a specific time of a day\n      // p.x - the deduced black level\n      // p.y - the value to which we map the black level (around 1/3 of the black level)\n      vec2 p = vec2(0.02 * (inputs.averageAmbientRadiance), 0.0075 * (inputs.averageAmbientRadiance));\n      // gamut map individual color changels\n      outColor.x = gamutMapChanel(inColor.x, p) ;\n      outColor.y = gamutMapChanel(inColor.y, p) ;\n      outColor.z = gamutMapChanel(inColor.z, p) ;\n\n      return outColor;\n    }\n    "]))))}}.apply(null,i))||(e.exports=r)},1856:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r,o;Object.defineProperty(t,"__esModule",{value:!0}),t.PiUtils=function(e){e.vertex.code.add(i.glsl(r=r||n(["\n    const float PI = 3.141592653589793;\n  "],["\n    const float PI = 3.141592653589793;\n  "]))),e.fragment.code.add(i.glsl(o=o||n(["\n    const float PI = 3.141592653589793;\n    const float LIGHT_NORMALIZATION = 1.0 / PI;\n    const float INV_PI = 0.3183098861837907;\n    const float HALF_PI = 1.570796326794897;\n    "],["\n    const float PI = 3.141592653589793;\n    const float LIGHT_NORMALIZATION = 1.0 / PI;\n    const float INV_PI = 0.3183098861837907;\n    const float HALF_PI = 1.570796326794897;\n    "])))}}.apply(null,i))||(e.exports=r)},1857:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){function r(e){e.fragment.uniforms.add("depthTex","sampler2D"),e.fragment.uniforms.add("highlightViewportPixelSz","vec4"),e.fragment.code.add(i.glsl(o=o||n(["\n    void outputHighlight() {\n      vec4 fragCoord = gl_FragCoord;\n\n      float sceneDepth = texture2D(depthTex, (fragCoord.xy - highlightViewportPixelSz.xy) * highlightViewportPixelSz.zw).r;\n      if (fragCoord.z > sceneDepth + 5e-6) {\n        gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n      }\n      else {\n        gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n      }\n    }\n  "],["\n    void outputHighlight() {\n      vec4 fragCoord = gl_FragCoord;\n\n      float sceneDepth = texture2D(depthTex, (fragCoord.xy - highlightViewportPixelSz.xy) * highlightViewportPixelSz.zw).r;\n      if (fragCoord.z > sceneDepth + 5e-6) {\n        gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n      }\n      else {\n        gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n      }\n    }\n  "])))}var o;Object.defineProperty(t,"__esModule",{value:!0}),t.OutputHighlight=r,(r=t.OutputHighlight||(t.OutputHighlight={})).bindOutputHighlight=function(e,t,n){e.bindTexture(n.highlightDepthTexture,5),t.setUniform1i("depthTex",5),t.setUniform4f("highlightViewportPixelSz",0,0,1/n.viewport[2],1/n.viewport[3])}}.apply(null,i))||(e.exports=r)},1858:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){function r(e,t){(t.vvSize||t.vvColor)&&e.attributes.add("instanceFeatureAttribute","vec4"),t.vvSize?(e.vertex.uniforms.add("vvSizeMinSize","vec3"),e.vertex.uniforms.add("vvSizeMaxSize","vec3"),e.vertex.uniforms.add("vvSizeOffset","vec3"),e.vertex.uniforms.add("vvSizeFactor","vec3"),e.vertex.uniforms.add("vvSymbolRotationMatrix","mat3"),e.vertex.uniforms.add("vvSymbolAnchor","vec3"),e.vertex.code.add(i.glsl(s=s||n(["\n      vec4 vvTransformPosition(vec3 position, vec4 _featureAttribute) {\n        vec3 vvScale = clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);\n        return vec4(vvSymbolRotationMatrix * (vvScale * (position + vvSymbolAnchor)), 1.0);\n      }\n    "],["\n      vec4 vvTransformPosition(vec3 position, vec4 _featureAttribute) {\n        vec3 vvScale = clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);\n        return vec4(vvSymbolRotationMatrix * (vvScale * (position + vvSymbolAnchor)), 1.0);\n      }\n    "]))),e.vertex.code.add(i.glsl(l=l||n(["\n      const float eps = 1.192092896e-07;\n      vec4 vvTransformNormal(vec3 _normal, vec4 _featureAttribute) {\n        vec3 vvScale = clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize + eps, vvSizeMaxSize);\n        return vec4(vvSymbolRotationMatrix * _normal / vvScale, 1.0);\n      }\n\n      vec4 vvLocalNormal(vec3 _normal) {\n        return vvTransformNormal(_normal, instanceFeatureAttribute);\n      }\n\n      vec4 localPosition() {\n        return vvTransformPosition(position, instanceFeatureAttribute);\n      }\n    "],["\n      const float eps = 1.192092896e-07;\n      vec4 vvTransformNormal(vec3 _normal, vec4 _featureAttribute) {\n        vec3 vvScale = clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize + eps, vvSizeMaxSize);\n        return vec4(vvSymbolRotationMatrix * _normal / vvScale, 1.0);\n      }\n\n      vec4 vvLocalNormal(vec3 _normal) {\n        return vvTransformNormal(_normal, instanceFeatureAttribute);\n      }\n\n      vec4 localPosition() {\n        return vvTransformPosition(position, instanceFeatureAttribute);\n      }\n    "])))):e.vertex.code.add(i.glsl(c=c||n(["\n      vec4 localPosition() { return vec4(position, 1.0); }\n\n      vec4 vvLocalNormal(vec3 _normal) { return vec4(_normal, 1.0); }\n    "],["\n      vec4 localPosition() { return vec4(position, 1.0); }\n\n      vec4 vvLocalNormal(vec3 _normal) { return vec4(_normal, 1.0); }\n    "]))),t.vvColor?(e.vertex.defines.addInt("VV_COLOR_N",8),e.vertex.code.add(i.glsl(u=u||n(["\n      uniform float vvColorValues[VV_COLOR_N];\n      uniform vec4 vvColorColors[VV_COLOR_N];\n\n      vec4 vvGetColor(vec4 featureAttribute, float values[VV_COLOR_N], vec4 colors[VV_COLOR_N]) {\n        float value = featureAttribute.y;\n        if (value <= values[0]) {\n          return colors[0];\n        }\n\n        for (int i = 1; i < VV_COLOR_N; ++i) {\n          if (values[i] >= value) {\n            float f = (value - values[i-1]) / (values[i] - values[i-1]);\n            return mix(colors[i-1], colors[i], f);\n          }\n        }\n        return colors[VV_COLOR_N - 1];\n      }\n\n      vec4 vvColor() {\n        return vvGetColor(instanceFeatureAttribute, vvColorValues, vvColorColors);\n      }\n    "],["\n      uniform float vvColorValues[VV_COLOR_N];\n      uniform vec4 vvColorColors[VV_COLOR_N];\n\n      vec4 vvGetColor(vec4 featureAttribute, float values[VV_COLOR_N], vec4 colors[VV_COLOR_N]) {\n        float value = featureAttribute.y;\n        if (value <= values[0]) {\n          return colors[0];\n        }\n\n        for (int i = 1; i < VV_COLOR_N; ++i) {\n          if (values[i] >= value) {\n            float f = (value - values[i-1]) / (values[i] - values[i-1]);\n            return mix(colors[i-1], colors[i], f);\n          }\n        }\n        return colors[VV_COLOR_N - 1];\n      }\n\n      vec4 vvColor() {\n        return vvGetColor(instanceFeatureAttribute, vvColorValues, vvColorColors);\n      }\n    "])))):e.vertex.code.add(i.glsl(d=d||n(["\n      vec4 vvColor() { return vec4(1.0); }\n    "],["\n      vec4 vvColor() { return vec4(1.0); }\n    "])))}function o(e,t){t.vvSizeEnabled&&(e.setUniform3fv("vvSizeMinSize",t.vvSizeMinSize),e.setUniform3fv("vvSizeMaxSize",t.vvSizeMaxSize),e.setUniform3fv("vvSizeOffset",t.vvSizeOffset),e.setUniform3fv("vvSizeFactor",t.vvSizeFactor)),t.vvColorEnabled&&(e.setUniform1fv("vvColorValues",t.vvColorValues),e.setUniform4fv("vvColorColors",t.vvColorColors))}var a,s,l,c,u,d;Object.defineProperty(t,"__esModule",{value:!0}),t.VisualVariables=r,(a=r=t.VisualVariables||(t.VisualVariables={})).bindUniformsWithOpacity=function(e,t){o(e,t),t.vvOpacityEnabled&&(e.setUniform1fv("vvOpacityValues",t.vvOpacityValues),e.setUniform1fv("vvOpacityOpacities",t.vvOpacityOpacities))},a.bindUniformsForSymbols=function(e,t){o(e,t),t.vvSizeEnabled&&(e.setUniform3fv("vvSymbolAnchor",t.vvSymbolAnchor),e.setUniformMatrix3fv("vvSymbolRotationMatrix",t.vvSymbolRotationMatrix))}}.apply(null,i))||(e.exports=r)},1859:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r,o,a;Object.defineProperty(t,"__esModule",{value:!0}),t.VertexColor=function(e,t){t.attributeColor?(e.attributes.add("color","vec4"),e.varyings.add("vColor","vec4"),e.vertex.code.add(i.glsl(r=r||n(["\n      void forwardVertexColor() { vColor = color; }\n    "],["\n      void forwardVertexColor() { vColor = color; }\n    "]))),e.vertex.code.add(i.glsl(o=o||n(["\n      void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }\n    "],["\n      void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }\n    "])))):e.vertex.code.add(i.glsl(a=a||n(["\n      void forwardVertexColor() {}\n      void forwardNormalizedVertexColor() {}\n    "],["\n      void forwardVertexColor() {}\n      void forwardNormalizedVertexColor() {}\n    "])))}}.apply(null,i))||(e.exports=r)},1860:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1),n(0),n(13),n(23),n(14),n(4),n(50),n(2),n(338),n(2750)],void 0===(r=function(e,t,n,i,r,o,a,s,l,c,u,d){Object.defineProperty(t,"__esModule",{value:!0});var p,f=(p=c.declared(r),n(h,p),Object.defineProperty(h.prototype,"active",{get:function(){return null!=this.view&&this.view.activeTool===this},enumerable:!0,configurable:!0}),Object.defineProperty(h.prototype,"isSupported",{get:function(){return!0},enumerable:!0,configurable:!0}),Object.defineProperty(h.prototype,"visible",{set:function(e){this._set("visible",e),e||u.setActive(this,!1),this.attached&&(e?this._show():this._hide())},enumerable:!0,configurable:!0}),Object.defineProperty(h.prototype,"editable",{get:function(){return this.hasEditableFlag(0)},set:function(e){this.setEditableFlag(0,e)},enumerable:!0,configurable:!0}),h.prototype.attach=function(){!this.attached&&this.isSupported&&(this.manipulators.attach(),this.onAttach(),this.visible&&this.onShow(),this._set("attached",!0))},h.prototype.detach=function(){this.attached&&(this.onHide(),this.onDetach(),this.manipulators.detach(),this._manipulatorHandles.removeAll(),this._set("attached",!1))},h.prototype.handleInputEvent=function(e){this.attached&&this.onInputEvent(e)},h.prototype.destroy=function(){this.manipulators.destroy(),this._manipulatorHandles&&(this._manipulatorHandles.destroy(),this._manipulatorHandles=null),this._set("view",null)},h.prototype.setEditableFlag=function(e,t){this._editableFlags[e]=t,this.manipulators.isToolEditable=this._editableFlags.every(function(e){return null==e||e}),this._updateManipulatorAttachment(),0===e&&this.notifyChange("editable"),this.onEditableChange()},h.prototype.hasEditableFlag=function(e){var t=this._editableFlags[e];return null==t||t},h.prototype.when=function(){return this._creationResolver.promise},h.prototype.rejectCreation=function(e){this._creationResolver.reject(e)},h.prototype.initialize=function(){this.deferCreation||this.complete()},h.prototype.onAttach=function(){},h.prototype.onDetach=function(){},h.prototype.onShow=function(){},h.prototype.onHide=function(){},h.prototype.onEditableChange=function(){},h.prototype.onInputEvent=function(e){},Object.defineProperty(h.prototype,"internallyEditable",{get:function(){return this.hasEditableFlag(0)&&this.hasEditableFlag(1)},enumerable:!0,configurable:!0}),h.prototype.create=function(){var e=this;this.created||(this._set("created",!0),a("esri-native-promise")?this._creationResolver(this):l.schedule(function(){return e._creationResolver(e)}))},h.prototype.complete=function(){this.create(),this._set("completed",!0)},h.prototype._show=function(){this._updateManipulatorAttachment(),this.onShow()},h.prototype._hide=function(){this._updateManipulatorAttachment(),this.onHide()},h.prototype._updateManipulatorAttachment=function(){this.attached&&this.visible?this.manipulators.attach():this.manipulators.detach()},i([c.property({constructOnly:!0})],h.prototype,"view",void 0),i([c.property({dependsOn:["view.activeTool"],readOnly:!0})],h.prototype,"active",null),i([c.property({value:!0})],h.prototype,"visible",null),i([c.property({value:!0})],h.prototype,"editable",null),i([c.property({readOnly:!0})],h.prototype,"attached",void 0),i([c.property({readOnly:!0})],h.prototype,"created",void 0),i([c.property({readOnly:!0})],h.prototype,"completed",void 0),i([c.property({readOnly:!0})],h.prototype,"manipulators",void 0),i([c.property({constructOnly:!0})],h.prototype,"deferCreation",void 0),i([c.subclass("esri.views.interactive.InteractiveToolBase")],h));function h(e){var t=p.call(this,e)||this;return t.attached=!1,t.created=!1,t.completed=!1,t.manipulators=new d.ManipulatorCollection,t.deferCreation=!1,t._editableFlags=new Array,t._manipulatorHandles=new o,t._creationResolver=s.createResolver(),t}t.InteractiveToolBase=f}.apply(null,i))||(e.exports=r)},1861:function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.HANDLE_COLOR=[1,.5,0],t.GEOMETRY_SEGMENTS=128,t.DISC_RADIUS=70,t.DISC_COLLISION_RADIUS=80,t.DISC_HEIGHT=.02,t.DISC_TRANSLATE_ARROW_SIZE=54,t.DISC_TRANSLATE_ARROW_OFFSET=100,t.RING_RADIUS=160,t.RING_HEIGHT=.5,t.RING_THICKNESS=24,t.INDICATOR_THICKNESS=9,t.INNER_INDICATOR_RADIUS=t.RING_RADIUS+30,t.OUTER_INDICATOR_RADIUS=t.RING_RADIUS+53,t.ROTATE_INDICATOR_ARROW_TIP_LENGTH=60,t.ROTATE_INDICATOR_ARROW_TIP_RADIUS=23,t.ROTATE_INDICATOR_ARC_LENGTH=5*Math.PI/12,t.SCALE_INDICATOR_ARC_LENGTH=1*Math.PI/3,t.DRAG_THRESHOLD_PX=10,t.ROTATE_INDICATOR_ARROW_PLACEMENT_PERCENTAGE=.2,t.SCALE_INDICATOR_OFFSET1=30,t.SCALE_INDICATOR_OFFSET2=53,t.SCALE_INDICATOR_DIRECTION_BUFFER=.2,t.ROTATE_INDICATOR_DIRECTION_BUFFER=.3,t.RING_INDICATOR_DELAY_MS=200,t.RING_RESET_ANIMATION_SPEED_FACTOR=3,t.ALIGN_ARROWS_SCALE_THRESHOLD=1e6}.apply(null,i))||(e.exports=r)},1862:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(5),n(11),n(1740),n(1778),n(1980),n(1678),n(1678),n(1779),n(2756)],void 0===(r=function(e,t,n,i,r,o,a,s,l,c,u){var d,p,f,h,v=(h=o.Material,i(P,h),P.prototype.setParameterValues=function(e){s.updateParameters(this.params,e)&&this.notifyDirty("matChanged")},P.prototype.getParameters=function(){return this.params},P.prototype.getTechniqueConfig=function(e){return this.techniqueConfig.output=e,this.techniqueConfig.cullFace=this.params.cullFace,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.polygonOffset=this.params.polygonOffset,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig},P.prototype.getPassParameters=function(){return this.params},P.prototype.intersect=function(e,t,n,i,r,o,a){l.intersectTriangleGeometry(e,t,i,r,o,void 0,a)},P.prototype.getGLMaterials=function(){return{color:g,depthShadowMap:void 0,normal:void 0,depth:void 0,highlight:y}},P.prototype.createBufferWriter=function(){return new a.DefaultBufferWriter(a.PositionColorLayout)},P.prototype.createRenderer=function(e,t){return new c(e,t,this)},P),m=(f=r.GLMaterial,i(S,f),S.prototype.updateParameters=function(){this.technique=this.techniqueRep.acquireAndReleaseExisting(u.ColorMaterialTechnique,this.material.getTechniqueConfig(this.output),this.technique)},S.prototype.beginSlot=function(e){if(4===this.output)return 4===e;var t=4;return this.technique.configuration.transparent&&(t=this.technique.configuration.writeDepth?6:9),e===t},S.prototype.getProgram=function(){return this.technique.program},S.prototype.getPrograms=function(){return null},S.prototype.bind=function(e,t){e.bindProgram(this.technique.program),this.technique.bindPipelineState(e),this.technique.bindPass(e,this.material.getPassParameters(),t)},S.prototype.release=function(){},S.prototype.bindView=function(e){this.technique.bindDraw(e)},S.prototype.bindInstance=function(e){this.technique.bindInstance(e)},S.prototype.getDrawMode=function(){return 4},S),g=(i(x,p=m),x),y=(i(_,d=m),_),b={color:[1,1,1,1],transparent:!1,writeDepth:!0,vertexColors:!1,polygonOffset:!1,slicePlaneEnabled:!1,cullFace:0};function _(e){return d.call(this,n({},e,{output:4}))||this}function x(e){return p.call(this,n({},e,{output:0}))||this}function S(e){var t=f.call(this,e)||this;return t.output=e.output,t.updateParameters(),t}function P(e,t){var n=h.call(this,t)||this;return n.supportsEdges=!0,n.techniqueConfig=new u.ColorMaterialTechniqueConfiguration,n.params=l.copyParameters(e,b),n}return v}.apply(null,i))||(e.exports=r)},1966:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(11),n(49),n(54),n(118),n(150),n(1701),n(2693)],void 0===(r=function(e,t,n,r,i,o,a,s,l){return n(c,u=i),c.prototype.addParentStage=function(t){if(!this._parentStages.has(t)){var e=this.on("dirty",function(e){t.notifyDirty(e.origin,e.dirtyType,e.subObject)});this._parentStages.set(t,e)}},c.prototype.removeParentStage=function(e){var t=this._parentStages.get(e);t&&(t.remove(),this._parentStages.delete(e)),this.invalidateSpatialQueryAccelerator()},c.prototype.getName=function(){return this.name},c.prototype.getGroup=function(){return this.group},c.prototype.getTranslation=function(){return this.translation},c.prototype.getObjectIds=function(){return r.keysOfSet(this._children,function(e){return e.id})},c.prototype.getObjects=function(){return r.keysOfSet(this._children)},c.prototype.getExtent=function(){return this._updateExtent(),this._extent},c.prototype.addObject=function(e){this._children.add(e),(e.parentLayer=this).notifyDirty("layerObjectAdded",e),this._invalidateExtent(),this._octree&&this._octree.add(e)},c.prototype.hasObject=function(e){return this._children.has(e)},c.prototype.removeObject=function(e){return!!this._children.delete(e)&&(e.parentLayer=null,this.notifyDirty("layerObjectRemoved",e),this._invalidateExtent(),this._octree&&this._octree.remove(e),!0)},c.prototype.notifyObjectBBChanged=function(e,t){this._octree&&this._octree.update(e,t)},c.prototype.getCenter=function(){this._updateExtent();var e=a.vec3f64.create();return o.vec3.lerp(e,this._extent[0],this._extent[1],.5)},c.prototype.getBSRadius=function(){return this._updateExtent(),.5*o.vec3.distance(this._extent[0],this._extent[1])},c.prototype.getSpatialQueryAccelerator=function(){return!this._octree&&50<this._children.size&&this._createOctree(),this._octree},c.prototype.shaderTransformationChanged=function(){this.notifyDirty("shaderTransformationChanged",null)},c.prototype.invalidateSpatialQueryAccelerator=function(){this._octree&&(this._octree.destroy(),this._octree=null)},c.prototype.notifyDirty=function(e,t,n,i){var r={origin:i||this,dirtyType:e,subObject:t};this.emit("dirty",r)},c.prototype._createOctree=function(){for(var e=this.getExtent(),t=0,n=0;n<3;n++)t=Math.max(t,e[1][n]-e[0][n]);var i=a.vec3f64.create();o.vec3.lerp(i,e[0],e[1],.5),this._octree=new l(i,1.2*t,{getRadius:function(e){return e.getBSRadius()},getCenter:function(e){return e.getCenter()}}),this._octree.add(r.keysOfSet(this._children))},c.prototype._invalidateExtent=function(){this._extentDirty=!0},c.prototype._updateExtent=function(){var r=this;if(this._extentDirty){if(this._extentDirty=!1,0===this._children.size)return void(this._extent=[[0,0,0],[0,0,0]]);var o=null;this._children.forEach(function(e){var t=e.getBBMin(),n=e.getBBMax();if(o)for(var i=0;i<3;++i)r._extent[0][i]=Math.min(r._extent[0][i],t[i]),r._extent[1][i]=Math.max(r._extent[1][i],n[i]);else o=[a.vec3f64.clone(t),a.vec3f64.clone(n)]}),this._extent=o}},c._idGen=new s.IdGen,c;function c(e,t,n){var i=u.call(this)||this;return i._parentStages=new Map,i._children=new Set,i.id=c._idGen.gen(e),i.apiLayerUid=n,i.name=e,t=t||{},i.group=t.group||"",i.isVisible=null==t.isVisible||t.isVisible,i.isPickable=null==t.isPickable||t.isPickable,i.isSliceable=!1,i.translation=t.translation?a.vec3f64.clone(t.translation):a.vec3f64.create(),i._extent=[a.vec3f64.fromValues(0,0,0),a.vec3f64.fromValues(1e3,1e3,1e3)],i._extentDirty=!0,i}var u}.apply(null,i))||(e.exports=r)},1967:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,i,r){var o,a,s,l;Object.defineProperty(t,"__esModule",{value:!0}),t.DiscardOrAdjustAlpha=function(e,t){var n=e.fragment;switch(t.alphaDiscardMode){case 0:n.code.add(r.glsl(o=o||i(["\n        void discardOrAdjustAlpha(inout vec4 color) {}\n      "],["\n        void discardOrAdjustAlpha(inout vec4 color) {}\n      "])));break;case 1:n.code.add(r.glsl(a=a||i(["\n        void discardOrAdjustAlpha(inout vec4 color) {\n          color.a = 1.0;\n        }\n      "],["\n        void discardOrAdjustAlpha(inout vec4 color) {\n          color.a = 1.0;\n        }\n      "])));break;case 2:n.uniforms.add("textureAlphaCutoff","float"),n.code.add(r.glsl(s=s||i(["\n        #define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } else { color.a = 1.0; } }\n      "],["\n        #define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } else { color.a = 1.0; } }\n      "])));break;case 3:e.fragment.uniforms.add("textureAlphaCutoff","float"),e.fragment.code.add(r.glsl(l=l||i(["\n        #define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } }\n      "],["\n        #define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } }\n      "])))}},t.TEXTURE_ALPHA_CUTOFF_DEFAULT=.1}.apply(null,i))||(e.exports=r)},1968:function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=function(e,t){function o(e,t,n){for(var i=0;i<n;++i)t[2*i]=e[i],t[2*i+1]=e[i]-t[2*i]}Object.defineProperty(t,"__esModule",{value:!0}),t.encodeDouble=function(e,t){s[0]=e,s[1]=e-s[0],t[0]=s[0],t[1]=s[1]},t.encodeDoubleArray=o,t.decodeDoubleArray=function(e,t,n){for(var i=0;i<n;++i)t[i]=e[2*i]+e[2*i+1]},t.encodeDoubleArraySplit=function(e,t,n,i){for(var r=0;r<i;++r)a[0]=e[r],o(a,s,1),t[r]=s[0],n[r]=s[1]};var a=new Float64Array(1),s=new Float32Array(2)}.apply(null,i))||(e.exports=r)},1969:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(484),n(1633)],void 0===(r=function(e,t,c,u){return function(e,t,n,i,r,o,a,s,l){this.name=e,this.from=t,this.to=n,this.displayedIndexRange=i,this.highlightedIndexRanges=r,this.transformation=o,this.instanceParameters=a,this.idx=s,this.dataId=l,null!=o&&(this.transformationNormal=u.mat4f64.clone(o),c.mat4.invert(this.transformationNormal,this.transformationNormal),c.mat4.transpose(this.transformationNormal,this.transformationNormal))}}.apply(null,i))||(e.exports=r)},1970:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(484),n(1633),n(1673),n(1642),n(507)],void 0===(r=function(e,t,r,n,o,a,f){Object.defineProperty(t,"__esModule",{value:!0}),t.generateRenderGeometryVisibleIndexRanges=function(e){if(e.instanceParameters.hidden)return[];var t=e.instanceParameters.componentVisibilities,n=e.componentOffsets;return o.generateVisibleIndexRanges(t,n)},t.generateRenderGeometryHighlightRanges=function(e){if(e.instanceParameters.hidden)return null;var t=e.instanceParameters.componentVisibilities,n=e.instanceParameters.componentHighlights,i=e.componentOffsets;return o.generateHighlightedIndexRanges(t,n,i)},t.doesRenderGeometryHaveHighlights=function(e){if(e.instanceParameters.hidden)return!1;var t=e.instanceParameters.componentVisibilities,n=e.instanceParameters.componentHighlights,i=e.componentOffsets;return o.hasHighlights(t,n,i)},t.isRenderGeometryHidden=function(e){if(e.instanceParameters.hidden)return!0;var t=e.instanceParameters.componentVisibilities,n=e.componentOffsets;return o.isAllHidden(t,n)},t.drawArrays=function(e,t,n,i,r){e.drawArrays(t,n,i),r&&(r.drawCalls++,4===t&&(r.triangles+=i))},t.drawElements=function(e,t,n,i,r,o){var a=f.getBytesPerElement(n);e.drawElements(t,r,n,i*a),o&&(o.drawCalls++,4===t&&(o.triangles+=r))},t.drawArraysFaceRange=function(e,t,n,i,r){for(var o=0,a=0,s=t;a<s.length;a++){var l=s[a],c=l[0]+n,u=l[1]-l[0]+1;o+=u,e.drawArrays(i,c,u)}r&&(r.drawCalls+=t.length,4===i&&(r.triangles=o/3))},t.drawElementsFaceRange=function(e,t,n,i,r,o){for(var a=f.getBytesPerElement(r),s=0,l=0,c=t;l<c.length;l++){var u=c[l],d=u[0]+n,p=u[1]-u[0]+1;s+=p,e.drawElements(i,p,r,d*a)}o&&(o.drawCalls+=t.length,4===i&&(o.triangles+=s/3))},t.acquireMaterials=function(e,t){var n=new Map;return n.set(0,t.acquire(e,"color")),n.set(3,t.acquire(e,"depthShadowMap")),n.set(2,t.acquire(e,"normal")),n.set(1,t.acquire(e,"depth")),n.set(4,t.acquire(e,"highlight")),n},t.releaseMaterials=function(e,t){t.release(e.id,"color"),t.release(e.id,"depthShadowMap"),t.release(e.id,"normal"),t.release(e.id,"depth"),t.release(e.id,"highlight")},t.calculateTransformRelToOrigin=function(e,t,n){var i=e.origin.vec3;a.setMatrixTranslation3(s,-i[0],-i[1],-i[2]),r.mat4.multiply(t,s,e.transformation),n&&(r.mat4.invert(n,t),r.mat4.transpose(n,n))};var s=n.mat4f64.create()}.apply(null,i))||(e.exports=r)},1971:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r,o,a;Object.defineProperty(t,"__esModule",{value:!0}),t.ForwardLinearDepth=function(e,t){0===t.output&&t.receiveShadows?(e.varyings.add("linearDepth","float"),e.vertex.code.add(i.glsl(r=r||n(["\n      void forwardLinearDepth() { linearDepth = gl_Position.w; }\n    "],["\n      void forwardLinearDepth() { linearDepth = gl_Position.w; }\n    "])))):1===t.output||3===t.output?(e.varyings.add("linearDepth","float"),e.vertex.uniforms.add("uCameraNearFar","vec2"),e.vertex.code.add(i.glsl(o=o||n(["\n      void forwardLinearDepth() {\n        linearDepth = (-position_view().z - uCameraNearFar[0]) / (uCameraNearFar[1] - uCameraNearFar[0]);\n      }\n    "],["\n      void forwardLinearDepth() {\n        linearDepth = (-position_view().z - uCameraNearFar[0]) / (uCameraNearFar[1] - uCameraNearFar[0]);\n      }\n    "])))):e.vertex.code.add(i.glsl(a=a||n(["\n      void forwardLinearDepth() {}\n    "],["\n      void forwardLinearDepth() {}\n    "])))}}.apply(null,i))||(e.exports=r)},1972:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.RgbaFloatEncoding=function(e){var t=i.glsl(r=r||n(["\n    // This is the maximum float value representable as 32bit fixed point,\n    // it is rgba2float(vec4(1)) inlined.\n    const float MAX_RGBA_FLOAT =\n      255.0 / 256.0 +\n      255.0 / 256.0 / 256.0 +\n      255.0 / 256.0 / 256.0 / 256.0 +\n      255.0 / 256.0 / 256.0 / 256.0 / 256.0;\n\n    // Factors to convert to fixed point, i.e. factors (256^0, 256^1, 256^2, 256^3)\n    const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\n\n    vec4 float2rgba(const float value) {\n      // Make sure value is in the domain we can represent\n      float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\n\n      // Decompose value in 32bit fixed point parts represented as\n      // uint8 rgba components. Decomposition uses the fractional part after multiplying\n      // by a power of 256 (this removes the bits that are represented in the previous\n      // component) and then converts the fractional part to 8bits.\n      vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\n\n      // Convert uint8 values (from 0 to 255) to floating point representation for\n      // the shader\n      const float toU8AsFloat = 1.0 / 255.0;\n\n      return fixedPointU8 * toU8AsFloat;\n    }\n\n    // Factors to convert rgba back to float\n    const vec4 RGBA_2_FLOAT_FACTORS = vec4(\n      255.0 / (256.0),\n      255.0 / (256.0 * 256.0),\n      255.0 / (256.0 * 256.0 * 256.0),\n      255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n    );\n\n    float rgba2float(vec4 rgba) {\n      // Convert components from 0->1 back to 0->255 and then\n      // add the components together with their corresponding\n      // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n      return dot(rgba, RGBA_2_FLOAT_FACTORS);\n    }\n  "],["\n    // This is the maximum float value representable as 32bit fixed point,\n    // it is rgba2float(vec4(1)) inlined.\n    const float MAX_RGBA_FLOAT =\n      255.0 / 256.0 +\n      255.0 / 256.0 / 256.0 +\n      255.0 / 256.0 / 256.0 / 256.0 +\n      255.0 / 256.0 / 256.0 / 256.0 / 256.0;\n\n    // Factors to convert to fixed point, i.e. factors (256^0, 256^1, 256^2, 256^3)\n    const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\n\n    vec4 float2rgba(const float value) {\n      // Make sure value is in the domain we can represent\n      float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\n\n      // Decompose value in 32bit fixed point parts represented as\n      // uint8 rgba components. Decomposition uses the fractional part after multiplying\n      // by a power of 256 (this removes the bits that are represented in the previous\n      // component) and then converts the fractional part to 8bits.\n      vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\n\n      // Convert uint8 values (from 0 to 255) to floating point representation for\n      // the shader\n      const float toU8AsFloat = 1.0 / 255.0;\n\n      return fixedPointU8 * toU8AsFloat;\n    }\n\n    // Factors to convert rgba back to float\n    const vec4 RGBA_2_FLOAT_FACTORS = vec4(\n      255.0 / (256.0),\n      255.0 / (256.0 * 256.0),\n      255.0 / (256.0 * 256.0 * 256.0),\n      255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n    );\n\n    float rgba2float(vec4 rgba) {\n      // Convert components from 0->1 back to 0->255 and then\n      // add the components together with their corresponding\n      // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n      return dot(rgba, RGBA_2_FLOAT_FACTORS);\n    }\n  "]));e.fragment.code.add(t),e.vertex.code.add(t)}}.apply(null,i))||(e.exports=r)},1973:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1974),n(1629)],void 0===(r=function(e,t,r,o,a){function n(e,t){var n=e.fragment,i=t.hasMetalnessAndRoughnessTexture||t.hasEmissionTexture||t.hasOcclusionTexture;t.usePBR&&i&&e.include(o.VertexTextureCoordinates,t),t.usePBR&&(n.uniforms.add("roughnessFactor","float"),n.uniforms.add("metalnessFactor","float"),n.uniforms.add("emissionFactor","vec3"),n.uniforms.add("reflectanceFactor","float"),n.code.add(a.glsl(s=s||r(["\n    float reflectance;\n    float roughness;\n    float metalness;\n    vec3 emission;\n    float occlusion;\n    "],["\n    float reflectance;\n    float roughness;\n    float metalness;\n    vec3 emission;\n    float occlusion;\n    "]))),t.hasMetalnessAndRoughnessTexture&&(n.uniforms.add("texMetallicRoughness","sampler2D"),t.supportsTextureAtlas&&n.uniforms.add("texMetallicRoughnessSize","vec2"),n.code.add(a.glsl(l=l||r(["\n    void applyMetallnessAndRoughness(TextureLookupParameter params) {\n      vec3 metallicRoughness = textureLookup(texMetallicRoughness, params).rgb;\n\n      roughness *= metallicRoughness.g;\n      metalness *= metallicRoughness.b;\n    }\n    "],["\n    void applyMetallnessAndRoughness(TextureLookupParameter params) {\n      vec3 metallicRoughness = textureLookup(texMetallicRoughness, params).rgb;\n\n      roughness *= metallicRoughness.g;\n      metalness *= metallicRoughness.b;\n    }\n    "])))),t.hasEmissionTexture&&(n.uniforms.add("texEmission","sampler2D"),t.supportsTextureAtlas&&n.uniforms.add("texEmissionSize","vec2"),n.code.add(a.glsl(c=c||r(["\n    void applyEmission(TextureLookupParameter params) {\n      emission *= textureLookup(texEmission, params).rgb;\n    }\n    "],["\n    void applyEmission(TextureLookupParameter params) {\n      emission *= textureLookup(texEmission, params).rgb;\n    }\n    "]))))),t.usePBR&&t.hasOcclusionTexture?(n.uniforms.add("texOcclusion","sampler2D"),t.supportsTextureAtlas&&n.uniforms.add("texOcclusionSize","vec2"),n.code.add(a.glsl(u=u||r(["\n    void applyOcclusion(TextureLookupParameter params) {\n      occlusion *= textureLookup(texOcclusion, params).r;\n    }\n\n    float getBakedOcclusion() {\n      return occlusion;\n    }\n    "],["\n    void applyOcclusion(TextureLookupParameter params) {\n      occlusion *= textureLookup(texOcclusion, params).r;\n    }\n\n    float getBakedOcclusion() {\n      return occlusion;\n    }\n    "])))):n.code.add(a.glsl(d=d||r(["\n    float getBakedOcclusion() { return 1.0; }\n    "],["\n    float getBakedOcclusion() { return 1.0; }\n    "]))),t.usePBR&&n.code.add(a.glsl(p=p||r(["\n    void applyPBRFactors() {\n      reflectance = reflectanceFactor;\n      roughness = roughnessFactor;\n      metalness = metalnessFactor;\n      emission = emissionFactor;\n      occlusion = 1.0;\n      ","\n      ","\n      ","\n      ","\n    }\n  "],["\n    void applyPBRFactors() {\n      reflectance = reflectanceFactor;\n      roughness = roughnessFactor;\n      metalness = metalnessFactor;\n      emission = emissionFactor;\n      occlusion = 1.0;\n      ","\n      ","\n      ","\n      ","\n    }\n  "]),i?"vtc.uv = vuv0;":"",t.hasMetalnessAndRoughnessTexture?t.supportsTextureAtlas?"vtc.size = texMetallicRoughnessSize; applyMetallnessAndRoughness(vtc);":"applyMetallnessAndRoughness(vtc);":"",t.hasEmissionTexture?t.supportsTextureAtlas?"vtc.size = texEmissionSize; applyEmission(vtc);":"applyEmission(vtc);":"",t.hasOcclusionTexture?t.supportsTextureAtlas?"vtc.size = texOcclusionSize; applyOcclusion(vtc);":"applyOcclusion(vtc);":""))}var s,l,c,u,d,p;Object.defineProperty(t,"__esModule",{value:!0}),t.PhysicallyBasedRenderingParameters=n,(n=t.PhysicallyBasedRenderingParameters||(t.PhysicallyBasedRenderingParameters={})).bindUniforms=function(e,t){e.setUniform1f("metalnessFactor",t.metallicFactor),e.setUniform1f("roughnessFactor",t.roughnessFactor),e.setUniform3fv("emissionFactor",t.emissiveFactor),e.setUniform1f("reflectanceFactor",t.reflectanceFactor)}}.apply(null,i))||(e.exports=r)},1974:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1975),n(2718),n(1629)],void 0===(r=function(e,t,n,i,r,o){var a,s,l;Object.defineProperty(t,"__esModule",{value:!0}),t.VertexTextureCoordinates=function(e,t){e.include(i.TextureCoordinateAttribute,t),e.fragment.code.add(o.glsl(a=a||n(["\n  struct TextureLookupParameter {\n    vec2 uv;\n    ","\n  } vtc;\n  "],["\n  struct TextureLookupParameter {\n    vec2 uv;\n    ","\n  } vtc;\n  "]),t.supportsTextureAtlas?"vec2 size;":"")),1===t.attributeTextureCoordinates&&e.fragment.code.add(o.glsl(s=s||n(["\n      vec4 textureLookup(sampler2D tex, TextureLookupParameter params) {\n        return texture2D(tex, params.uv);\n      }\n    "],["\n      vec4 textureLookup(sampler2D tex, TextureLookupParameter params) {\n        return texture2D(tex, params.uv);\n      }\n    "]))),2===t.attributeTextureCoordinates&&(e.include(r.TextureAtlasLookup),e.fragment.code.add(o.glsl(l=l||n(["\n    vec4 textureLookup(sampler2D tex, TextureLookupParameter params) {\n        return textureAtlasLookup(tex, params.size, params.uv, vuvRegion);\n      }\n    "],["\n    vec4 textureLookup(sampler2D tex, TextureLookupParameter params) {\n        return textureAtlasLookup(tex, params.size, params.uv, vuvRegion);\n      }\n    "]))))}}.apply(null,i))||(e.exports=r)},1975:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r,o,a;Object.defineProperty(t,"__esModule",{value:!0}),t.TextureCoordinateAttribute=function(e,t){1===t.attributeTextureCoordinates&&(e.attributes.add("uv0","vec2"),e.varyings.add("vuv0","vec2"),e.vertex.code.add(i.glsl(r=r||n(["\n      void forwardTextureCoordinates() {\n        vuv0 = uv0;\n      }\n    "],["\n      void forwardTextureCoordinates() {\n        vuv0 = uv0;\n      }\n    "])))),2===t.attributeTextureCoordinates&&(e.attributes.add("uv0","vec2"),e.varyings.add("vuv0","vec2"),e.attributes.add("uvRegion","vec4"),e.varyings.add("vuvRegion","vec4"),e.vertex.code.add(i.glsl(o=o||n(["\n      void forwardTextureCoordinates() {\n        vuv0 = uv0;\n        vuvRegion = uvRegion;\n      }\n    "],["\n      void forwardTextureCoordinates() {\n        vuv0 = uv0;\n        vuvRegion = uvRegion;\n      }\n    "])))),0===t.attributeTextureCoordinates&&e.vertex.code.add(i.glsl(a=a||n(["\n      void forwardTextureCoordinates() {}\n    "],["\n      void forwardTextureCoordinates() {}\n    "])))}}.apply(null,i))||(e.exports=r)},1976:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(14),n(1629),n(2719)],void 0===(r=function(e,t,n,i,r,o){var a,s;Object.defineProperty(t,"__esModule",{value:!0}),t.DoublePrecision=function(e,t){t.doublePrecisionRequiresObfuscation?e.vertex.code.add(r.glsl(a=a||n(["\n      vec3 dpPlusFrc(vec3 a, vec3 b) {\n        return mix(a, a + b, vec3(notEqual(b, vec3(0))));\n      }\n\n      vec3 dpMinusFrc(vec3 a, vec3 b) {\n        return mix(vec3(0), a - b, vec3(notEqual(a, b)));\n      }\n\n      // based on https://www.thasler.com/blog/blog/glsl-part2-emu\n      vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n        vec3 t1 = dpPlusFrc(hiA, hiB);\n        vec3 e = dpMinusFrc(t1, hiA);\n        vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\n        return t1 + t2;\n      }\n    "],["\n      vec3 dpPlusFrc(vec3 a, vec3 b) {\n        return mix(a, a + b, vec3(notEqual(b, vec3(0))));\n      }\n\n      vec3 dpMinusFrc(vec3 a, vec3 b) {\n        return mix(vec3(0), a - b, vec3(notEqual(a, b)));\n      }\n\n      // based on https://www.thasler.com/blog/blog/glsl-part2-emu\n      vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n        vec3 t1 = dpPlusFrc(hiA, hiB);\n        vec3 e = dpMinusFrc(t1, hiA);\n        vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\n        return t1 + t2;\n      }\n    "]))):e.vertex.code.add(r.glsl(s=s||n(["\n      vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n        vec3 t1 = hiA + hiB;\n        vec3 e = t1 - hiA;\n        vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n        return t1 + t2;\n      }\n    "],["\n      vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n        vec3 t1 = hiA + hiB;\n        vec3 e = t1 - hiA;\n        vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n        return t1 + t2;\n      }\n    "])))},t.doublePrecisionRequiresObfuscation=function(e){return!!i("force-double-precision-obfuscation")||o.testWebGLDriver(e).doublePrecisionRequiresObfuscation}}.apply(null,i))||(e.exports=r)},1977:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,i,r){var o,a;Object.defineProperty(t,"__esModule",{value:!0}),t.EvaluateAmbientOcclusion=function(e,t){var n=e.fragment;t.receiveAmbientOcclusion?(n.uniforms.add("ssaoTex","sampler2D"),n.uniforms.add("viewportPixelSz","vec4"),n.code.add(r.glsl(o=o||i(["\n      float evaluateAmbientOcclusion() {\n        return 1.0 - texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n      }\n\n      float evaluateAmbientOcclusionInverse() {\n        float ssao = texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n        return viewportPixelSz.z < 0.0 ? 1.0 : ssao;\n      }\n    "],["\n      float evaluateAmbientOcclusion() {\n        return 1.0 - texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n      }\n\n      float evaluateAmbientOcclusionInverse() {\n        float ssao = texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n        return viewportPixelSz.z < 0.0 ? 1.0 : ssao;\n      }\n    "])))):n.code.add(r.glsl(a=a||i(["\n      float evaluateAmbientOcclusion() { return 0.0; } // no occlusion\n      float evaluateAmbientOcclusionInverse() { return 1.0; }\n    "],["\n      float evaluateAmbientOcclusion() { return 0.0; } // no occlusion\n      float evaluateAmbientOcclusionInverse() { return 1.0; }\n    "])))}}.apply(null,i))||(e.exports=r)},1978:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.HighlightData=function(e){e.fragment.code.add(i.glsl(r=r||n(["\n    vec4 highlightData(vec4 fragCoord, sampler2D depthTex, vec4 viewportPixelSize) {\n      float sceneDepth = texture2D(depthTex, (fragCoord.xy - viewportPixelSize.xy) * viewportPixelSize.zw).r;\n      if (fragCoord.z > sceneDepth + 5e-7) {\n        return vec4(1.0, 1.0, 0.0, 1.0);\n      }\n      else {\n        return vec4(1.0, 0.0, 1.0, 1.0);\n      }\n    }\n  "],["\n    vec4 highlightData(vec4 fragCoord, sampler2D depthTex, vec4 viewportPixelSize) {\n      float sceneDepth = texture2D(depthTex, (fragCoord.xy - viewportPixelSize.xy) * viewportPixelSize.zw).r;\n      if (fragCoord.z > sceneDepth + 5e-7) {\n        return vec4(1.0, 1.0, 0.0, 1.0);\n      }\n      else {\n        return vec4(1.0, 0.0, 1.0, 1.0);\n      }\n    }\n  "])))}}.apply(null,i))||(e.exports=r)},1979:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(12),n(214),n(1654),n(484),n(1633),n(1669),n(1708),n(118),n(1684),n(150),n(1660),n(1661),n(1650),n(1906),n(1907),n(1852)],void 0===(r=function(e,t,a,n,i,u,r,o,s,d,l,p,c,f,h,v,m,g){function y(e,t){return a.isNone(e)||null==e.layerUid?null:a.isSome(t.graphicsView)&&e.layerUid===t.graphicsView.mockLayerId?t.graphics:t.map.findLayerByUid(e.layerUid)}function b(e,t){if(a.isNone(e))return null;var n=y(e,t);if(a.isNone(n))return null;if(n===t.graphics)return a.isSome(t.graphicsView)?a.expect(t.graphicsView.getGraphicFromGraphicUid(e.graphicUid)):null;var i,r,o=t.allLayerViews.find(function(e){return e.layer===n});return o?(r=e,!(i=o)||i.suspended?null:"getGraphicFromIntersectorMetadata"in i&&r?i.getGraphicFromIntersectorMetadata(r):"getGraphicFromGraphicUid"in i&&null!=r.graphicUid?i.getGraphicFromGraphicUid(r.graphicUid):null):null}Object.defineProperty(t,"__esModule",{value:!0}),t.sliceFilterPredicate=function(i){return function(e,t,n){return d.vec3.lerp(V,e,t,n),!v.extrusionContainsPoint(i,V)}};function _(){this.selectionMode=!1,this.hud=!0,this.selectOpaqueTerrainOnly=!0,this.invisibleTerrain=!1,this.backfacesTerrain=!0,this.storeTerrainResults=!0,this.store=2}t.IntersectorOptions=_;var x=(S.prototype.invalidateLazyTransforms=function(){this._transformInverse.invalidate(),this._transformInverseTranspose.invalidate(),this._transformTranspose.invalidate(),this._transformInverseRotation.invalidate()},Object.defineProperty(S.prototype,"transform",{get:function(){return this._transform},enumerable:!0,configurable:!0}),Object.defineProperty(S.prototype,"inverse",{get:function(){return this._transformInverse.value},enumerable:!0,configurable:!0}),Object.defineProperty(S.prototype,"inverseTranspose",{get:function(){return this._transformInverseTranspose.value},enumerable:!0,configurable:!0}),Object.defineProperty(S.prototype,"inverseRotation",{get:function(){return this._transformInverseRotation.value},enumerable:!0,configurable:!0}),Object.defineProperty(S.prototype,"transpose",{get:function(){return this._transformTranspose.value},enumerable:!0,configurable:!0}),S.prototype.setTransformMatrix=function(e){u.mat4.copy(this._transform,e)},S.prototype.multiplyTransform=function(e){u.mat4.multiply(this._transform,this._transform,e)},S.prototype.set=function(e){u.mat4.copy(this._transform,e),this.invalidateLazyTransforms()},S.prototype.setAndInvalidateLazyTransforms=function(e,t){this.setTransformMatrix(e),this.multiplyTransform(t),this.invalidateLazyTransforms()},S);function S(){this._transform=r.mat4f64.create(),this._transformInverse=new P({value:this._transform},u.mat4.invert,r.mat4f64.create),this._transformInverseTranspose=new P(this._transformInverse,u.mat4.transpose,r.mat4f64.create),this._transformTranspose=new P({value:this._transform},u.mat4.transpose,r.mat4f64.create),this._transformInverseRotation=new P({value:this._transform},n.mat3.normalFromMat4Legacy,i.mat3f64.create)}t.IntersectorTransform=x;var P=(C.prototype.invalidate=function(){this.dirty=!0},Object.defineProperty(C.prototype,"value",{get:function(){return this.dirty&&(this.update(this.transform,this.original.value),this.dirty=!1),this.transform},enumerable:!0,configurable:!0}),C),w=(A.prototype.init=function(e){this.min.init(e),this.max.init(e),this.hud.init(e),this.terrain.init(e),this.all=[]},A);function A(){this.min=new O,this.max=new O,this.hud=new O,this.terrain=new O}function C(e,t,n){this.original=e,this.update=t,this.dirty=!0,this.transform=n()}t.IntersectorResults=w;var O=(Object.defineProperty(M.prototype,"ray",{get:function(){return this._ray},enumerable:!0,configurable:!0}),Object.defineProperty(M.prototype,"hasIntersectionPoint",{get:function(){return null!=this.dist},enumerable:!0,configurable:!0}),Object.defineProperty(M.prototype,"distanceInRenderSpace",{get:function(){if(null!=this.dist)return d.vec3.scale(N,this.ray.direction,this.dist),d.vec3.length(N)},enumerable:!0,configurable:!0}),M.prototype.getIntersectionPoint=function(e){return!!this.hasIntersectionPoint&&(d.vec3.scale(N,this.ray.direction,this.dist),d.vec3.add(e,this.ray.origin,N),!0)},M.prototype.getTransformedNormal=function(e){return d.vec3.copy(j,this.normal),j[3]=0,c.vec4.transformMat4(j,j,this.transformation),d.vec3.copy(e,j),d.vec3.normalize(e,e),e},M.prototype.set=function(e,t,n,i,r,o,a,s,l,c){e instanceof g&&(e={type:"stage",obj:e}),this.dist=n,d.vec3.copy(this.normal,i),u.mat4.copy(this.transformation,r),this.target=e,this.name=t,this.drapedLayerOrder=o,this.center=a?p.vec3f64.clone(a):null,this.geometryId=s,this.triangleNr=l,this.drapedLayerGraphicOrder=c},M.prototype.copyFrom=function(e){h.ray.copy(e._ray,this._ray),this.dist=e.dist,this.target=e.target,this.name=e.name,this.drapedLayerOrder=e.drapedLayerOrder,this.center=e.center?p.vec3f64.clone(e.center):null,this.geometryId=e.geometryId,this.triangleNr=e.triangleNr,this.intersector=e.intersector,this.drapedLayerGraphicOrder=e.drapedLayerGraphicOrder,d.vec3.copy(this.normal,e.normal),u.mat4.copy(this.transformation,e.transformation)},M.prototype.init=function(e){this.dist=void 0,this.target=void 0,this.name=void 0,this.drapedLayerOrder=void 0,this.drapedLayerGraphicOrder=void 0,this.center=null,this.geometryId=null,this.triangleNr=null,this.intersector="Stage",e?h.ray.copy(e,this._ray):this._ray=h.ray.create()},M.prototype.toOwner=function(e){if(!this.target)return null;switch(this.target.type){case"stage":return y(this.target.obj.getMetadata(),e);case"external":switch(this.intersector){case"PointRenderer":return t=this.target,n=e,null!=(i=t.metadata.layerUid)?n.map.findLayerByUid(i):null;case"I3S":case"LodRenderer":case"DrapedRenderer":return y(this.target.metadata,e);case"TerrainRenderer":return e.map&&e.map.ground}}var t,n,i;return null},M.prototype.toGraphic=function(e){if(!this.target)return null;switch(this.target.type){case"stage":return b(this.target.obj.getMetadata(),e);case"external":switch(this.intersector){case"PointRenderer":return this.target.metadata.createGraphic();case"I3S":case"LodRenderer":case"DrapedRenderer":return b(this.target.metadata,e)}}return null},M);function M(e){this.normal=p.vec3f64.create(),this.transformation=r.mat4f64.create(),this._ray=h.ray.create(),this.init(e)}t.IntersectorResult=O;var D=(T.prototype.applyToVertex=function(e,t,n){var i=e+this.localOrigin[0],r=t+this.localOrigin[1],o=n+this.localOrigin[2],a=this.offset/Math.sqrt(i*i+r*r+o*o);return this.tmpVertex[0]=e+i*a,this.tmpVertex[1]=t+r*a,this.tmpVertex[2]=n+o*a,this.tmpVertex},T.prototype.applyToAABB=function(e){var t=e[0]+this.localOrigin[0],n=e[1]+this.localOrigin[1],i=e[2]+this.localOrigin[2],r=e[3]+this.localOrigin[0],o=e[4]+this.localOrigin[1],a=e[5]+this.localOrigin[2],s=this.offset/Math.sqrt(t*t+n*n+i*i);e[0]+=t*s,e[1]+=n*s,e[2]+=i*s;var l=this.offset/Math.sqrt(r*r+o*o+a*a);return e[3]+=r*l,e[4]+=o*l,e[5]+=a*l,e},T);function T(e){this.offset=e,this.tmpVertex=p.vec3f64.create()}t.TerrainVerticalOffsetGlobalViewingMode=D;var R=(Object.defineProperty(I.prototype,"localOrigin",{set:function(e){this.componentLocalOriginLength=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2])},enumerable:!0,configurable:!0}),I.prototype.applyToVertex=function(e,t,n){var i=e,r=t,o=n+this.componentLocalOriginLength,a=this.offset/Math.sqrt(i*i+r*r+o*o);return this.tmpVertex[0]=e+i*a,this.tmpVertex[1]=t+r*a,this.tmpVertex[2]=n+o*a,this.tmpVertex},I.prototype.applyToAABB=function(e){var t=e[0],n=e[1],i=e[2]+this.componentLocalOriginLength,r=e[3],o=e[4],a=e[5]+this.componentLocalOriginLength,s=this.offset/Math.sqrt(t*t+n*n+i*i);e[0]+=t*s,e[1]+=n*s,e[2]+=i*s;var l=this.offset/Math.sqrt(r*r+o*o+a*a);return e[3]+=r*l,e[4]+=o*l,e[5]+=a*l,e},I.prototype.applyToMbs=function(e){var t=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]),n=this.offset/t;return this.mbs[0]=e[0]+e[0]*n,this.mbs[1]=e[1]+e[1]*n,this.mbs[2]=e[2]+e[2]*n,this.mbs[3]=e[3]+e[3]*this.offset/t,this.mbs},I.prototype.applyToObb=function(e){var t=e.center,n=this.offset/Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);this.obb.center[0]=t[0]+t[0]*n,this.obb.center[1]=t[1]+t[1]*n,this.obb.center[2]=t[2]+t[2]*n,d.vec3.transformQuat(this.obb.halfSize,e.halfSize,e.quaternion),d.vec3.add(this.obb.halfSize,this.obb.halfSize,e.center);var i=this.offset/Math.sqrt(this.obb.halfSize[0]*this.obb.halfSize[0]+this.obb.halfSize[1]*this.obb.halfSize[1]+this.obb.halfSize[2]*this.obb.halfSize[2]);return this.obb.halfSize[0]+=this.obb.halfSize[0]*i,this.obb.halfSize[1]+=this.obb.halfSize[1]*i,this.obb.halfSize[2]+=this.obb.halfSize[2]*i,d.vec3.subtract(this.obb.halfSize,this.obb.halfSize,e.center),o.quat.conjugate(F,e.quaternion),d.vec3.transformQuat(this.obb.halfSize,this.obb.halfSize,F),this.obb.halfSize[0]*=this.obb.halfSize[0]<0?-1:1,this.obb.halfSize[1]*=this.obb.halfSize[1]<0?-1:1,this.obb.halfSize[2]*=this.obb.halfSize[2]<0?-1:1,this.obb.quaternion=e.quaternion,this.obb},I);function I(e){this.offset=e,this.componentLocalOriginLength=0,this.tmpVertex=p.vec3f64.create(),this.mbs=f.vec4f64.create(),this.obb={center:p.vec3f64.create(),halfSize:l.vec3f32.create(),quaternion:null}}t.I3SVerticalOffsetGlobalViewingMode=R;var z=(L.prototype.applyToVertex=function(e,t,n){var i=this.objectTransform.transform,r=i[0]*e+i[4]*t+i[8]*n+i[12],o=i[1]*e+i[5]*t+i[9]*n+i[13],a=i[2]*e+i[6]*t+i[10]*n+i[14],s=this.offset/Math.sqrt(r*r+o*o+a*a);r+=r*s,o+=o*s,a+=a*s;var l=this.objectTransform.inverse;return this.tmpVertex[0]=l[0]*r+l[4]*o+l[8]*a+l[12],this.tmpVertex[1]=l[1]*r+l[5]*o+l[9]*a+l[13],this.tmpVertex[2]=l[2]*r+l[6]*o+l[10]*a+l[14],this.tmpVertex},L.prototype.applyToMinMax=function(e,t){var n=this.offset/Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);e[0]+=e[0]*n,e[1]+=e[1]*n,e[2]+=e[2]*n;var i=this.offset/Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]+=t[0]*i,t[1]+=t[1]*i,t[2]+=t[2]*i},L.prototype.applyToAABB=function(e){var t=this.offset/Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);e[0]+=e[0]*t,e[1]+=e[1]*t,e[2]+=e[2]*t;var n=this.offset/Math.sqrt(e[3]*e[3]+e[4]*e[4]+e[5]*e[5]);return e[3]+=e[3]*n,e[4]+=e[4]*n,e[5]+=e[5]*n,e},L.prototype.applyToBoundingSphere=function(e,t){var n=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]),i=this.offset/n;return this.sphere.center[0]=t[0]+t[0]*i,this.sphere.center[1]=t[1]+t[1]*i,this.sphere.center[2]=t[2]+t[2]*i,this.sphere.radius=e+e*this.offset/n,this.sphere},L);function L(e){this.offset=e,this.sphere=m.create(),this.tmpVertex=p.vec3f64.create()}t.Object3DVerticalOffsetGlobalViewingMode=z;function E(e){this.terrain=new D(e),this.i3s=new R(e),this.object3D=new z(e)}t.VerticalOffsetForGlobalViewingMode=E,t.TERRAIN_ID="terrain";var V=p.vec3f64.create(),N=p.vec3f64.create(),j=f.vec4f64.create(),F=s.quatf64.create()}.apply(null,i))||(e.exports=r)},1980:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1727),n(1642),n(1853)],void 0===(r=function(e,t,n,i,r){Object.defineProperty(t,"__esModule",{value:!0}),t.PositionLayout=n.newLayout().vec3f(i.VertexAttrConstants.POSITION),t.PositionUVLayout=n.newLayout().vec3f(i.VertexAttrConstants.POSITION).vec2f(i.VertexAttrConstants.UV0),t.PositionColorLayout=n.newLayout().vec3f(i.VertexAttrConstants.POSITION).vec4u8(i.VertexAttrConstants.COLOR);var o=(a.prototype.allocate=function(e){return this.vertexBufferLayout.createBuffer(e)},a.prototype.elementCount=function(e){return e.indices[i.VertexAttrConstants.POSITION].length},a.prototype.write=function(e,t,n,i){r.writeDefaultAttributes(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,n,i)},a);function a(e){this.vertexBufferLayout=e}t.DefaultBufferWriter=o}.apply(null,i))||(e.exports=r)},1981:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,r,o){var a,s,l,c;Object.defineProperty(t,"__esModule",{value:!0}),t.LineStipple=function(e,t){var n,i;e.defines.addFloat("STIPPLE_ALPHA_COLOR_DISCARD",.001),e.defines.addFloat("STIPPLE_ALPHA_HIGHLIGHT_DISCARD",.5),t.stippleEnabled?(i=t,(n=e).vertex.uniforms.add("stipplePatternPixelSizeInv","float"),i.stippleUVMaxEnabled&&n.varyings.add("stipplePatternUvMax","float"),n.varyings.add("stipplePatternUv","float"),n.fragment.uniforms.add("stipplePatternTexture","sampler2D"),i.stippleOffColorEnabled&&n.fragment.uniforms.add("stippleOffColor","vec4"),n.fragment.code.add(o.glsl(a=a||r(["\n  float getStippleAlpha() {\n    float stipplePatternUvClamped = stipplePatternUv * gl_FragCoord.w;\n    ","\n\n    return texture2D(stipplePatternTexture, vec2(mod(stipplePatternUvClamped, 1.0), 0.5)).a;\n  }"],["\n  float getStippleAlpha() {\n    float stipplePatternUvClamped = stipplePatternUv * gl_FragCoord.w;\n    ","\n\n    return texture2D(stipplePatternTexture, vec2(mod(stipplePatternUvClamped, 1.0), 0.5)).a;\n  }"]),i.stippleUVMaxEnabled?"stipplePatternUvClamped = clamp(stipplePatternUvClamped, 0.0, stipplePatternUvMax);":"")),i.stippleOffColorEnabled?n.fragment.code.add(o.glsl(s=s||r(["\n    #define discardByStippleAlpha(stippleAlpha, threshold) {}\n    #define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)\n    "],["\n    #define discardByStippleAlpha(stippleAlpha, threshold) {}\n    #define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)\n    "]))):n.fragment.code.add(o.glsl(l=l||r(["\n    #define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }\n    #define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)\n    "],["\n    #define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }\n    #define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)\n    "])))):e.fragment.code.add(o.glsl(c=c||r(["\n  float getStippleAlpha() { return 1.0; }\n\n  #define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}\n  #define blendStipple(color, _stippleAlpha_) color\n  "],["\n  float getStippleAlpha() { return 1.0; }\n\n  #define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}\n  #define blendStipple(color, _stippleAlpha_) color\n  "])))}}.apply(null,i))||(e.exports=r)},1982:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(11),n(0),n(5),n(12),n(12),n(1679),n(1693),n(1857),n(1858),n(1741),n(1742),n(1743),n(2746),n(314),n(502)],void 0===(r=function(e,r,t,n,i,a,s,o,l,c,u,d,p,f,h,v,m){Object.defineProperty(r,"__esModule",{value:!0}),r.RibbonVertexAttributeConstants={POSITION:"position",SUBDIVISIONFACTOR:"subdivisionFactor",UV0:"uv0",AUXPOS1:"auxpos1",AUXPOS2:"auxpos2",SUBDIVISIONS:"subdivisions",COLOR:"color",COLORFEATUREATTRIBUTE:"colorFeatureAttribute",SIZE:"size",SIZEFEATUREATTRIBUTE:"sizeFeatureAttribute",OPACITYFEATUREATTRIBUTE:"opacityFeatureAttribute"},r.ribbonVertexAttributeLocations={position:0,subdivisionFactor:1,uv0:2,auxpos1:3,auxpos2:4,size:6,sizeFeatureAttribute:6,color:5,colorFeatureAttribute:5,opacityFeatureAttribute:7};var g,y=(g=p.ShaderTechnique,t(b,g),b.prototype.initializeProgram=function(e){var t=b.shader.get(),n=this.configuration,i=t.build({output:n.output,slicePlaneEnabled:n.slicePlaneEnabled,sliceHighlightDisabled:n.sliceHighlightDisabled,stippleEnabled:n.stippleEnabled,stippleOffColorEnabled:n.stippleOffColorEnabled,stippleUVMaxEnabled:n.stippleIntegerRepeatsEnabled,stippleIntegerRepeatsEnabled:n.stippleIntegerRepeatsEnabled,roundCaps:n.roundCaps,roundJoins:n.roundJoins,vvColor:n.vvColor,vvSize:n.vvSize,vvOpacity:n.vvOpacity});return new v(e.rctx,i.generateSource("vertex"),i.generateSource("fragment"),r.ribbonVertexAttributeLocations)},b.prototype.dispose=function(){g.prototype.dispose.call(this),this.stippleTextureRepository.release(this.stipplePattern),this.stipplePattern=null,this.stippleTextureBind=null},b.prototype.bindPass=function(e,t,n){if(4===this.configuration.output&&c.OutputHighlight.bindOutputHighlight(e,this.program,n),this.program.setUniform1f("symbolLineWidth",t.width),this.program.setUniform4fv("symbolColor",t.color),this.program.setUniform1f("miterLimit","miter"!==t.join?0:t.miterLimit),this.program.setUniform1f("nearPlane",n.nearFar[0]),this.program.setUniform1f("pixelRatio",n.pixelRatio),this.program.setUniform2fv("screenSize",[n.viewport[2],n.viewport[3]]),u.VisualVariables.bindUniformsWithOpacity(this.program,t),this.stipplePattern!==t.stipplePattern){var i=t.stipplePattern;this.stippleTextureBind=this.stippleTextureRepository.swap(this.stipplePattern,i),this.stipplePattern=i}if(this.configuration.stippleEnabled){var r=s.isSome(this.stippleTextureBind)?this.stippleTextureBind(e,0)*n.pixelRatio:1;if(this.program.setUniform1i("stipplePatternTexture",0),this.program.setUniform1f("stipplePatternPixelSizeInv",1/r),this.configuration.stippleOffColorEnabled){var o=a.expect(t.stippleOffColor);this.program.setUniform4f("stippleOffColor",o[0],o[1],o[2],3<o.length?o[3]:1)}}},b.prototype.bindDraw=function(e){l.Transform.bindUniforms(this.program,e),o.Slice.bindUniformsWithOrigin(this.program,this.configuration,e)},b.prototype.bindInstance=function(e){this.program.setUniformMatrix4fv("model",e.transformation)},b.prototype.initializePipeline=function(){var e=this.configuration;return 0===e.output?m.makePipelineState({blending:m.separateBlendingParams(770,1,771,771),polygonOffset:e.polygonOffset&&x,depthTest:{func:513},depthWrite:!e.transparent&&e.writeDepth&&m.defaultDepthWriteParams,colorWrite:m.defaultColorWriteParams}):m.makePipelineState({polygonOffset:e.polygonOffset&&x,depthTest:{func:513},depthWrite:!e.transparent&&e.writeDepth&&m.defaultDepthWriteParams,colorWrite:m.defaultColorWriteParams})},b.prototype.bindPipelineState=function(e){e.setPipelineState(this.pipeline)},b.shader=new d.ReloadableShaderModule(h,"./RibbonLine.glsl",e),b);function b(e,t){var n=g.call(this,e,t)||this;return n.stipplePattern=null,n.stippleTextureBind=null,n.stippleTextureRepository=e.stippleTextureRepository,n}r.RibbonLineTechnique=y;var _,x={factor:0,units:-4},S=(_=f.ShaderTechniqueConfiguration,t(P,_),n([f.parameter({count:6})],P.prototype,"output",void 0),n([f.parameter()],P.prototype,"slicePlaneEnabled",void 0),n([f.parameter()],P.prototype,"sliceHighlightDisabled",void 0),n([f.parameter()],P.prototype,"vertexColors",void 0),n([f.parameter()],P.prototype,"transparent",void 0),n([f.parameter()],P.prototype,"polygonOffset",void 0),n([f.parameter()],P.prototype,"writeDepth",void 0),n([f.parameter()],P.prototype,"stippleEnabled",void 0),n([f.parameter()],P.prototype,"stippleOffColorEnabled",void 0),n([f.parameter()],P.prototype,"stippleIntegerRepeatsEnabled",void 0),n([f.parameter()],P.prototype,"roundCaps",void 0),n([f.parameter()],P.prototype,"roundJoins",void 0),n([f.parameter()],P.prototype,"vvSize",void 0),n([f.parameter()],P.prototype,"vvColor",void 0),n([f.parameter()],P.prototype,"vvOpacity",void 0),P);function P(){var e=null!==_&&_.apply(this,arguments)||this;return e.output=0,e.slicePlaneEnabled=!1,e.sliceHighlightDisabled=!1,e.vertexColors=!1,e.transparent=!1,e.polygonOffset=!1,e.writeDepth=!1,e.stippleEnabled=!1,e.stippleOffColorEnabled=!1,e.stippleIntegerRepeatsEnabled=!1,e.roundCaps=!1,e.roundJoins=!1,e.vvSize=!1,e.vvColor=!1,e.vvOpacity=!1,e}r.RibbonLineTechniqueConfiguration=S}.apply(null,i))||(e.exports=r)},1983:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(0),n(11),n(12),n(48),n(127),n(118),n(150),n(1660),n(1661),n(305),n(55)],void 0===(r=function(e,t,n,i,r,o,a,s,l,c,u,v,d){function m(){return new p}Object.defineProperty(t,"__esModule",{value:!0});var p=(f.prototype.makeVertex=function(e,t,n){void 0===t&&(t=null),void 0===n&&(n=null);var i={pos:e,unnormalizedPos:e,left:t,right:n,type:"vertex",component:this};return this.vertices.push(i),i},f.prototype.makeEdge=function(e,t){var n={v0:e,v1:t,type:"edge",component:this};return e.right=n,t.left=n,this.edges.push(n),n},f.prototype.removeVertex=function(e){this.vertices.splice(this.vertices.indexOf(e),1),e.left&&this.removeEdge(e.left),e.right&&this.removeEdge(e.right)},f.prototype.removeEdge=function(e){this.edges.splice(this.edges.indexOf(e),1),e.v0.right=null,e.v1.left=null},f);function f(){this.vertices=[],this.edges=[]}t.Component=p;var h=(g.prototype.createNew=function(){return a.vec2f64.create()},g.prototype.fromArray=function(e){return a.vec2f64.fromValues(e[0],e[1])},g.prototype.toArray=function(e){return[e[0],e[1]]},g.prototype.toPoint=function(e,t){return t.x=e[0],t.y=e[1],t.hasZ=!1,t.hasM=!1,t},g.prototype.lerp=function(e,t,n,i){return o.vec2.lerp(i,e,t,n)},g.prototype.addDelta=function(e,t,n){e[0]+=t,e[1]+=n},g);function g(){}t.CoordinateHelper2D=h;var y=(b.prototype.createNew=function(){return l.vec3f64.create()},b.prototype.fromArray=function(e){return l.vec3f64.fromValues(e[0],e[1],e[2]||0)},b.prototype.toArray=function(e){return[e[0],e[1],e[2]]},b.prototype.toPoint=function(e,t){return t.x=e[0],t.y=e[1],0===this.ztype?(t.z=e[2],t.hasZ=!0,t.hasM=!1):(t.m=e[2],t.hasZ=!1,t.hasM=!0),t},b.prototype.lerp=function(e,t,n,i){return s.vec3.lerp(i,e,t,n)},b.prototype.addDelta=function(e,t,n,i){e[0]+=t,e[1]+=n,0===this.ztype&&(e[2]+=i)},b);function b(e){this.ztype=e}t.CoordinateHelper3D=y;var _=(x.prototype.createNew=function(){return u.vec4f64.create()},x.prototype.fromArray=function(e){return u.vec4f64.fromValues(e[0],e[1],e[2]||0,e[3]||0)},x.prototype.toArray=function(e){return[e[0],e[1],e[2],e[3]]},x.prototype.toPoint=function(e,t){return t.x=e[0],t.y=e[1],t.z=e[2],t.m=e[3],t.hasZ=!0,t.hasM=!0,t},x.prototype.lerp=function(e,t,n,i){return c.vec4.lerp(i,e,t,n)},x.prototype.addDelta=function(e,t,n,i){e[0]+=t,e[1]+=n,e[2]+=i},x);function x(){}t.CoordinateHelper4D=_;var S=(P.prototype.addDelta=function(e,t,n,i){this.coordinateHelper.addDelta(e.pos,t,n,i)},P.prototype.getVertexPositionAsPoint=function(e,t){return this.coordinateHelper.toPoint(e.pos,t),t.spatialReference=this.geometry.spatialReference,t},P.prototype.getEdgePosition=function(e,t,n){return void 0===n&&(n=this.coordinateHelper.createNew()),this.coordinateHelper.lerp(e.v0.unnormalizedPos,e.v1.unnormalizedPos,t,n)},P.prototype.getEdgePositionAsPoint=function(e,t,n){var i=this.getEdgePosition(e,t,this._tmpMapPoint);return this.coordinateHelper.toPoint(i,n),n.spatialReference=this.geometry.spatialReference,n},P.prototype.canRemoveVertex=function(e){return!0},P.prototype.removeVertex=function(e){var t=e.component,n=e.left,i=e.right;return t.removeVertex(e),n&&i?t.makeEdge(n.v0,i.v1):null},P.prototype.splitEdge=function(e,t){var n=e.component,i=n.makeVertex(this.getEdgePosition(e,t)),r=e.v0,o=e.v1;return n.removeEdge(e),n.makeEdge(r,i),n.makeEdge(i,o),i},P);function P(e,t,n){this.geometry=e,this.doUnnormalization=t,this.coordinateHelper=n,this.components=[];var i=d.getInfo(this.geometry.spatialReference);this._tmpMapPoint=n.createNew(),i?(this._spanMin=i.valid[0],this._spanMax=i.valid[1],this._span=this._spanMax-this._spanMin):this.doUnnormalization=!1}t.ReshapeHelper=S;var w,A,C=(i(D,A=S),D.prototype.canRemoveVertex=function(e){return 3<e.component.vertices.length},D.prototype.commit=function(){var r=this,o=[],a=this.coordinateHelper.toArray;return this.components.forEach(function(e){var t=[];r.doUnnormalization&&v.computeUnnormalizedVertexPositionsOnDateLineCrossing(e.vertices,r._spanMin,r._spanMax,r._span);for(var n=e.vertices[0],i=n;t.push(a(n.unnormalizedPos)),(n=n.right.v1)&&n!==i;);t.push(a(e.vertices[0].unnormalizedPos)),o.push(t)}),this.geometry.rings=o,this.geometry},D),O=(i(M,w=S),M.prototype.canRemoveVertex=function(e){return 2<e.component.vertices.length},M.prototype.commit=function(){var r=this,o=[],a=this.coordinateHelper.toArray;return this.components.forEach(function(e){var t=[];r.doUnnormalization&&v.computeUnnormalizedVertexPositionsOnDateLineCrossing(e.vertices,r._spanMin,r._spanMax,r._span);for(var n=e.vertices[0],i=n;t.push(a(n.unnormalizedPos)),(n=n.right?n.right.v1:null)&&n!==i;);o.push(t)}),this.geometry.paths=o,this.geometry},M);function M(e,t,n){var i=w.call(this,e,t,n)||this;i.geometry=e;for(var r=i.geometry.paths,o=0;o<r.length;++o){for(var a=r[o],s=m(),l=a.length,c=0;c<l;++c){var u=n.fromArray(a[c]);s.makeVertex(u)}for(var d=s.vertices.length-1,p=0;p<d;++p){var f=s.vertices[p],h=s.vertices[p+1];s.makeEdge(f,h)}i.doUnnormalization&&v.computeUnnormalizedVertexPositionsOnDateLineCrossing(s.vertices,i._spanMin,i._spanMax,i._span),i.components.push(s)}return i}function D(e,t,n){var i=A.call(this,e,t,n)||this;i.geometry=e;for(var r=i.geometry.rings,o=0;o<r.length;++o){for(var a=r[o],s=m(),l=a.length-1,c=0;c<l;++c){var u=n.fromArray(a[c]);s.makeVertex(u)}for(var d=s.vertices.length-1,p=0;p<d;++p){var f=s.vertices[p],h=s.vertices[p+1];s.makeEdge(f,h)}s.makeEdge(s.vertices[s.vertices.length-1],s.vertices[0]),i.doUnnormalization&&v.computeUnnormalizedVertexPositionsOnDateLineCrossing(s.vertices,i._spanMin,i._spanMax,i._span),i.components.push(s)}return i}t.isReshapeGeometry=function(e){return r.isSome(e)&&("polygon"===e.type||"polyline"===e.type)},t.createReshapeHelper=function(e,t){if(r.isNone(e))return null;var n,i=(n=e).hasZ&&n.hasM?new _:n.hasM?new y(1):n.hasZ?new y(0):new h;return new("polygon"===e.type?C:O)(e,t,i)}}.apply(null,i))||(e.exports=r)},2691:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(0),n(1),n(5),n(18),n(54),n(23),n(12),n(16),n(2),n(1700),n(1677),n(1780),n(1873),n(1860),n(1783),n(1745)],void 0===(r=function(e,t,n,i,a,r,o,s,l,c,u,d,p,f,h,v,m,g){Object.defineProperty(t,"__esModule",{value:!0});var y=function(e){this.allGraphics=e,this.type="graphic-move-start"};t.GraphicMoveStartEvent=y;var b=function(e,t,n,i){this.dx=e,this.dy=t,this.dz=n,this.allGraphics=i,this.type="graphic-move"};t.GraphicMoveEvent=b;var _=function(e){this.allGraphics=e,this.type="graphic-move-stop"};t.GraphicMoveStopEvent=_;var x,S=(x=u.declared(o.EventedMixin(v.InteractiveToolBase)),i(P,x),P.prototype.initialize=function(){var e=this;this._handles.add(this.graphics.on("change",function(){e._refreshManipulators()})),this._refreshManipulators()},P.prototype.destroy=function(){this._handles.destroy(),this._handles=null,this.graphics.removeAll(),this._set("view",null)},P.prototype.reset=function(){},P.prototype._createDragAction=function(t){var n=this,i=m.createGraphicDragActionMany(t);return function(e){switch(e.action){case"start":n.emit("graphic-move-start",new y(t))}switch(i(e),e.action){case"start":case"update":("update"===e.action||e.deltaX||e.deltaY||e.deltaZ)&&n.emit("graphic-move",new b(e.deltaX,e.deltaY,e.deltaZ,t));break;case"end":n.emit("graphic-move-stop",new _(t))}}},P.prototype._refreshManipulators=function(){var i=this;this._handles.remove("graphics"),this.manipulators.removeAll();for(var e=this.graphics.toArray(),r=[],o=this,t=0,n=e;t<n.length;t++)!function(t){if(0===h.isSupportedGraphic(t)){var e=f.createGraphicMoveXYManipulator(o.view,t);o._handles.add(e.events.on("immediate-click",function(e){i.emit("immediate-click",a({},e,{graphic:t})),e.stopPropagation()}),"graphics"),o.manipulators.add(e),r.push(e);var n=f.createGraphicMoveZManipulator({view:o.view,graphic:t});l.isNone(n)||(o._handles.add([c.init(t,"geometry",function(){return p.placeManipulatorAtGraphic(n,t)}),c.init(t,["visible","layer.visible"],function(){return n.visible=t.visible&&t.layer.visible})],"graphics"),o.manipulators.add(n),r.push(n))}}(n[t]);g.createManipulatorDragHandlerOneOf(r,function(e,t){return e instanceof d.Manipulator3D?f.createGraphicMoveZScreenDragToMap(i.view,e):f.createGraphicMoveXYScreenDragToMap(i.view,e,t)},this._createDragAction(e))},n([u.property({constructOnly:!0,nonNullable:!0})],P.prototype,"view",void 0),n([u.property({readOnly:!0})],P.prototype,"graphics",void 0),n([u.property({readOnly:!0})],P.prototype,"type",void 0),n([u.subclass("esri.views.3d.interactive.editingTools.graphicMove3D.GraphicMove3DTool")],P));function P(e){var t=x.call(this,e)||this;return t.graphics=new r,t.type="move-3d",t._handles=new s,t}t.GraphicMove3DTool=S}.apply(null,i))||(e.exports=r)},2692:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(33),n(15),n(484),n(1633),n(118),n(150),n(1660),n(1661),n(1650),n(500),n(1760),n(1642)],void 0===(r=function(e,t,r,i,o,a,s,l,c,u,d,p,n,f){function h(e,t){var n=t[0]-e[0],i=t[1]-e[1],r=t[2]-e[2],o=t[3]-e[3];return n*n+i*i+r*r+o*o}function v(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function m(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]}Object.defineProperty(t,"__esModule",{value:!0});var g=(Object.defineProperty(y.prototype,"eye",{get:function(){return this._eye},set:function(e){this._compareAndSetView(e,this._eye)},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"center",{get:function(){return this._center},set:function(e){this._compareAndSetView(e,this._center)},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"ray",{get:function(){return this._ray.origin=this.eye,this._ray.direction||(this._ray.direction=l.vec3f64.create()),s.vec3.subtract(this._ray.direction,this.center,this.eye),this._ray},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"up",{get:function(){return this._up},set:function(e){this._compareAndSetView(e,this._up)},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"viewMatrix",{get:function(){return this._ensureViewClean(),this._viewMatrix},set:function(e){o.mat4.copy(this._viewMatrix,e),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"viewForward",{get:function(){return this._ensureViewClean(),this._viewForward},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"viewUp",{get:function(){return this._ensureViewClean(),this._viewUp},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"viewRight",{get:function(){return this._ensureViewClean(),this._viewRight},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"near",{get:function(){return this._near},set:function(e){this._near!==e&&(this._near=e,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"far",{get:function(){return this._far},set:function(e){this._far!==e&&(this._far=e,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"viewport",{get:function(){return this._viewport},set:function(e){this.x=e[0],this.y=e[1],this.width=e[2],this.height=e[3]},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"x",{get:function(){return this._viewport[0]},set:function(e){e+=this._padding[3],this._viewport[0]!==e&&(this._viewport[0]=e,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"y",{get:function(){return this._viewport[1]},set:function(e){e+=this._padding[2],this._viewport[1]!==e&&(this._viewport[1]=e,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"width",{get:function(){return this._viewport[2]},set:function(e){this._viewport[2]!==e&&(this._viewport[2]=e,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"height",{get:function(){return this._viewport[3]},set:function(e){this._viewport[3]!==e&&(this._viewport[3]=e,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"fullWidth",{get:function(){return this._viewport[2]+this._padding[1]+this._padding[3]},set:function(e){this.width=e-(this._padding[1]+this._padding[3])},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"fullHeight",{get:function(){return this._viewport[3]+this._padding[0]+this._padding[2]},set:function(e){this.height=e-(this._padding[0]+this._padding[2])},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"fullViewport",{get:function(){return this._fullViewport||(this._fullViewport=u.vec4f64.create()),this._fullViewport[0]=this._viewport[0]-this._padding[3],this._fullViewport[1]=this._viewport[1]-this._padding[2],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"aspect",{get:function(){return this.width/this.height},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"padding",{get:function(){return this._padding},set:function(e){this._padding[0]===e[0]&&this._padding[1]===e[1]&&this._padding[2]===e[2]&&this._padding[3]===e[3]||(this._viewport[0]+=e[3]-this._padding[3],this._viewport[1]+=e[2]-this._padding[2],this._viewport[2]-=e[1]+e[3]-(this._padding[1]+this._padding[3]),this._viewport[3]-=e[0]+e[2]-(this._padding[0]+this._padding[2]),c.vec4.copy(this._padding,e),this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"viewProjectionMatrix",{get:function(){return this._viewProjectionDirty&&(o.mat4.multiply(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"projectionMatrix",{get:function(){if(this._projectionDirty){var e=this.width,t=this.height,n=this.near*Math.tan(this.fovY/2),i=n*this.aspect;o.mat4.frustum(this._projectionMatrix,-i*(1+2*this._padding[3]/e),i*(1+2*this._padding[1]/e),-n*(1+2*this._padding[2]/t),n*(1+2*this._padding[0]/t),this.near,this.far),this._projectionDirty=!1}return this._projectionMatrix},set:function(e){o.mat4.copy(this._projectionMatrix,e),this._projectionDirty=!1,this._viewProjectionDirty=!0,this._frustumDirty=!0},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"fov",{get:function(){return this._fov},set:function(e){this._fov=e,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"fovX",{get:function(){return f.fovd2fovx(this._fov,this.width,this.height)},set:function(e){this._fov=f.fovx2fovd(e,this.width,this.height),this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"fovY",{get:function(){return f.fovd2fovy(this._fov,this.width,this.height)},set:function(e){this._fov=f.fovy2fovd(e,this.width,this.height),this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"distance",{get:function(){return s.vec3.distance(this._center,this._eye)},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"frustum",{get:function(){return this._recomputeFrustum(),this._frustum},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"viewInverseTransposeMatrix",{get:function(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&(this._viewInverseTransposeMatrix||(this._viewInverseTransposeMatrix=a.mat4f64.create()),o.mat4.invert(this._viewInverseTransposeMatrix,this.viewMatrix),o.mat4.transpose(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"perRenderPixelRatio",{get:function(){return Math.tan(this.fovX/2)/(this.width/2)},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"perScreenPixelRatio",{get:function(){return this.perRenderPixelRatio*this.pixelRatio},enumerable:!0,configurable:!0}),Object.defineProperty(y.prototype,"aboveGround",{get:function(){return 0<=this.relativeElevation},enumerable:!0,configurable:!0}),y.prototype.copyFrom=function(e){var t=e;return s.vec3.copy(this._eye,t._eye),s.vec3.copy(this._center,t._center),s.vec3.copy(this._up,t._up),c.vec4.copy(this._viewport,t._viewport),c.vec4.copy(this._padding,t._padding),this._near=t._near,this._far=t._far,this._fov=t._fov,this.relativeElevation=e.relativeElevation,this._viewDirty=t._viewDirty,this._viewDirty||(o.mat4.copy(this._viewMatrix,t._viewMatrix),s.vec3.copy(this._viewRight,t._viewRight),s.vec3.copy(this._viewUp,t._viewUp),s.vec3.copy(this._viewForward,t._viewForward)),t._projectionDirty?this._projectionDirty=!0:(o.mat4.copy(this._projectionMatrix,t._projectionMatrix),this._projectionDirty=!1),this._viewProjectionDirty=!0,this._frustumDirty=t._frustumDirty,this._frustumDirty||(d.frustum.copy(t._frustum,this._frustum),this._frustumDirty=!1),t._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:(this._viewInverseTransposeMatrix?o.mat4.copy(this._viewInverseTransposeMatrix,t._viewInverseTransposeMatrix):this._viewInverseTransposeMatrix=a.mat4f64.clone(t._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),t._fullViewport?this._fullViewport?c.vec4.copy(this._fullViewport,t._fullViewport):this._fullViewport=u.vec4f64.clone(t._fullViewport):this._fullViewport=null,this.pixelRatio=e.pixelRatio,this},y.prototype.copyViewFrom=function(e){this.eye=e.eye,this.center=e.center,this.up=e.up},y.prototype.clone=function(){var e=new y;return e.copyFrom(this),e},y.prototype.equals=function(e){return v(this._eye,e._eye)&&v(this._center,e._center)&&v(this._up,e._up)&&m(this._viewport,e._viewport)&&m(this._padding,e._padding)&&this._near===e._near&&this._far===e._far&&this._fov===e._fov&&this.pixelRatio===e.pixelRatio&&this.relativeElevation===e.relativeElevation},y.prototype.almostEquals=function(e,t,n){void 0===n&&(n=!1);var i,r=s.vec3.distance(this._eye,this._center)*(t||5e-4),o=r*r;return i=n?(p.directionFromTo(x,e._eye,e._center),p.directionFromTo(S,this._eye,this._center),1e-10):(s.vec3.copy(x,e._center),s.vec3.copy(S,this._center),o),s.vec3.squaredDistance(e._eye,this._eye)<o&&s.vec3.squaredDistance(x,S)<i&&Math.abs(e._fov-this._fov)<.001&&h(e._padding,this._padding)<.5&&h(e._viewport,this._viewport)<.5&&this.pixelRatio===e.pixelRatio},y.prototype.markViewDirty=function(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0},y.prototype.computeRenderPixelSizeAt=function(e){return this.computeRenderPixelSizeAtDist(this.viewDirectionDistance(e))},y.prototype.computeRenderPixelSizeAtDist=function(e){return e*this.perRenderPixelRatio},y.prototype.computeScreenPixelSizeAt=function(e){return this.computeScreenPixelSizeAtDist(this.viewDirectionDistance(e))},y.prototype.viewDirectionDistance=function(e){return Math.abs(n.projectPointSignedLength(this.viewForward,s.vec3.subtract(x,e,this._eye)))},y.prototype.computeScreenPixelSizeAtDist=function(e){return e*this.perScreenPixelRatio},y.prototype.computeDistanceFromRadius=function(e,t){return e/Math.tan(Math.min(this.fovX,this.fovY)/(2*(t||1)))},y.prototype.getScreenCenter=function(e){return void 0===e&&(e=i.createScreenPointArray()),e[0]=(this.padding[3]+this.width/2)/this.pixelRatio,e[1]=(this.padding[0]+this.height/2)/this.pixelRatio,e},y.prototype.getRenderCenter=function(e,t,n){return void 0===t&&(t=.5),void 0===n&&(n=.5),(e=e||i.createRenderScreenPointArray3())[0]=this.padding[3]+this.width*t,e[1]=this.padding[2]+this.height*n,2<e.length&&(e[2]=.5),e},y.prototype.setGLViewport=function(e){var t=this.viewport,n=this.padding;e.setViewport(t[0]-n[3],t[1]-n[2],t[2]+n[1]+n[3],t[3]+n[0]+n[2])},y.prototype.applyProjection=function(e,t,n){void 0===n&&(n=!1),e!==b&&s.vec3.copy(b,e),b[3]=1,n&&(t[2]=-b[2]),c.vec4.transformMat4(b,b,this.projectionMatrix),s.vec3.scale(b,b,1/Math.abs(b[3]));var i=this.fullViewport;return t[0]=r.lerp(0,i[0]+i[2],.5+.5*b[0]),t[1]=r.lerp(0,i[1]+i[3],.5+.5*b[1]),n||(t[2]=.5*(b[2]+1)),t},y.prototype.projectPoint=function(e,t){if(b[0]=e[0],b[1]=e[1],b[2]=e[2],b[3]=1,c.vec4.transformMat4(b,b,this.viewProjectionMatrix),0===b[3])return null;s.vec3.scale(b,b,1/Math.abs(b[3]));var n=this.fullViewport;return"x"in t?(t.x=r.lerp(0,n[0]+n[2],.5+.5*b[0]),t.y=r.lerp(0,n[1]+n[3],.5+.5*b[1])):(t[0]=r.lerp(0,n[0]+n[2],.5+.5*b[0]),t[1]=r.lerp(0,n[1]+n[3],.5+.5*b[1]),2<t.length&&(t[2]=.5*(b[2]+1))),t},y.prototype.unprojectPoint=function(e,t){if(o.mat4.multiply(_,this.projectionMatrix,this.viewMatrix),!o.mat4.invert(_,_))return null;var n=this.fullViewport;return b[0]=2*(e[0]-n[0])/n[2]-1,b[1]=2*(e[1]-n[1])/n[3]-1,b[2]=2*e[2]-1,b[3]=1,c.vec4.transformMat4(b,b,_),0===b[3]?null:(t[0]=b[0]/b[3],t[1]=b[1]/b[3],t[2]=b[2]/b[3],t)},y.prototype.computeUp=function(e){"global"===e?this.computeUpGlobal():this.computeUpLocal()},y.prototype.screenToRender=function(e,t){var n=e[0]*this.pixelRatio,i=this.fullHeight-e[1]*this.pixelRatio;return t[0]=n,t[1]=i,t},y.prototype.renderToScreen=function(e,t){var n=e[0]/this.pixelRatio,i=(this.fullHeight-e[1])/this.pixelRatio;return t[0]=n,t[1]=i,t},y.prototype.computeUpGlobal=function(){s.vec3.subtract(x,this.center,this.eye);var e=s.vec3.length(this.center);e<1?(s.vec3.set(this.up,0,0,1),this.markViewDirty()):Math.abs(s.vec3.dot(x,this.center))>.9999*s.vec3.length(x)*e||(s.vec3.cross(this.up,x,this.center),s.vec3.cross(this.up,this.up,x),s.vec3.normalize(this.up,this.up),this.markViewDirty())},y.prototype.computeUpLocal=function(){p.directionFromTo(x,this.eye,this.center),Math.abs(x[2])<=.9999&&(s.vec3.scale(x,x,x[2]),s.vec3.set(this.up,-x[0],-x[1],1-x[2]),s.vec3.normalize(this.up,this.up),this.markViewDirty())},y.prototype._compareAndSetView=function(e,t){v(e,t)||(s.vec3.copy(t,e),this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0)},y.prototype._recomputeFrustum=function(){this._frustumDirty&&(d.frustum.fromMatrix(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)},y.prototype._ensureViewClean=function(){this._viewDirty&&(o.mat4.lookAt(this._viewMatrix,this._eye,this._center,this._up),s.vec3.set(this._viewForward,-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10]),s.vec3.set(this._viewUp,this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9]),s.vec3.set(this._viewRight,this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8]),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)},y);function y(e,t,n){void 0===e&&(e=l.vec3f64.create()),void 0===t&&(t=l.vec3f64.create()),void 0===n&&(n=l.vec3f64.fromValues(0,0,1)),this._viewUp=l.vec3f64.create(),this._viewForward=l.vec3f64.create(),this._viewRight=l.vec3f64.create(),this._ray=d.ray.createWrapper(),this._viewport=u.vec4f64.fromValues(0,0,1,1),this._padding=u.vec4f64.fromValues(0,0,0,0),this._fov=55/180*Math.PI,this._near=1,this._far=1e3,this._viewDirty=!0,this._viewMatrix=a.mat4f64.create(),this._projectionDirty=!0,this._projectionMatrix=a.mat4f64.create(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=a.mat4f64.create(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=a.mat4f64.create(),this._frustumDirty=!0,this._frustum=d.frustum.create(),this._fullViewport=null,this.pixelRatio=1,this.relativeElevation=0,this._eye=l.vec3f64.clone(e),this._center=l.vec3f64.clone(t),this._up=l.vec3f64.clone(n),this._padding=u.vec4f64.create()}t.default=g;var b=u.vec4f64.create(),_=a.mat4f64.create(),x=l.vec3f64.create(),S=l.vec3f64.create()}.apply(null,i))||(e.exports=r)},2693:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(76),n(166),n(118),n(150),n(1650),n(1642)],void 0===(r=function(e,t,n,i,g,r,a,o){function s(e,t,n){return(n=n||e)[0]=e[0]+t,n[1]=e[1]+t,n[2]=e[2]+t,n}function y(e,t,n){return!a.frustum.intersectsSphere(n.planes,a.sphere.wrap(t,e))}function b(e,t){for(var n=1/0,i=null,r=0;r<8;++r){var o=_(e,t,d[r]);o<n&&(n=o,i=d[r])}return i}function _(e,t,n){return t*(e[0]*n[0]+e[1]*n[1]+e[2]*n[2])}var l=(Object.defineProperty(R.prototype,"center",{get:function(){return this._root.center},enumerable:!0,configurable:!0}),Object.defineProperty(R.prototype,"size",{get:function(){return 2*this._root.halfSize},enumerable:!0,configurable:!0}),Object.defineProperty(R.prototype,"root",{get:function(){return this._root.node},enumerable:!0,configurable:!0}),Object.defineProperty(R.prototype,"maximumObjectsPerNode",{get:function(){return this._maximumObjectsPerNode},enumerable:!0,configurable:!0}),Object.defineProperty(R.prototype,"maximumDepth",{get:function(){return this._maximumDepth},enumerable:!0,configurable:!0}),Object.defineProperty(R.prototype,"objectCount",{get:function(){return this._objectCount},enumerable:!0,configurable:!0}),R.prototype.destroy=function(){this._degenerateObjects.clear(),this._root=null,c.clearPool(),p=[null],m.prune(),M.prune(),D.prune()},R.prototype.add=function(e,t){var n=this._objectOrObjectsArray(e);t=null==t?n.length:t,this._objectCount+=t,this._grow(n,t);for(var i=c.acquire(),r=0;r<t;r++){var o=n[r];i.init(this._root),this._isDegenerate(o)?this._degenerateObjects.add(o):this._add(o,i)}c.release(i)},R.prototype.remove=function(e,t){var n=this._objectOrObjectsArray(e);this._objectCount-=n.length;for(var i=c.acquire(),r=0;r<n.length;r++){var o=n[r],a=t||this._boundingSphereFromObject(o,P);this._isValidRadius(a.radius)?(i.init(this._root),this._remove(o,a,i)):this._degenerateObjects.delete(o)}c.release(i),this._shrink()},R.prototype.update=function(e,t){!this._isValidRadius(t.radius)&&this._isDegenerate(e)||(this.remove(e,t),this.add(e))},R.prototype.forEachAlongRay=function(e,t,n){var i=this,r=a.ray.wrap(e,t);this._forEachNode(this._root,function(e){if(!i._intersectsNode(r,e))return!1;var t=e.node;return t.terminals.forEach(function(e){i._intersectsObject(r,e)&&n(e)}),null!==t.residents&&t.residents.forEach(function(e){i._intersectsObject(r,e)&&n(e)}),!0})},R.prototype.forEachAlongRayWithVerticalOffset=function(e,t,n,i){var r=this,o=a.ray.wrap(e,t);this._forEachNode(this._root,function(e){if(!r._intersectsNodeWithOffset(o,e,i))return!1;var t=e.node;return t.terminals.forEach(function(e){r._intersectsObjectWithOffset(o,e,i)&&n(e)}),null!==t.residents&&t.residents.forEach(function(e){r._intersectsObjectWithOffset(o,e,i)&&n(e)}),!0})},R.prototype.forEach=function(n){this._forEachNode(this._root,function(e){var t=e.node;return t.terminals.forEach(n),null!==t.residents&&t.residents.forEach(n),!0}),this._degenerateObjects.forEach(n)},R.prototype.forEachDegenerateObject=function(e){this._degenerateObjects.forEach(e)},R.prototype.findClosest=function(e,t,n,i,r){return this._findClosest(e,"front-to-back"===t?1:-1,n,i,r)},R.prototype.forEachInDepthRange=function(e,t,n,i,r,o,a,s){this._forEachInDepthRange(e,t,"front-to-back"===n?1:-1,i,r,o,a,s)},R.prototype.forEachNode=function(t){this._forEachNode(this._root,function(e){return t(e.node,e.center,2*e.halfSize)})},R.prototype._intersectsNode=function(e,t){return s(t.center,2*-t.halfSize,f),s(t.center,2*t.halfSize,h),o.rayBoxTest(e.origin,e.direction,f,h)},R.prototype._intersectsNodeWithOffset=function(e,t,n){return s(t.center,2*-t.halfSize,f),s(t.center,2*t.halfSize,h),n.applyToMinMax(f,h),o.rayBoxTest(e.origin,e.direction,f,h)},R.prototype._intersectsObject=function(e,t){var n=this._objectToBoundingSphere.getRadius(t);return!(0<n)||a.sphere.intersectsRay(a.sphere.wrap(n,this._objectToBoundingSphere.getCenter(t)),e)},R.prototype._intersectsObjectWithOffset=function(e,t,n){var i=this._objectToBoundingSphere.getRadius(t);return!(0<i)||a.sphere.intersectsRay(n.applyToBoundingSphere(i,this._objectToBoundingSphere.getCenter(t)),e)},R.prototype._forEachNode=function(e,t){for(var n=c.acquire().init(e),i=[n];0!==i.length;){if(t(n=i.pop())&&!n.isLeaf())for(var r=0;r<n.node.children.length;r++)n.node.children[r]&&i.push(c.acquire().init(n).advance(r));c.release(n)}},R.prototype._forEachNodeDepthOrdered=function(e,t,n,i){void 0===i&&(i=1);var r=c.acquire().init(e),o=[r];for(function(e,t,n){if(!M.length)for(var i=0;i<8;++i)M.push({index:0,distance:0});for(i=0;i<8;++i){var r=u[i];M.data[i].index=i,M.data[i].distance=_(e,t,r)}for(M.sort(function(e,t){return e.distance-t.distance}),n.clear(),i=0;i<8;++i)n.push(M.data[i].index)}(n,i,D);0!==o.length;){if(t(r=o.pop())&&!r.isLeaf())for(var a=7;0<=a;--a){var s=D.data[a];s>=r.node.children.length||r.node.children[s]&&o.push(c.acquire().init(r).advance(s))}c.release(r)}},R.prototype._findClosest=function(o,a,s,l,n){function i(e){if(++f,!l||l(e)){var t=c._objectToBoundingSphere.getCenter(e),n=c._objectToBoundingSphere.getRadius(e);if(!s||!y(t,n,s)){var i=_(o,a,t),r=i-n;r<u&&(u=r,d=i+n,p=e)}}}var c=this,u=1/0,d=1/0,p=null,r=b(o,a),f=0;return this._forEachNodeDepthOrdered(this._root,function(e){if(null!=n&&n<=f)return!1;if(s&&y(e.center,e.halfSize*x,s))return!1;if(g.vec3.scale(S,r,e.halfSize),g.vec3.add(S,S,e.center),_(o,a,S)>d)return!1;var t=e.node;return t.terminals.forEach(function(e){i(e)}),null!==t.residents&&t.residents.forEach(function(e){i(e)}),!0},o,a),p},R.prototype._forEachInDepthRange=function(e,r,o,t,a,s,l,n){var c=this,u=-1/0,d=1/0,p={setRange:function(e){d=1===o?(u=Math.max(u,e.near),Math.min(d,e.far)):(u=Math.max(u,-e.far),Math.min(d,-e.near))}};function i(e){if(++m,!l||l(e)){var t=c._objectToBoundingSphere.getCenter(e),n=c._objectToBoundingSphere.getRadius(e),i=_(r,o,t)-f;d<i-n||i+n<u||s&&y(t,n,s)||a(e,p)}}p.setRange(t);var f=_(r,o,e),h=b(r,o),v=b(r,-1*o),m=0;this._forEachNodeDepthOrdered(this._root,function(e){if(null!=n&&n<=m)return!1;if(s&&y(e.center,e.halfSize*x,s))return!1;if(g.vec3.scale(S,h,e.halfSize),g.vec3.add(S,S,e.center),_(r,o,S)-f>d)return!1;if(g.vec3.scale(S,v,e.halfSize),g.vec3.add(S,S,e.center),_(r,o,S)-f<u)return!1;var t=e.node;return t.terminals.forEach(function(e){i(e)}),null!==t.residents&&t.residents.forEach(function(e){i(e)}),!0},r,o)},R.prototype._objectOrObjectsArray=function(e){return Array.isArray(e)?e:(p[0]=e,p)},R.prototype._remove=function(e,t,n){m.clear();var i=n.advanceTo(t,function(e,t){m.push(e.node),m.push(t)})?n.node.terminals:n.node.residents;if(i.removeUnordered(e),0===i.length)for(var r=m.length-2;0<=r;r-=2){var o=m.data[r],a=m.data[r+1];if(!this._purge(o,a))break}},R.prototype._nodeIsEmpty=function(e){if(0!==e.terminals.length)return!1;if(null!==e.residents)return 0===e.residents.length;for(var t=0;t<e.children.length;t++)if(e.children[t])return!1;return!0},R.prototype._purge=function(e,t){return 0<=t&&(e.children[t]=null),!!this._nodeIsEmpty(e)&&(null===e.residents&&(e.residents=new i({shrink:!0})),!0)},R.prototype._add=function(e,t){t.advanceTo(this._boundingSphereFromObject(e,P))?t.node.terminals.push(e):(t.node.residents.push(e),t.node.residents.length>this._maximumObjectsPerNode&&t.depth<this._maximumDepth&&this._split(t))},R.prototype._split=function(e){var t=e.node.residents;e.node.residents=null;for(var n=0;n<t.length;n++){var i=c.acquire().init(e);this._add(t.data[n],i),c.release(i)}},R.prototype._grow=function(e,t){var n=this;if(0!==t){var i=this._boundingSphereFromObjects(e,t,function(e,t){return n._boundingSphereFromObject(e,t)},w);if(this._isValidRadius(i.radius)&&!this._fitsInsideTree(i))if(this._nodeIsEmpty(this._root.node))g.vec3.copy(this._root.center,i.center),this._root.halfSize=1.25*i.radius;else{var r=c.acquire();this._rootBoundsForRootAsSubNode(i,r),this._placingRootViolatesMaxDepth(r)?this._rebuildTree(i,r):this._growRootAsSubNode(r),c.release(r)}}},R.prototype._rebuildTree=function(e,t){var n=this;g.vec3.copy(A.center,t.center),A.radius=t.halfSize;var i=this._boundingSphereFromObjects([e,A],2,function(e){return e},C),r=c.acquire().init(this._root);this._root.initFrom(null,i.center,1.25*i.radius),this._forEachNode(r,function(e){return n.add(e.node.terminals.data,e.node.terminals.length),null!==e.node.residents&&n.add(e.node.residents.data,e.node.residents.length),!0}),c.release(r)},R.prototype._placingRootViolatesMaxDepth=function(e){var t=0;return this._forEachNode(this._root,function(e){return t=Math.max(t,e.depth),!0}),t+Math.log(e.halfSize/this._root.halfSize)*Math.LOG2E>this._maximumDepth},R.prototype._rootBoundsForRootAsSubNode=function(e,t){for(var n=e.radius,i=e.center,r=-1/0,o=this._root.center,a=this._root.halfSize,s=0;s<3;s++){var l=o[s]-a-(i[s]-n),c=i[s]+n-(o[s]+a),u=Math.max(0,Math.ceil(l/(2*a))),d=Math.max(0,Math.ceil(c/(2*a)))+1,p=Math.pow(2,Math.ceil(Math.log(u+d)*Math.LOG2E));r=Math.max(r,p),O[s].min=u,O[s].max=d}for(s=0;s<3;s++){var f=(r-((u=O[s].min)+(d=O[s].max)))/2;u+=Math.ceil(f),d+=Math.floor(f);var h=o[s]-a-u*a*2;v[s]=h+(d+u)*a}return t.initFrom(null,v,r*a,0)},R.prototype._growRootAsSubNode=function(e){var t=this._root.node;g.vec3.copy(w.center,this._root.center),w.radius=this._root.halfSize,this._root.init(e),e.advanceTo(w,null,!0),e.node.children=t.children,e.node.residents=t.residents,e.node.terminals=t.terminals},R.prototype._shrink=function(){for(;;){var e=this._findShrinkIndex();if(-1===e)break;this._root.advance(e),this._root.depth=0}},R.prototype._findShrinkIndex=function(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return-1;for(var e=null,t=this._root.node.children,n=0,i=0;i<t.length&&null==e;)e=t[n=i++];for(;i<t.length;)if(t[i++])return-1;return n},R.prototype._isDegenerate=function(e){var t=this._objectToBoundingSphere.getRadius(e);return!this._isValidRadius(t)},R.prototype._isValidRadius=function(e){return!isNaN(e)&&e!==-1/0&&e!==1/0&&0<e},R.prototype._fitsInsideTree=function(e){var t=this._root.center,n=this._root.halfSize,i=e.center;return e.radius<=n&&i[0]>=t[0]-n&&i[0]<=t[0]+n&&i[1]>=t[1]-n&&i[1]<=t[1]+n&&i[2]>=t[2]-n&&i[2]<=t[2]+n},R.prototype._boundingSphereFromObject=function(e,t){return g.vec3.copy(t.center,this._objectToBoundingSphere.getCenter(e)),t.radius=this._objectToBoundingSphere.getRadius(e),t},R.prototype._boundingSphereFromObjects=function(e,t,n,i){if(1===t){var r=n(e[0],w);g.vec3.copy(i.center,r.center),i.radius=r.radius}else{f[0]=1/0,f[1]=1/0,f[2]=1/0,h[0]=-1/0,h[1]=-1/0,h[2]=-1/0;for(var o=0;o<t;o++)r=n(e[o],w),this._isValidRadius(r.radius)&&(c=f,u=r.center,d=r.radius,c[0]=Math.min(c[0],u[0]-d),c[1]=Math.min(c[1],u[1]-d),c[2]=Math.min(c[2],u[2]-d),a=h,s=r.center,l=r.radius,a[0]=Math.max(a[0],s[0]+l),a[1]=Math.max(a[1],s[1]+l),a[2]=Math.max(a[2],s[2]+l));g.vec3.lerp(i.center,f,h,.5),i.radius=Math.max(h[0]-f[0],h[1]-f[1],h[2]-f[2])/2}var a,s,l,c,u,d;return i},R),c=(T.prototype.init=function(e){return this.initFrom(e.node,e.center,e.halfSize,e.depth)},T.prototype.initFrom=function(e,t,n,i){return void 0===e&&(e=null),void 0===n&&(n=this.halfSize),void 0===i&&(i=this.depth),this.node=e||T.createEmptyNode(),t&&g.vec3.copy(this.center,t),this.halfSize=n,this.depth=i,this},T.prototype.advance=function(e){var t=this.node.children[e];t||(t=T.createEmptyNode(),this.node.children[e]=t),this.node=t,this.halfSize/=2,this.depth++;var n=u[e];return this.center[0]+=n[0]*this.halfSize,this.center[1]+=n[1]*this.halfSize,this.center[2]+=n[2]*this.halfSize,this},T.prototype.advanceTo=function(e,t,n){for(void 0===n&&(n=!1);;){if(this.isTerminalFor(e))return t&&t(this,-1),!0;if(this.isLeaf()&&!n)return t&&t(this,-1),!1;this.isLeaf()&&(this.node.residents=null);var i=this._childIndex(e);t&&t(this,i),this.advance(i)}},T.prototype.isLeaf=function(){return null!=this.node.residents},T.prototype.isTerminalFor=function(e){return e.radius>this.halfSize/2},T.prototype._childIndex=function(e){for(var t=e.center,n=this.center,i=0,r=0;r<3;r++)n[r]<t[r]&&(i|=1<<r);return i},T.createEmptyNode=function(){return{children:[null,null,null,null,null,null,null,null],terminals:new i({shrink:!0}),residents:new i({shrink:!0})}},T.acquire=function(){return T._pool.acquire()},T.release=function(e){T._pool.release(e)},T.clearPool=function(){T._pool.prune()},T._pool=new n(T),T),u=[r.vec3f64.fromValues(-1,-1,-1),r.vec3f64.fromValues(1,-1,-1),r.vec3f64.fromValues(-1,1,-1),r.vec3f64.fromValues(1,1,-1),r.vec3f64.fromValues(-1,-1,1),r.vec3f64.fromValues(1,-1,1),r.vec3f64.fromValues(-1,1,1),r.vec3f64.fromValues(1,1,1)],d=[r.vec3f64.fromValues(-1,-1,-1),r.vec3f64.fromValues(-1,-1,1),r.vec3f64.fromValues(-1,1,-1),r.vec3f64.fromValues(-1,1,1),r.vec3f64.fromValues(1,-1,-1),r.vec3f64.fromValues(1,-1,1),r.vec3f64.fromValues(1,1,-1),r.vec3f64.fromValues(1,1,1)],x=Math.sqrt(3),p=[null],v=r.vec3f64.create(),S=r.vec3f64.create(),f=r.vec3f64.create(),h=r.vec3f64.create(),m=new i,P={center:r.vec3f64.create(),radius:0},w={center:r.vec3f64.create(),radius:0},A={center:r.vec3f64.create(),radius:0},C={center:r.vec3f64.create(),radius:0},O=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],M=new i,D=new i;function T(e,t,n){void 0===n&&(n=0),this.center=r.vec3f64.create(),this.initFrom(e,t,n,0)}function R(e,t,n,i){this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._objectCount=0,this._objectToBoundingSphere=n,i&&(void 0!==i.maximumObjectsPerNode&&(this._maximumObjectsPerNode=i.maximumObjectsPerNode),void 0!==i.maximumDepth&&(this._maximumDepth=i.maximumDepth)),isNaN(e[0])||isNaN(e[1])||isNaN(e[2])||isNaN(t)?this._root=new c(null,r.vec3f64.fromValues(0,0,0),.5):this._root=new c(null,e,t/2)}return l}.apply(null,i))||(e.exports=r)},2694:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(76),n(118),n(1701)],void 0===(r=function(e,t,n,i,r){return a.prototype.getStaticTransformation=function(){return this.transformation},a.prototype.getShaderTransformation=function(){return this.shaderTransformation?this.shaderTransformation(this.transformation):this.transformation},a.prototype.computeAttachmentOrigin=function(e){return!!(this.material.computeAttachmentOrigin?this.material.computeAttachmentOrigin(this.geometry,e):this.geometry.computeAttachmentOrigin(e))&&(i.vec3.transformMat4(e,e,this.getStaticTransformation()),!0)},a._idGen=new r.IdGen,a.pool=new n(a,!0),a;function a(e,t,n,i,r,o){this.id=a._idGen.gen(e&&e.id),this.geometry=e,this.material=t,this.transformation=n,this.instanceParameters=i,this.origin=r,this.shaderTransformation=o}}.apply(null,i))||(e.exports=r)},2695:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1701)],void 0===(r=function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var i=new n.IdGen;t.generateHighlightId=function(){return i.gen("highlight")}}.apply(null,i))||(e.exports=r)},2696:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(33),n(12),n(484),n(1633),n(127),n(150),n(1660),n(1661),n(492),n(80),n(521),n(305),n(486),n(211)],void 0===(r=function(e,t,r,s,l,c,n,f,o,i,a,u,d,p,h,v){function m(e){var t=e.paths[0];if(!t||0===t.length)return null;var n=p.getPointOnPath(t,p.getPathLength(t)/2);return h.makeDehydratedPoint(n[0],n[1],n[2],e.spatialReference)}function g(e,t,n){var i=n?e:h.clonePoint(e);return t&&e?v.pointToPoint(e,i,t)?i:null:i}function y(e){if(Array.isArray(e)){for(var t=0,n=e;t<n.length;t++)if(!y(n[t]))return!1;return!0}return null==e||0<=e}Object.defineProperty(t,"__esModule",{value:!0}),t.computeCentroid=function(e,t){if("point"===e.type)return g(e,t,!1);if(h.isHydratedGeometry(e))switch(e.type){case"extent":return g(e.center,t,!1);case"polygon":return g(e.centroid,t,!1);case"polyline":return g(m(e),t,!0);case"mesh":return g(e.extent.center,t,!1)}else switch(e.type){case"extent":return g((n=e,i=r.isFinite(n.zmin),h.makeDehydratedPoint(.5*(n.xmax+n.xmin),.5*(n.ymax+n.ymin),i?.5*(n.zmax+n.zmin):void 0,n.spatialReference)),t,!0);case"polygon":return g(function(e){var t=e.rings[0];if(!t||0===t.length)return null;var n=d.ringsCentroid(e.rings,e.hasZ);return h.makeDehydratedPoint(n[0],n[1],n[2],e.spatialReference)}(e),t,!0);case"polyline":return g(m(e),t,!0)}var n,i},t.enlargeExtent=function(e,t,n){if(e){t=t||u.create();var i=.5*e.width*(n-1),r=.5*e.height*(n-1);return e.width<1e-7*e.height?i+=r/20:e.height<1e-7*e.width&&(r+=i/20),o.vec4.set(t,e.xmin-i,e.ymin-r,e.xmax+i,e.ymax+r),t}return null},t.updateVertexAttributeAuxpos1w=function(e,t){for(var n=0;n<e.geometries.length;++n){var i=e.geometries[n].data.vertexAttributes.auxpos1;i&&i.data[3]!==t&&(i.data[3]=t,e.geometryVertexAttrsUpdated(n))}},t.mixinColorAndOpacity=function(e,t){var n=i.vec4f64.clone(i.vec4f64.ONES);return s.isSome(e)&&(n[0]=e[0],n[1]=e[1],n[2]=e[2]),s.isSome(t)?n[3]=t:s.isSome(e)&&3<e.length&&(n[3]=e[3]),n},t.overrideColor=function(e,t,n,i,r,o){void 0===o&&(o=[0,0,0,0]);for(var a=0;a<3;++a)s.isSome(e)&&null!=e[a]?o[a]=e[a]:s.isSome(n)&&null!=n[a]?o[a]=n[a]:o[a]=r[a];return s.isSome(t)?o[3]=t:s.isSome(i)?o[3]=i:o[3]=r[3],o},t.computeObjectScale=function(e,t,n,i){void 0===e&&(e=f.vec3f64.ONES),void 0===i&&(i=1);var r=new Array(3);if(null==t||null==n)r[0]=1,r[1]=1,r[2]=1;else{for(var o=void 0,a=0,s=2;0<=s;s--){var l=e[s],c=void 0,u=null!=l,d=0===s&&!o&&!u,p=n[s];"symbolValue"===l||d?c=0!==p?t[s]/p:1:u&&"proportional"!==l&&isFinite(l)&&(c=0!==p?l/p:1),null!=c&&(o=r[s]=c,a=Math.max(a,Math.abs(c)))}for(s=2;0<=s;s--)null==r[s]?r[s]=o:0===r[s]&&(r[s]=.001*a)}for(s=2;0<=s;s--)r[s]/=i;return f.vec3f64.fromArray(r)},t.computeSizeWithResourceSize=function(e,t){var n=t.isPrimitive,i=t.width,r=t.depth,o=t.height,a=n?10:1;if(null==i&&null==o&&null==r)return[a*e[0],a*e[1],a*e[2]];for(var s,l=f.vec3f64.fromValues(i,r,o),c=0;c<3;c++){var u=l[c];if(null!=u){s=u/e[c];break}}for(c=0;c<3;c++)null==l[c]&&(l[c]=e[c]*s);return l},t.validateSymbolLayerSize=function(e){return null!=e.isPrimitive&&(e=[e.width,e.depth,e.height]),y(e)?null:"Symbol sizes may not be negative values"},t.isValidSize=y,t.computeObjectRotation=function(e,t,n,i){void 0===i&&(i=c.mat4f64.create());var r=e||0,o=t||0,a=n||0;return 0!==r&&l.mat4.rotateZ(i,i,-r/180*Math.PI),0!==o&&l.mat4.rotateX(i,i,o/180*Math.PI),0!==a&&l.mat4.rotateY(i,i,a/180*Math.PI),i},t.demResolutionForBoundingBox=function(e,t){return null!=t.minDemResolution?t.minDemResolution:a.isPoint(e)?t.minDemResolutionForPoints:.01*a.maximumDimension(e)},t.namedAnchorToHUDMaterialAnchorPos={"bottom-left":n.vec2f64.fromValues(0,0),bottom:n.vec2f64.fromValues(.5,0),"bottom-right":n.vec2f64.fromValues(1,0),left:n.vec2f64.fromValues(0,.5),center:n.vec2f64.fromValues(.5,.5),right:n.vec2f64.fromValues(1,.5),"top-left":n.vec2f64.fromValues(0,1),top:n.vec2f64.fromValues(.5,1),"top-right":n.vec2f64.fromValues(1,1)}}.apply(null,i))||(e.exports=r)},2697:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(166),n(118),n(150),n(1642)],void 0===(r=function(e,t,n,S,P,w){var i=(A.prototype.getCenter=function(){return this.center},A.prototype.getBSRadius=function(){return this.bsRadius},A.prototype.getBBMin=function(){return this.bbMin},A.prototype.getBBMax=function(){return this.bbMax},A.prototype.getPrimitiveIndices=function(){return this.primitiveIndices},A.prototype.getIndices=function(){return this.indices},A.prototype.getPosition=function(){return this._position},A.prototype.getChildren=function(){if(this._children)return this._children;if(1<S.vec3.squaredDistance(this.bbMin,this.bbMax)){for(var e=S.vec3.lerp(P.vec3f64.create(),this.bbMin,this.bbMax,.5),t=this.primitiveIndices.length,n=new Uint8Array(t),i=new Array(8),r=0;r<8;++r)i[r]=0;var o=this._position,a=o.data,s=o.offsetIdx,l=o.strideIdx;for(r=0;r<t;++r){for(var c=0,u=this._numIndexPerPrimitive*this.primitiveIndices[r],d=s+l*this.indices[u],p=a[d],f=a[d+1],h=a[d+2],v=1;v<this._numIndexPerPrimitive;++v){var m=a[d=s+l*this.indices[u+v]],g=a[d+1],y=a[d+2];m<p&&(p=m),g<f&&(f=g),y<h&&(h=y)}p<e[0]&&(c|=1),f<e[1]&&(c|=2),h<e[2]&&(c|=4),++i[n[r]=c]}var b=0;for(r=0;r<8;++r)0<i[r]&&++b;if(b<2)return;var _=new Array(8);for(r=0;r<8;++r)_[r]=0<i[r]?new Uint32Array(i[r]):void 0;for(r=0;r<8;++r)i[r]=0;for(r=0;r<t;++r)_[c=n[r]][i[c]++]=this.primitiveIndices[r];for(this._children=new Array(8),r=0;r<8;++r)void 0!==_[r]&&(this._children[r]=new A(_[r],this._numIndexPerPrimitive,this.indices,this._position))}return this._children},A);function A(e,t,n,i){this.primitiveIndices=e,this._numIndexPerPrimitive=t,this.indices=n,this._position=i,this.center=P.vec3f64.create(),w.assert(1<=e.length),w.assert(n.length%this._numIndexPerPrimitive==0),w.assert(n.length>=e.length*this._numIndexPerPrimitive),w.assert(3===this._position.size||4===this._position.size);var r=this._position,o=r.data,a=r.offsetIdx,s=r.strideIdx,l=0,c=e.length,u=a+s*n[this._numIndexPerPrimitive*e[l]];for(A.tmpIndices.clear(),A.tmpIndices.push(u),this.bbMin=P.vec3f64.fromValues(o[u],o[u+1],o[u+2]),this.bbMax=P.vec3f64.clone(this.bbMin);l<c;++l)for(var d=this._numIndexPerPrimitive*e[l],p=0;p<this._numIndexPerPrimitive;++p){u=a+s*n[d+p],A.tmpIndices.push(u);var f=o[u];this.bbMin[0]=Math.min(f,this.bbMin[0]),this.bbMax[0]=Math.max(f,this.bbMax[0]),f=o[u+1],this.bbMin[1]=Math.min(f,this.bbMin[1]),this.bbMax[1]=Math.max(f,this.bbMax[1]),f=o[u+2],this.bbMin[2]=Math.min(f,this.bbMin[2]),this.bbMax[2]=Math.max(f,this.bbMax[2])}S.vec3.lerp(this.center,this.bbMin,this.bbMax,.5),this.bsRadius=.5*Math.max(Math.max(this.bbMax[0]-this.bbMin[0],this.bbMax[1]-this.bbMin[1]),this.bbMax[2]-this.bbMin[2]);var h=this.bsRadius*this.bsRadius;for(l=0;l<A.tmpIndices.length;++l){var v=o[u=A.tmpIndices.data[l]]-this.center[0],m=o[u+1]-this.center[1],g=o[u+2]-this.center[2],y=v*v+m*m+g*g;if(!(y<=h)){var b=Math.sqrt(y),_=.5*(b-this.bsRadius);this.bsRadius=this.bsRadius+_,h=this.bsRadius*this.bsRadius;var x=_/b;this.center[0]+=v*x,this.center[1]+=m*x,this.center[2]+=g*x}}A.tmpIndices.clear()}return(i||(i={})).tmpIndices=new n({deallocator:null}),i}.apply(null,i))||(e.exports=r)},2698:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1673),n(1721),n(1642)],void 0===(r=function(e,t,h,v,m){Object.defineProperty(t,"__esModule",{value:!0});var n=(Object.defineProperty(g.prototype,"id",{get:function(){return this._id},enumerable:!0,configurable:!0}),Object.defineProperty(g.prototype,"vertexAttributes",{get:function(){return this._vertexAttributes},enumerable:!0,configurable:!0}),Object.defineProperty(g.prototype,"indices",{get:function(){return this._indices},enumerable:!0,configurable:!0}),Object.defineProperty(g.prototype,"componentOffsets",{get:function(){return this._componentOffsets},enumerable:!0,configurable:!0}),Object.defineProperty(g.prototype,"indexCount",{get:function(){var e=m.getFirstObjectValue(this._indices);return null==e?0:e.length},enumerable:!0,configurable:!0}),Object.defineProperty(g.prototype,"primitiveType",{get:function(){return this._primitiveType},enumerable:!0,configurable:!0}),g.prototype.getVertexAttr=function(){return this.vertexAttributes},g.prototype.toRenderData=function(){return{id:this._id.toString(),preinterleaved:!1,indices:this._indices,vertexAttr:this._vertexAttributes}},g.prototype.getIndices=function(e){return this._indices[e]},g.prototype.getAttribute=function(e){return this._vertexAttributes[e]},g.prototype.estimateGpuMemoryUsage=function(){var e=0;if(this._indices[m.VertexAttrConstants.POSITION]){var t=3;e+=this._indices[m.VertexAttrConstants.POSITION].length*t*4}return this._indices[m.VertexAttrConstants.NORMAL]&&(t=3,e+=this._indices[m.VertexAttrConstants.NORMAL].length*t*4),this._indices[m.VertexAttrConstants.UV0]&&(t=2,e+=this._indices[m.VertexAttrConstants.UV0].length*t*4),this._indices[m.VertexAttrConstants.COLOR]&&(t=1,e+=this._indices[m.VertexAttrConstants.COLOR].length*t*4),e},g.DefaultIndices={},g.DefaultOffsets=new Uint32Array(0),g);function g(e,t,n,i){void 0===t&&(t=g.DefaultIndices),void 0===n&&(n=g.DefaultOffsets),void 0===i&&(i="triangle"),this.preinterleaved=!1;var r,o,a={};for(var s in e){var l=e[s],c=l.data,u=l.size;a[s]={data:c,size:u,offsetIdx:0,strideIdx:u}}if(t===g.DefaultIndices){var d=(r=a,null==(o=m.getFirstObjectValue(r))?0:o.data.length/o.size),p=v.generateDefaultIndexArray(d);for(var f in t={},a)t[f]=p}this._id=v.getNewId(),this._vertexAttributes=a,this._indices=t,this._componentOffsets=h.createOffsets(n),this._primitiveType=i}t.GeometryData=n}.apply(null,i))||(e.exports=r)},2699:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(11),n(5),n(12),n(1654),n(118),n(150),n(1727),n(1967),n(2700),n(1778),n(1642),n(1853),n(1678),n(2704),n(1779),n(2717),n(502),n(502)],void 0===(r=function(e,t,n,i,h,r,v,o,a,s,l,c,u,d,m,p,f,g,y,b){function _(e,t){return e?t?6:9:4}var x,S,P,w,A,C,O=u.assert,M=(C=c.Material,n(F,C),F.prototype.isVisibleInPass=function(e){return 3!==e||this.params.castShadows},F.prototype.isVisible=function(){var e=this.params;if(!C.prototype.isVisible.call(this)||0===e.layerOpacity)return!1;var t=e.instanced,n=e.vertexColors,i=e.symbolColors,r=!!t&&-1<t.indexOf("color"),o=e.vvColorEnabled,a="replace"===e.colorMixMode,s=0<e.opacity,l=e.externalColor&&0<e.externalColor[3];return n&&(r||o||i)?!!a||s:n?a?l:s:r||o||i?!!a||s:a?l:s},F.prototype.setParameterValues=function(e){var t=this.params;for(var n in e)"instanced"===n&&O(e.instanced===t.instanced,"Can not change instanced attributes"),"textureId"===n&&O(t.textureId,"Can only change texture of material that already has a texture"),"vertexColors"===n&&!0===e[n]&&e[n]!==t[n]&&O(t.vertexColors,"Can not enable vertex colors after DefaultMaterial creation"),t[n]=e[n];this.notifyDirty("matChanged")},F.prototype.getParameters=function(){return this.params},F.prototype.getTechniqueConfig=function(e){return this.techniqueConfig.output=e,this.techniqueConfig.hasNormalTexture=!!this.params.normalTextureId,this.techniqueConfig.hasColorTexture=!!this.params.textureId,this.techniqueConfig.vertexTangents=this.params.vertexTangents,this.techniqueConfig.instanced=!!this.params.instanced,this.techniqueConfig.instancedDoublePrecision=this.params.instancedDoublePrecision,this.techniqueConfig.vvSize=this.params.vvSizeEnabled,this.techniqueConfig.verticalOffset=null!==this.params.verticalOffset,this.techniqueConfig.screenSizePerspective=null!==this.params.screenSizePerspective,this.techniqueConfig.slice=this.params.slicePlaneEnabled,this.techniqueConfig.sliceHighlightDisabled=this.params.sliceHighlightDisabled,this.techniqueConfig.alphaDiscardMode="opaque"===this.params.textureAlphaMode?1:"mask"===this.params.textureAlphaMode?2:"maskBlend"===this.params.textureAlphaMode?3:0,this.techniqueConfig.normalsTypeDerivate="screenDerivative"===this.params.normals,0===e&&(this.techniqueConfig.treeRendering=!!this.params.treeRendering,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.symbolColors=this.params.symbolColors,this.techniqueConfig.doubleSidedMode=this.params.doubleSided&&"normal"===this.params.doubleSidedType?1:this.params.doubleSided&&"winding-order"===this.params.doubleSidedType?2:0,this.techniqueConfig.instancedColor=!!this.params.instanced&&-1<this.params.instanced.indexOf("color"),this.techniqueConfig.receiveShadows=this.params.receiveShadows,this.techniqueConfig.receiveAmbientOcclusion=this.params.receiveSSAO,this.techniqueConfig.vvColor=this.params.vvColorEnabled,this.techniqueConfig.textureAlphaPremultiplied=!!this.params.textureAlphaPremultiplied,this.techniqueConfig.usePBR=this.params.usePBR,this.techniqueConfig.hasMetalnessAndRoughnessTexture=!!this.params.metallicRoughnessTextureId,this.techniqueConfig.hasEmissionTexture=!!this.params.emissiveTextureId,this.techniqueConfig.hasOcclusionTexture=!!this.params.occlusionTextureId,this.techniqueConfig.offsetBackfaces=!(!this.params.transparent||!this.params.offsetTransparentBackfaces)),this.techniqueConfig},F.prototype.intersect=function(e,t,n,i,r,o,a){if(null!==this.params.verticalOffset){var s=i.camera;v.vec3.set(Y,n[12],n[13],n[14]);var l=null;switch(i.viewingMode){case"global":l=v.vec3.normalize(Z,Y);break;case"local":l=v.vec3.copy(Z,W)}var c=0;if(null!==this.params.verticalOffset){var u=v.vec3.subtract(K,Y,s.eye),d=v.vec3.length(u),p=v.vec3.scale(u,u,1/d),f=null;this.params.screenSizePerspective&&(f=v.vec3.dot(l,p)),c+=m.verticalOffsetAtDistance(s,d,this.params.verticalOffset,f,this.params.screenSizePerspective)}v.vec3.scale(l,l,c),v.vec3.transformMat3(X,l,i.transform.inverseRotation),r=v.vec3.subtract(k,r,X),o=v.vec3.subtract(q,o,X)}m.intersectTriangleGeometry(e,t,i,r,o,h.isSome(i.options.verticalOffset)?i.options.verticalOffset.object3D:void 0,a)},F.prototype.getGLMaterials=function(){return{color:D,depthShadowMap:R,normal:I,depth:T,highlight:z}},F.prototype.createRenderer=function(e,t){return new(this.params.softwareInstanced?p:f)(e,t,this)},F.prototype.createBufferWriter=function(){return new H(this.vertexBufferLayout,this.instanceBufferLayout)},F.getVertexBufferLayout=function(e){var t=e.textureId||e.normalTextureId||e.metallicRoughnessTextureId||e.emissiveTextureId||e.occlusionTextureId,n=a.newLayout().vec3f("position").vec3f("normal");return e.vertexTangents&&n.vec4f("tangent"),t&&n.vec2f("uv0"),e.vertexColors&&n.vec4u8("color"),e.symbolColors&&n.vec4u8("symbolColor"),n},F.getInstanceBufferLayout=function(e){var t=a.newLayout();return t=e.instancedDoublePrecision?t.vec3f("modelOriginHi").vec3f("modelOriginLo").mat3f("model").mat3f("modelNormal"):t.mat4f("model").mat4f("modelNormal"),e.instanced&&-1<e.instanced.indexOf("color")&&(t=t.vec4f("instanceColor")),e.instanced&&-1<e.instanced.indexOf("featureAttribute")&&(t=t.vec4f("instanceFeatureAttribute")),t},F),D=(n(j,A=l),j.prototype.selectPipeline=function(e){var t=this.params,n=0===e?B(t):null;this.pipelineState=b.makePipelineState({blending:n,culling:U(t),depthTest:{func:513},depthWrite:t.writeDepth&&b.defaultDepthWriteParams,colorWrite:b.defaultColorWriteParams})},j.prototype.beginSlot=function(e){return e===this.slot},j.prototype.getProgram=function(){return this.technique.program},j.prototype.getPrograms=function(){return null},j.prototype.updateParameters=function(){this.params=m.copyParameters(this.material.getParameters()),this.slot=_(this.params.transparent,this.params.writeDepth),this.updateTexture(this.params.textureId),this.technique=this.techniqueRep.acquireAndReleaseExisting(g.DefaultMaterialTechnique,this.material.getTechniqueConfig(0),this.technique),this.selectPipeline(0)},j.prototype._updateShadowState=function(e){e.shadowMappingEnabled!==this.params.receiveShadows&&(this.material.setParameterValues({receiveShadows:e.shadowMappingEnabled}),this.updateParameters())},j.prototype.bind=function(e,t){var n=this.params;this._updateShadowState(t);var i=this.technique.program;e.bindProgram(i),e.setPipelineState(this.pipelineState),this.technique.bindPass(e,n,t),m.bindVerticalOffset(n.verticalOffset,t,i),m.bindScreenSizePerspective(n.screenSizePerspective,i),this.bindTexture(e,i)},j.prototype.release=function(){},j.prototype.bindView=function(e){var t=this.technique.program,n=this.params,i=n.instancedDoublePrecision?o.vec3f64.fromValues(e.viewInvTransp[3],e.viewInvTransp[7],e.viewInvTransp[11]):e.origin;m.bindView(i,e.view,t),m.bindCamPos(i,e.viewInvTransp,t),n.instancedDoublePrecision&&m.bindViewOriginDouble(i,t),n.slicePlaneEnabled&&m.bindSlicePlane(i,e.slicePlane,t),e.shadowMappingEnabled&&e.shadowMap.bindView(t,i)},j.prototype.bindInstance=function(e){var t=this.technique.program;t.setUniformMatrix4fv("model",e.transformation),t.setUniformMatrix4fv("modelNormal",e.transformationNormal)},j.prototype.getDrawMode=function(){return 4},j),T=(n(N,w=l),N.prototype.beginSlot=function(e){return e===this.slot},N.prototype.getProgram=function(){return this.technique.program},N.prototype.getPrograms=function(){return null},N.prototype.selectPipeline=function(){var e=this.params;this.pipelineState=b.makePipelineState({culling:U(e),depthTest:{func:513},depthWrite:e.writeDepth&&b.defaultDepthWriteParams,colorWrite:b.defaultColorWriteParams})},N.prototype.selectSlot=function(){this.slot=_(this.params.transparent,this.params.writeDepth)},N.prototype.updateParameters=function(){this.params=m.copyParameters(this.material.getParameters()),this.technique=this.techniqueRep.acquireAndReleaseExisting(g.DefaultMaterialTechnique,this.material.getTechniqueConfig(1),this.technique),this.selectPipeline(),this.selectSlot(),this.updateTexture(this.params.textureId)},N.prototype.bind=function(e,t){var n=this.technique.program,i=this.params;e.bindProgram(n),e.setPipelineState(this.pipelineState),this.technique.bindPass(e,i,t),m.bindVerticalOffset(i.verticalOffset,t,n),m.bindScreenSizePerspective(i.screenSizePerspective,n),this.bindTexture(e,n)},N.prototype.release=function(){},N.prototype.bindView=function(e){var t=this.technique.program,n=this.params,i=n.instancedDoublePrecision?o.vec3f64.fromValues(e.viewInvTransp[3],e.viewInvTransp[7],e.viewInvTransp[11]):e.origin;m.bindView(i,e.view,t),n.slicePlaneEnabled&&m.bindSlicePlane(i,e.slicePlane,t),n.screenSizePerspective&&m.bindCamPos(i,e.viewInvTransp,t),n.instancedDoublePrecision&&m.bindViewOriginDouble(i,t)},N.prototype.bindInstance=function(e){this.technique.program.setUniformMatrix4fv("model",e.transformation)},N.prototype.getDrawMode=function(){return 4},N),R=(n(V,P=T),V.prototype.updateParameters=function(){this.params=m.copyParameters(this.material.getParameters()),this.technique=this.techniqueRep.acquireAndReleaseExisting(g.DefaultMaterialTechnique,this.material.getTechniqueConfig(3),this.technique),this.selectPipeline(),this.selectSlot(),this.updateTexture(this.params.textureId)},V),I=(n(E,S=l),E.prototype.beginSlot=function(e){return e===this.slot},E.prototype.getProgram=function(){return this.technique.program},E.prototype.getPrograms=function(){return null},E.prototype.selectPipeline=function(){var e=this.params;this.pipelineState=b.makePipelineState({culling:U(e),depthTest:{func:513},depthWrite:e.writeDepth&&b.defaultDepthWriteParams,colorWrite:b.defaultColorWriteParams})},E.prototype.selectSlot=function(){this.slot=_(this.params.transparent,this.params.writeDepth)},E.prototype.updateParameters=function(){this.params=m.copyParameters(this.material.getParameters()),this.technique=this.techniqueRep.acquireAndReleaseExisting(g.DefaultMaterialTechnique,this.material.getTechniqueConfig(2),this.technique),this.selectPipeline(),this.selectSlot(),this.updateTexture(this.params.textureId)},E.prototype.bind=function(e,t){var n=this.technique.program,i=this.params;e.bindProgram(n),e.setPipelineState(this.pipelineState),this.technique.bindPass(e,i,t),m.bindVerticalOffset(i.verticalOffset,t,n),m.bindScreenSizePerspective(i.screenSizePerspective,n),this.bindTexture(e,n)},E.prototype.release=function(){},E.prototype.bindView=function(e){var t=this.technique.program,n=this.params,i=n.instancedDoublePrecision?o.vec3f64.fromValues(e.viewInvTransp[3],e.viewInvTransp[7],e.viewInvTransp[11]):e.origin;m.bindView(i,e.view,t),t.setUniformMatrix4fv("viewNormal",e.viewInvTransp),n.slicePlaneEnabled&&m.bindSlicePlane(i,e.slicePlane,t),n.screenSizePerspective&&m.bindCamPos(i,e.viewInvTransp,t),n.instancedDoublePrecision&&m.bindViewOriginDouble(i,t)},E.prototype.bindInstance=function(e){var t=this.technique.program;t.setUniformMatrix4fv("model",e.transformation),t.setUniformMatrix4fv("modelNormal",e.transformationNormal)},E.prototype.getDrawMode=function(){return 4},E),z=(n(L,x=l),L.prototype.beginSlot=function(e){return e===this.slot},L.prototype.getProgram=function(){return this.technique.program},L.prototype.getPrograms=function(){return null},L.prototype.selectPipeline=function(){var e=this.params;this.pipelineState=b.makePipelineState({culling:U(e),depthTest:{func:513},depthWrite:e.writeDepth&&b.defaultDepthWriteParams,colorWrite:b.defaultColorWriteParams})},L.prototype.selectSlot=function(){this.slot=_(this.params.transparent,this.params.writeDepth)},L.prototype.updateParameters=function(){this.params=m.copyParameters(this.material.getParameters()),this.technique=this.techniqueRep.acquireAndReleaseExisting(g.DefaultMaterialTechnique,this.material.getTechniqueConfig(4),this.technique),this.selectPipeline(),this.selectSlot(),this.updateTexture(this.params.textureId)},L.prototype.bind=function(e,t){var n=this.technique.program,i=this.params;e.bindProgram(n),e.setPipelineState(this.pipelineState),this.technique.bindPass(e,i,t),m.bindVerticalOffset(i.verticalOffset,t,n),m.bindScreenSizePerspective(i.screenSizePerspective,n),this.bindTexture(e,n)},L.prototype.release=function(){},L.prototype.bindView=function(e){var t=this.technique.program,n=this.params,i=n.instancedDoublePrecision?o.vec3f64.fromValues(e.viewInvTransp[3],e.viewInvTransp[7],e.viewInvTransp[11]):e.origin;m.bindView(i,e.view,t),n.slicePlaneEnabled&&m.bindSlicePlane(i,e.slicePlane,t),n.screenSizePerspective&&m.bindCamPos(i,e.viewInvTransp,t),n.instancedDoublePrecision&&m.bindViewOriginDouble(i,t)},L.prototype.bindInstance=function(e){var t=this.technique.program;t.setUniformMatrix4fv("model",e.transformation),t.setUniformMatrix4fv("modelNormal",e.transformationNormal)},L.prototype.getDrawMode=function(){return 4},L);function L(e){var t=this,n=e.material;return(t=x.call(this,l.makeCtorParameters(e,n.getParameters()))||this).updateParameters(),t}function E(e){var t=this,n=e.material.getParameters();return(t=S.call(this,l.makeCtorParameters(e,n))||this).params=m.copyParameters(n),t.technique=t.techniqueRep.acquireAndReleaseExisting(g.DefaultMaterialTechnique,t.material.getTechniqueConfig(2),t.technique),t.selectPipeline(),t.selectSlot(),t}function V(e){return P.call(this,e)||this}function N(e){var t=this,n=e.material;return(t=w.call(this,l.makeCtorParameters(e,n.getParameters()))||this).updateParameters(),t}function j(e){var t=this,n=e.material.getParameters();(t=A.call(this,l.makeCtorParameters(e,n))||this).params=m.copyParameters(n);var i=t.params;return t.slot=_(i.transparent,i.writeDepth),t.technique=t.techniqueRep.acquireAndReleaseExisting(g.DefaultMaterialTechnique,t.material.getTechniqueConfig(0),t.technique),t.selectPipeline(0),t}function F(e,t){var n=C.call(this,t)||this;return n.supportsEdges=!0,n.techniqueConfig=new g.DefaultMaterialTechniqueConfiguration,n.params=m.copyParameters(e,G),n.vertexBufferLayout=F.getVertexBufferLayout(n.params),n.instanceBufferLayout=e.instanced?F.getInstanceBufferLayout(n.params):null,n}var G={textureId:void 0,initTextureTransparent:!((M||(M={})).COLOR_GAMMA=2.1),usePBR:!1,normalTextureId:void 0,vertexTangents:!1,occlusionTextureId:void 0,emissiveTextureId:void 0,metallicRoughnessTextureId:void 0,emissiveFactor:[0,0,0],metallicFactor:0,roughnessFactor:1,reflectanceFactor:.5,ambient:[.2,.2,.2],diffuse:[.8,.8,.8],specular:[0,0,0],externalColor:[1,1,1,1],colorMixMode:"multiply",opacity:1,layerOpacity:1,vertexColors:!1,symbolColors:!1,doubleSided:!1,doubleSidedType:"normal",cullFace:void 0,softwareInstanced:!1,instanced:void 0,instancedDoublePrecision:!1,normals:"default",receiveSSAO:!0,receiveShadows:!1,castShadows:!0,verticalOffset:null,screenSizePerspective:null,slicePlaneEnabled:!1,sliceHighlightDisabled:!1,offsetTransparentBackfaces:!1,vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvSizeValue:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],vvSymbolAnchor:[0,0,0],vvSymbolRotationMatrix:r.mat3f64.create(),transparent:!1,writeDepth:!0,textureAlphaMode:"blend",textureAlphaCutoff:s.TEXTURE_ALPHA_CUTOFF_DEFAULT,textureAlphaPremultiplied:!1},H=(J.prototype.allocate=function(e){return this.vertexBufferLayout.createBuffer(e)},J.prototype.elementCount=function(e){return e.indices.position.length},J.prototype.write=function(e,t,n,i){d.writeDefaultAttributes(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,n,i)},J),B=function(e){return e.transparent&&y.separateBlendingParams(770,1,771,771)},U=function(e){return((t=e).cullFace?0!==t.cullFace:!t.slicePlaneEnabled&&!t.transparent&&!t.doubleSided)&&{face:1===e.cullFace?1028:1029,mode:2305};var t},k=o.vec3f64.create(),q=o.vec3f64.create(),W=o.vec3f64.fromValues(0,0,1),Z=o.vec3f64.create(),X=o.vec3f64.create(),Y=o.vec3f64.create(),K=o.vec3f64.create();function J(e,t){this.vertexBufferLayout=e,this.instanceBufferLayout=t}return M}.apply(null,i))||(e.exports=r)},2700:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(5),n(11),n(2701),n(1740),n(1678)],void 0===(r=function(e,t,n,i,r,o,a){var s,l=(s=o.GLMaterial,i(c,s),c.prototype.dispose=function(){a.releaseIfNotUndefined(this.textureId,this.textureRep)},c.prototype.updateTexture=function(e){e!==this.textureId&&(a.releaseIfNotUndefined(this.textureId,this.textureRep),this.textureId=e,this.glTextureRef=a.acquireIfNotUndefined(this.textureId,this.textureRep,this.initTransparent))},c.prototype.bindTexture=function(e,t){null!=this.glTextureRef&&(t.setUniform1i("tex",r.DefaultTextureUnits.DIFFUSE),e.bindTexture(this.glTextureRef.getGLTexture(),r.DefaultTextureUnits.DIFFUSE)),this.glTextureRefNormal&&(t.setUniform1i("normalTexture",r.DefaultTextureUnits.NORMAL),e.bindTexture(this.glTextureRefNormal.getGLTexture(),r.DefaultTextureUnits.NORMAL)),this.glTextureRefEmission&&(t.setUniform1i("texEmission",r.DefaultTextureUnits.EMISSION),e.bindTexture(this.glTextureRefEmission.getGLTexture(),r.DefaultTextureUnits.EMISSION)),this.glTextureRefOcclusion&&(t.setUniform1i("texOcclusion",r.DefaultTextureUnits.OCCLUSION),e.bindTexture(this.glTextureRefOcclusion.getGLTexture(),r.DefaultTextureUnits.OCCLUSION)),this.glTextureRefRoughnessMetallness&&(t.setUniform1i("texMetallicRoughness",r.DefaultTextureUnits.METALLIC_ROUGHNESS),e.bindTexture(this.glTextureRefRoughnessMetallness.getGLTexture(),r.DefaultTextureUnits.METALLIC_ROUGHNESS))},c.prototype.bindTextureScale=function(e,t){var n=this.glTextureRef&&this.glTextureRef.getGLTexture();n&&n.descriptor.textureCoordinateScaleFactor?t.setUniform2fv("textureCoordinateScaleFactor",n.descriptor.textureCoordinateScaleFactor):t.setUniform2f("textureCoordinateScaleFactor",1,1)},c);function c(e){var t=s.call(this,e)||this,n=e.textureRep;t.textureRep=n,t.textureId=e.textureId,t.initTransparent=!!e.initTextureTransparent;function i(e){return a.acquireIfNotUndefined(e,n,t.initTransparent)}return t.glTextureRef=i(t.textureId),e.normalTextureId&&(t.glTextureRefNormal=i(e.normalTextureId)),e.emissiveTextureId&&(t.glTextureRefEmission=i(e.emissiveTextureId)),e.occlusionTextureId&&(t.glTextureRefOcclusion=i(e.occlusionTextureId)),e.metallicRoughnessTextureId&&(t.glTextureRefRoughnessMetallness=i(e.metallicRoughnessTextureId)),t}return(l||(l={})).makeCtorParameters=function(e,t){return n({},e,t)},l}.apply(null,i))||(e.exports=r)},2701:function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.DefaultTextureUnits={DIFFUSE:0,COMPONENT_COLOR:1,NORMAL:2,EMISSION:3,OCCLUSION:4,METALLIC_ROUGHNESS:5}}.apply(null,i))||(e.exports=r)},2702:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1),n(0),n(2)],void 0===(r=function(e,t,i,r,o){Object.defineProperty(t,"__esModule",{value:!0}),t.AutoDisposableMixin=function(e){return n=o.declared(e),i(t,n),t.prototype.dispose=function(){for(var e=this.__proto__.__managedDisposables__||[],t=e.length-1;0<=t;t--){var n=e[t];this[n]&&"function"==typeof this[n].dispose&&this[n].dispose(),this[n]=null}this._isDisposed=!0},Object.defineProperty(t.prototype,"isDisposed",{get:function(){return this._isDisposed},enumerable:!0,configurable:!0}),r([o.subclass("esri.views.3d.webgl-engine.lib.AutoDisposableMixin")],t);function t(){var e=null!==n&&n.apply(this,arguments)||this;return e._isDisposed=!1,e}var n};var n,a=(n=o.declared(t.AutoDisposableMixin(function(){})),i(s,n),r([o.subclass("esri.views.3d.webgl-engine.lib.AutoDisposable")],s));function s(){return null!==n&&n.apply(this,arguments)||this}t.AutoDisposable=a,t.autoDispose=function(){return function(e,t){e.__managedDisposables__=e.__managedDisposables__||[],e.__managedDisposables__.push(t)}}}.apply(null,i))||(e.exports=r)},2703:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(33),n(526)],void 0===(r=function(e,r,p,f){function a(e){return Math.abs(e*e*e)}function o(e,t,n,i){void 0===i&&(i=h);var r=n.parameters,o=n.paddingPixelsOverride;return i.scale=Math.min(r.divisor/(t-r.offset),1),i.factor=a(e),i.minPixelSize=r.minPixelSize,i.paddingPixels=o,i}function s(e,t){return 0===e?t.minPixelSize:t.minPixelSize*(1+2*t.paddingPixels/e)}function l(e,t){return Math.max(p.lerp(e*t.scale,e,t.factor),s(e,t))}function c(e,t,n){var i=o(e,t,n);return i.minPixelSize=0,i.paddingPixels=0,l(1,i)}Object.defineProperty(r,"__esModule",{value:!0}),r.getSettings=function(e){return new u(e,r.defaultDescription)},r.getLabelSettings=function(e){var t=r.defaultDescription.curvatureDependent,n=r.defaultDescription.scaleStart,i=r.defaultDescription.scaleFallOffRange;return new u(e,{curvatureDependent:{min:{curvature:t.min.curvature,tiltAngle:t.min.tiltAngle,scaleFallOffFactor:d.curvatureDependent.min.scaleFallOffFactor},max:{curvature:t.max.curvature,tiltAngle:t.max.tiltAngle,scaleFallOffFactor:d.curvatureDependent.max.scaleFallOffFactor}},scaleStart:n,scaleFallOffRange:i,minPixelSize:d.minPixelSize})},r.perspectiveFactor=a,r.scaleFactor=o,r.applyScaleFactor=l,r.applyScaleFactorVec2=function(e,t,n){void 0===n&&(n=[0,0]);var i=Math.min(Math.max(t.scale,s(e[1],t)/e[1]),1);return n[0]=p.lerp(e[0]*i,e[0],t.factor),n[1]=p.lerp(e[1]*i,e[1],t.factor),n},r.precomputeScale=c,r.precomputeScaleFactor=function(e,t,n,i){return i.scale=c(e,t,n),i.factor=0,i.minPixelSize=n.parameters.minPixelSize,i.paddingPixels=n.paddingPixelsOverride,i},r.applyPrecomputedScaleFactorVec2=function(e,t,n){void 0===n&&(n=[0,0]);var i=Math.min(Math.max(t.scale,s(e[1],t)/e[1]),1);return n[0]=e[0]*i,n[1]=e[1]*i,n},r.scale=function(e,t,n,i){return l(e,o(t,n,i))};var u=(Object.defineProperty(t.prototype,"paddingPixelsOverride",{get:function(){return this._paddingPixelsOverride||this.parameters.paddingPixels},enumerable:!0,configurable:!0}),t.prototype.update=function(e){return!(this.parameters&&this.parameters.camera.fovY===e.fovY&&this.parameters.camera.distance===e.distance||(this.calculateParameters(e,this.parameters),0))},t.prototype.overridePadding=function(e){return e!==this.paddingPixelsOverride?new t(this.viewingMode,this.description,this.parameters,e):this},t.prototype.calculateParameters=function(e,t){var n=this.description,i=n.scaleStart,r=n.scaleFallOffRange,o=n.minPixelSize,a=e.fovY,s=e.distance,l=this.calculateCurvatureDependentParameters(e),c=this.coverageCompensation(e,l),u=l.tiltAngle,d=l.scaleFallOffFactor,p=Math.sin(u)*s,f=.5*Math.PI-u-a*(.5-i*c),h=p/Math.cos(f),v=f+a*r*c,m=(h-d*(p/Math.cos(v)))/(1-d);return t.camera.fovY=e.fovY,t.camera.distance=e.distance,t.offset=m,t.divisor=h-m,t.minPixelSize=o,t},t.prototype.calculateCurvatureDependentParametersLocal=function(e,t){return void 0===t&&(t=v),t.tiltAngle=this.description.curvatureDependent.min.tiltAngle,t.scaleFallOffFactor=this.description.curvatureDependent.min.scaleFallOffFactor,t},t.prototype.calculateCurvatureDependentParametersGlobal=function(e,t){void 0===t&&(t=v);var n=this.description.curvatureDependent,i=1+e.distance/f.earthRadius,r=Math.sqrt(i*i-1),o=[n.min.curvature,n.max.curvature],a=o[0],s=o[1],l=p.clamp((r-a)/(s-a),0,1),c=[n.min,n.max],u=c[0],d=c[1];return t.tiltAngle=p.lerp(u.tiltAngle,d.tiltAngle,l),t.scaleFallOffFactor=p.lerp(u.scaleFallOffFactor,d.scaleFallOffFactor,l),t},t.prototype.surfaceCoverageCompensationLocal=function(e,t){return(e.fovY-t.tiltAngle)/e.fovY},t.prototype.surfaceCoverageCompensationGlobal=function(e,t){var n=f.earthRadius*f.earthRadius,i=t.tiltAngle+.5*Math.PI,r=e.fovY,o=e.distance,a=o*o+n-2*Math.cos(i)*o*f.earthRadius,s=Math.sqrt(a),l=Math.sqrt(a-n);return(Math.acos(l/s)-Math.asin(f.earthRadius/(s/Math.sin(i)))+.5*r)/r},t);function t(e,t,n,i){void 0===n&&(n={camera:{distance:0,fovY:0},divisor:0,offset:0,minPixelSize:0,paddingPixels:0}),this.viewingMode=e,this.description=t,this.parameters=n,this._paddingPixelsOverride=i,"local"===this.viewingMode?(this.coverageCompensation=this.surfaceCoverageCompensationLocal,this.calculateCurvatureDependentParameters=this.calculateCurvatureDependentParametersLocal):(this.coverageCompensation=this.surfaceCoverageCompensationGlobal,this.calculateCurvatureDependentParameters=this.calculateCurvatureDependentParametersGlobal)}r.defaultDescription={curvatureDependent:{min:{curvature:p.deg2rad(10),tiltAngle:p.deg2rad(12),scaleFallOffFactor:.5},max:{curvature:p.deg2rad(70),tiltAngle:p.deg2rad(40),scaleFallOffFactor:.8}},scaleStart:.3,scaleFallOffRange:.65,minPixelSize:0};var d={curvatureDependent:{min:{scaleFallOffFactor:.7},max:{scaleFallOffFactor:.95}},minPixelSize:14};r.copyParameters=function(e,t){return t.camera.distance=e.camera.distance,t.camera.fovY=e.camera.fovY,t.divisor=e.divisor,t.offset=e.offset,t.minPixelSize=e.minPixelSize,t};var h={scale:0,factor:0,minPixelSize:0,paddingPixels:0},v={tiltAngle:0,scaleFallOffFactor:0}}.apply(null,i))||(e.exports=r)},2704:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1633),n(1764),n(1704),n(1969),n(1970),n(328),n(507),n(329)],void 0===(r=function(e,t,c,u,r,d,p,f,h,v){function s(e,t){function n(e,t){var n=e.origin.id,i=e.data.id,r=a.get(n);r||(r={origin:e.origin.vec3,deltaByGeometry:new Map},a.set(n,r));var o=r.deltaByGeometry.get(i);o||(o={renderData:e.data,toAdd:[],toRemove:[]},r.deltaByGeometry.set(i,o)),(t?o.toAdd:o.toRemove).push(e)}var a=new Map;return e.forEach(function(e){n(e,!0)}),t.forEach(function(e){n(e,!1)}),a}function m(e,t,n){var i=t.elementCount(e),r=t.allocate(i);t.write({},e,r,0),n.setData(r.buffer)}return n.prototype.dispose=function(){p.releaseMaterials(this._material,this._materialRep)},Object.defineProperty(n.prototype,"isEmpty",{get:function(){return 0===this._dataByOrigin.size},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"hasHighlights",{get:function(){return 0<this._highlightCount},enumerable:!0,configurable:!0}),n.prototype.hasWater=function(){return!1},n.prototype.renderPriority=function(){return this._material.renderPriority},n.prototype.modify=function(e){this.updateGeometries(e.toUpdate),this.addAndRemoveGeometries(e.toAdd,e.toRemove),this.updateHighlightCount()},n.prototype.addAndRemoveGeometries=function(e,t){var n=this,i=this._rctx,r=this._bufferWriter,o=this._dataByOrigin,a=s(e,t),l=r.vertexBufferLayout;a.forEach(function(e,t){var s=o.get(t);s||(s={origin:e.origin,highlightCount:0,dataByGeometry:new Map},o.set(t,s)),e.deltaByGeometry.forEach(function(e,t){var o=s.dataByGeometry.get(t);!o&&0<e.toAdd.length&&(o={vao:new v(i,n._vertexAttributeLocations,{geometry:u.glLayout(l)},{geometry:f.createVertex(i,35044)}),vertexCount:0,instances:new Map,highlightCount:0},m(e.renderData,r,o.vao.vertexBuffers.geometry),o.vertexCount=h.vertexCount(o.vao,"geometry"),s.dataByGeometry.set(t,o));var a=o.instances;e.toAdd.forEach(function(e){var t=c.mat4f64.create();p.calculateTransformRelToOrigin(e,t);var n=p.generateRenderGeometryVisibleIndexRanges(e),i=p.generateRenderGeometryHighlightRanges(e),r=new d(e.name,0,o.vertexCount,n,i,t,e.instanceParameters,e.idx,e.data.id);a.set(e.uniqueName,r),s.highlightCount=null,o.highlightCount=null}),e.toRemove.forEach(function(e){a.delete(e.uniqueName)}),0===a.size&&(o.vao.dispose(),s.dataByGeometry.delete(t))}),0===s.dataByGeometry.size&&o.delete(t)})},n.prototype.updateGeometries=function(e){var a=this._dataByOrigin,s=this._bufferWriter;e.forEach(function(e){var t=e.updateType,n=e.renderGeometry,i=a.get(n.origin.id),r=i&&i.dataByGeometry.get(n.data.id),o=r&&r.instances.get(n.uniqueName);o&&(1&t&&(o.displayedIndexRange=p.generateRenderGeometryVisibleIndexRanges(n)),17&t&&(o.highlightedIndexRanges=p.generateRenderGeometryHighlightRanges(n),i.highlightCount=null,r.highlightCount=null),2&t&&m(n.data,s,r.vao.vertexBuffers.geometry),4&t&&p.calculateTransformRelToOrigin(n,o.transformation,o.transformationNormal))})},n.prototype.updateHighlightCount=function(){var t=this;this._highlightCount=0,this._dataByOrigin.forEach(function(e){if(null==e.highlightCount){var n=0;e.dataByGeometry.forEach(function(e){if(null==e.highlightCount){var t=0;e.instances.forEach(function(e){e.highlightedIndexRanges&&++t}),e.highlightCount=t}n+=e.highlightCount}),e.highlightCount=n}t._highlightCount+=e.highlightCount})},n.prototype.render=function(e,t,n,i){var r=this,o=this._rctx,a=this._glMaterials.get(t.pass),s=4===t.pass;if(!a||null!=e&&!a.beginSlot(e)||s&&0===this._highlightCount)return!1;a.bind(o,n);var l=!1;return this._dataByOrigin.forEach(function(e){s&&0===e.highlightCount||(n.origin=e.origin,a.bindView(n),e.dataByGeometry.forEach(function(e){l=s?r.renderHighlightPass(a,e,i)||l:r.renderDefaultPass(a,e,i)||l}))}),o.bindVAO(null),a.release(),l},n.prototype.renderDefaultPass=function(n,e,i){var r=this._rctx,o=n.getDrawMode(),t=e.vao,a=e.vertexCount;n.ensureAttributeLocations(t),r.bindVAO(t);var s=!1;return e.instances.forEach(function(e){var t=e.displayedIndexRange;t&&0===t.length||(n.bindInstance(e),t?p.drawArraysFaceRange(r,t,0,o,i):p.drawArrays(r,o,0,a,i),s=!0)}),s},n.prototype.renderHighlightPass=function(a,e,s){var l=this._rctx,c=a.getDrawMode(),t=e.vao,u=e.vertexCount;if(0!==e.highlightCount){a.ensureAttributeLocations(t),l.bindVAO(t);var d=!1;return e.instances.forEach(function(e){var t=e.highlightedIndexRanges;if(t&&0!==t.length){a.bindInstance(e);for(var n=0;n<t.length;n++){var i=t[n],r=i.range?i.range[0]:0,o=i.range?i.range[1]-i.range[0]+1:u;p.drawArrays(l,c,r,o,s),d=!0}}}),d}},n;function n(e,t,n,i){void 0===i&&(i=r.Default3D),this.type="InstancedRenderer",this._dataByOrigin=new Map,this._highlightCount=0,this._rctx=e,this._vertexAttributeLocations=i,this._material=n,this._materialRep=t,this._glMaterials=p.acquireMaterials(this._material,this._materialRep),this._bufferWriter=n.createBufferWriter()}}.apply(null,i))||(e.exports=r)},2705:function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=function(e,t){return n.copyIntervals=function(e){for(var t=[],n=0;n<e.length;n++){var i=e[n];t.push([i[0],i[1]])}return t},n.convertFaceToIndexRange=function(e,t){for(var n=0;n<e.length;n++){var i=e[n];i[0]=i[0]*t,i[1]=i[1]*t+(t-1)}},n.sortIntervals=function(e){return e.sort(function(e,t){return e[0]===t[0]?e[1]>t[1]?1:e[1]<t[1]?-1:0:e[0]>t[0]?1:e[0]<t[0]?-1:0})},n.intersectIntervals=function(e,t){if(e.length<=0)return[];for(var n=[],i=0;i<e.length;i++){var r=e[i];if(!(r[1]<t[0]||r[0]>t[1])){var o=[r[0],r[1]];o[0]<t[0]&&(o[0]=t[0]),o[1]>t[1]&&(o[1]=t[1]),n.push(o)}}return n},n.mergeIntervals=function(e){if(e.length<=0)return[];var t=[];e=this.sortIntervals(e),t.push(e[0]);for(var n=1;n<e.length;n++){var i=t[t.length-1];i[1]+1<e[n][0]?t.push(e[n]):i[1]<e[n][1]&&(i[1]=e[n][1],t.pop(),t.push(i))}return t},n.invertIntervals=function(e,t){for(var n=[],i=0,r=0;r<e.length;r++){var o=e[r];o[0]>i&&n.push([i,o[0]-1]),i=o[1]+1}return i<=t&&n.push([i,t]),n},n.offsetIntervals=function(e,t){for(var n=[],i=0;i<e.length;i++){var r=e[i];n.push([r[0]+t,r[1]+t])}return n},n;function n(){}}.apply(null,i))||(e.exports=r)},2706:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(33)],void 0===(r=function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var i=(r.prototype.resize=function(e,t){if(this._size=e,this._size>this._array.length){for(var n=this._array.length||1;n<this._size;)n*=2;var i=new Float32Array(n);return t&&i.set(this._array),this._array=i,!0}var r=2*this._size;if(r<=this._array.length){for(n=this._array.length;r<=n;)n=Math.floor(n/2);return i=new Float32Array(n),t&&i.set(this._array.subarray(0,n)),this._array=i,!0}return!1},r.prototype.append=function(e){var t=this._size;this.resize(this._size+e.length,!0),this._array.set(e,t)},r.prototype.erase=function(e,t){for(var n=e;n<t;++n)this._array[n]=0},Object.defineProperty(r.prototype,"array",{get:function(){return this._array},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"size",{get:function(){return this._size},enumerable:!0,configurable:!0}),r);function r(e){null==e?e=16:e<65536&&(e=n.nextHighestPowerOfTwo(e)),this._array=new Float32Array(e),this._size=0}t.ResizableFloat32Array=i}.apply(null,i))||(e.exports=r)},2707:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(11),n(1740),n(2708),n(1678),n(2715)],void 0===(r=function(e,t,n,i,r,o,a){Object.defineProperty(t,"__esModule",{value:!0});var s,l=(s=i.GLMaterial,n(c,s),c.prototype.updateParameters=function(){this.params=o.copyParameters(this.material.getParameters()),this.selectProgram(0)},c.prototype.selectProgram=function(e){this.techniqueConfig.output=e,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig.receiveShadows=this.params.receiveShadows,this.techniqueConfig.slice=this.params.slicePlaneEnabled,this.techniqueConfig.transparent=this.params.transparent,this.technique=this.techniqueRep.acquireAndReleaseExisting(r.WaterTechnique,this.techniqueConfig,this.technique)},c.prototype.beginSlot=function(e){var t=4;return this.params.transparent&&(t=this.params.writeDepth?6:9),e===t},c.prototype.getProgram=function(){return this.technique.program},c.prototype.getPrograms=function(){return null},c.prototype._initTextures=function(e){this.texturePaths=[this.params.waveTexture,this.params.perturbationTexture],a.waterTextureRepo.initialize(e,this.texturePaths)},c.prototype._setWaveUniforms=function(e){e.setUniform1i("texWaveNormal",0),e.setUniform1i("texWavePerturbation",1),e.setUniform4f("waveParams",this.params.waveStrength,this.params.waveTextureRepeat,this.params.flowStrength,this.params.flowOffset),e.setUniform2f("waveDirection",this.params.waveDirection[0]*this.params.waveVelocity,this.params.waveDirection[1]*this.params.waveVelocity);var t=.001*this.material.animation.time;e.setUniform1f("timeElapsed",t*this.params.animationSpeed)},c.prototype._updateShadowState=function(e){e.shadowMappingEnabled!==this.params.receiveShadows&&(this.material.setParameterValues({receiveShadows:e.shadowMappingEnabled}),this.updateParameters())},c.prototype.ensureResources=function(e){return a.waterTextureRepo.ready()||a.waterTextureRepo.loading()||this._initTextures(e),a.waterTextureRepo.ready()?2:1},c.prototype.bind=function(e,t){a.waterTextureRepo.ready()&&(this._updateShadowState(t),e.bindProgram(this.technique.program),e.setPipelineState(this.technique.pipeline),a.waterTextureRepo.bindRepo(e),this.technique.program.setUniform4fv("waterColor",this.params.color),this._setWaveUniforms(this.technique.program))},c.prototype.release=function(){},c.prototype.bindView=function(e){var t=this.technique.program;t.setUniform3fv("localOrigin",e.origin),o.bindView(e.origin,e.view,t),o.bindCamPos(e.origin,e.viewInvTransp,t),this.params.slicePlaneEnabled&&o.bindSlicePlane(e.origin,e.slicePlane,t),e.shadowMappingEnabled&&(e.shadowMap.bind(t),e.shadowMap.bindView(t,e.origin))},c.prototype.bindInstance=function(e){this.technique.program.setUniformMatrix4fv("model",e.transformation)},c.prototype.getDrawMode=function(){return 4},c);function c(e){var t=s.call(this,e)||this;return t.techniqueConfig=new r.WaterTechniqueConfiguration,t.updateParameters(),t}t.WaterGLMaterial=l;var u,d=(n(p,u=l),p.prototype.updateParameters=function(){this.params=o.copyParameters(this.material.getParameters()),this.selectProgram(5)},p.prototype.bind=function(e){e.bindProgram(this.technique.program),e.setPipelineState(this.technique.pipeline),this.technique.program.setUniform4fv("waterColor",this.params.color)},p.prototype.bindView=function(e){this.technique.program.setUniform3fv("localOrigin",e.origin),o.bindView(e.origin,e.view,this.technique.program)},p.prototype.beginSlot=function(e){return null==e},p);function p(){return null!==u&&u.apply(this,arguments)||this}t.WaterDrapedGLMaterial=d;var f,h=(n(v,f=l),v.prototype.updateParameters=function(){this.params=o.copyParameters(this.material.getParameters()),this.selectProgram(2)},v.prototype.bind=function(e){a.waterTextureRepo.ready()&&(e.bindProgram(this.technique.program),e.setPipelineState(this.technique.pipeline),a.waterTextureRepo.bindRepo(e),this._setWaveUniforms(this.technique.program))},v.prototype.bindView=function(e){this.technique.program.setUniform3fv("localOrigin",e.origin),o.bindView(e.origin,e.view,this.technique.program)},v.prototype.beginSlot=function(e){return 19===e},v);function v(){return null!==f&&f.apply(this,arguments)||this}t.WaterNormalGLMaterial=h}.apply(null,i))||(e.exports=r)},2708:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(11),n(0),n(5),n(1741),n(1742),n(1743),n(1704),n(2709),n(314),n(502)],void 0===(r=function(e,t,n,i,r,o,a,s,l,c,u,d){Object.defineProperty(t,"__esModule",{value:!0});var p,f=(p=a.ShaderTechnique,n(h,p),h.prototype.initializeProgram=function(e){var t=h.shader.get(),n=this.configuration,i=t.build({output:n.output,viewingMode:e.viewingMode,slicePlaneEnabled:n.slice,sliceHighlightDisabled:!1,receiveShadows:n.receiveShadows,usePBR:!1,usePBRforWater:!0,useCustomDTRExponentForWater:!0});return new u(e.rctx,i.generateSource("vertex"),i.generateSource("fragment"),l.Default3D)},h.prototype.initializePipeline=function(){var e=this.configuration;return 2===e.output?d.makePipelineState({depthTest:{func:513},depthWrite:e.writeDepth&&d.defaultDepthWriteParams,colorWrite:d.defaultColorWriteParams}):d.makePipelineState({blending:e.transparent&&d.separateBlendingParams(770,1,771,771),depthTest:{func:513},depthWrite:e.writeDepth&&d.defaultDepthWriteParams,colorWrite:d.defaultColorWriteParams})},h.prototype.bindPipelineState=function(e){e.setPipelineState(this.pipeline)},h.shader=new o.ReloadableShaderModule(c,"../shaders/WaterSurface.glsl",e),h);function h(){return null!==p&&p.apply(this,arguments)||this}t.WaterTechnique=f;var v,m=(v=s.ShaderTechniqueConfiguration,n(g,v),i([s.parameter({count:6})],g.prototype,"output",void 0),i([s.parameter()],g.prototype,"receiveShadows",void 0),i([s.parameter()],g.prototype,"slice",void 0),i([s.parameter()],g.prototype,"transparent",void 0),i([s.parameter()],g.prototype,"writeDepth",void 0),g);function g(){var e=null!==v&&v.apply(this,arguments)||this;return e.output=0,e.receiveShadows=!1,e.slice=!1,e.transparent=!1,e.writeDepth=!1,e}t.WaterTechniqueConfiguration=m}.apply(null,i))||(e.exports=r)},2709:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1971),n(1679),n(1693),n(2710),n(1854),n(2711),n(2714),n(1629),n(1744)],void 0===(r=function(e,t,n,i,r,o,a,s,l,c,u,d){var p,f,h,v,m,g,y,b,_;Object.defineProperty(t,"__esModule",{value:!0}),t.build=function(e){var t=new d.ShaderBuilder;return t.include(o.Transform,{linearDepth:!1}),t.attributes.add("position","vec3"),t.attributes.add("uv0","vec2"),t.vertex.uniforms.add("proj","mat4").add("view","mat4").add("model","mat4").add("localOrigin","vec3"),0===e.output&&(t.include(a.NormalUtils,e),t.include(i.ForwardLinearDepth,e),t.varyings.add("vuv","vec2"),t.varyings.add("vpos","vec3"),t.varyings.add("vnormal","vec3"),t.varyings.add("vtbnMatrix","mat3"),t.vertex.code.add(u.glsl(p=p||n(["\n      void main(void) {\n        vuv = uv0;\n        vpos = (model * vec4(position, 1.0)).xyz;\n\n        vnormal = getLocalUp(vpos, localOrigin);\n        vtbnMatrix = getTBNMatrix(vnormal);\n\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardLinearDepth();\n      }\n    "],["\n      void main(void) {\n        vuv = uv0;\n        vpos = (model * vec4(position, 1.0)).xyz;\n\n        vnormal = getLocalUp(vpos, localOrigin);\n        vtbnMatrix = getTBNMatrix(vnormal);\n\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardLinearDepth();\n      }\n    "]))),t.include(c.WaterDistortion,e),t.include(r.Slice,e),e.receiveShadows&&t.include(s.ReadShadowMap,e),t.include(l.Water,e),t.fragment.uniforms.add("waterColor","vec4").add("lightingMainDirection","vec3").add("lightingMainIntensity","vec3").add("camPos","vec3").add("timeElapsed","float"),t.fragment.code.add(u.glsl(f=f||n(["\n      void main() {\n        discardBySlice(vpos);\n        vec3 localUp = vnormal;\n        // the created normal is in tangent space\n        vec3 tangentNormal = getSurfaceNormal(vuv, timeElapsed);\n\n        // we rotate the normal according to the tangent-bitangent-normal-Matrix\n        vec3 n = normalize(vtbnMatrix * tangentNormal);\n        vec3 v = -normalize(vpos - camPos);\n        vec3 l = normalize(-lightingMainDirection);\n        "],["\n      void main() {\n        discardBySlice(vpos);\n        vec3 localUp = vnormal;\n        // the created normal is in tangent space\n        vec3 tangentNormal = getSurfaceNormal(vuv, timeElapsed);\n\n        // we rotate the normal according to the tangent-bitangent-normal-Matrix\n        vec3 n = normalize(vtbnMatrix * tangentNormal);\n        vec3 v = -normalize(vpos - camPos);\n        vec3 l = normalize(-lightingMainDirection);\n        "]))),e.receiveShadows?t.fragment.code.add(u.glsl(h=h||n(["\n        float shadow = 1.0 - readShadowMap(vpos, linearDepth);\n      "],["\n        float shadow = 1.0 - readShadowMap(vpos, linearDepth);\n      "]))):t.fragment.code.add(u.glsl(v=v||n(["\n        float shadow = 1.0;\n      "],["\n        float shadow = 1.0;\n      "]))),t.fragment.code.add(u.glsl(m=m||n(["\n        vec4 final = vec4(getSeaColor(n, v, l, waterColor.rgb, lightingMainIntensity, localUp, shadow), waterColor.w);\n\n        // gamma correction\n        gl_FragColor = delinearizeGamma(final);\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "],["\n        vec4 final = vec4(getSeaColor(n, v, l, waterColor.rgb, lightingMainIntensity, localUp, shadow), waterColor.w);\n\n        // gamma correction\n        gl_FragColor = delinearizeGamma(final);\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "])))),2===e.output&&(t.include(a.NormalUtils,e),t.include(c.WaterDistortion,e),t.include(r.Slice,e),t.varyings.add("vpos","vec3"),t.varyings.add("vuv","vec2"),t.vertex.code.add(u.glsl(g=g||n(["\n        void main(void) {\n          vuv = uv0;\n          vpos = (model * vec4(position, 1.0)).xyz;\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "],["\n        void main(void) {\n          vuv = uv0;\n          vpos = (model * vec4(position, 1.0)).xyz;\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "]))),t.fragment.uniforms.add("timeElapsed","float"),t.fragment.code.add(u.glsl(y=y||n(["\n        void main() {\n          discardBySlice(vpos);\n          // the created normal is in tangent space\n          vec3 tangentNormal = getSurfaceNormal(vuv, timeElapsed);\n          tangentNormal = normalize(tangentNormal);\n          gl_FragColor = vec4((tangentNormal + vec3(1.0)) * 0.5, 0.0);\n        }\n    "],["\n        void main() {\n          discardBySlice(vpos);\n          // the created normal is in tangent space\n          vec3 tangentNormal = getSurfaceNormal(vuv, timeElapsed);\n          tangentNormal = normalize(tangentNormal);\n          gl_FragColor = vec4((tangentNormal + vec3(1.0)) * 0.5, 0.0);\n        }\n    "])))),5===e.output&&(t.include(a.NormalUtils,e),t.varyings.add("vpos","vec3"),t.vertex.code.add(u.glsl(b=b||n(["\n        void main(void) {\n          vpos = (model * vec4(position, 1.0)).xyz;\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "],["\n        void main(void) {\n          vpos = (model * vec4(position, 1.0)).xyz;\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "]))),t.fragment.uniforms.add("waterColor","vec4"),t.fragment.code.add(u.glsl(_=_||n(["\n        void main() {\n          gl_FragColor = waterColor;\n        }\n    "],["\n        void main() {\n          gl_FragColor = waterColor;\n        }\n    "])))),t}}.apply(null,i))||(e.exports=r)},2710:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r,o,a,s;Object.defineProperty(t,"__esModule",{value:!0}),t.NormalUtils=function(e,t){0===t.viewingMode?e.vertex.code.add(i.glsl(r=r||n(["\n      vec3 getLocalUp(in vec3 pos, in vec3 origin) {\n          return normalize(pos + origin);\n      }\n    "],["\n      vec3 getLocalUp(in vec3 pos, in vec3 origin) {\n          return normalize(pos + origin);\n      }\n    "]))):e.vertex.code.add(i.glsl(o=o||n(["\n      vec3 getLocalUp(in vec3 pos, in vec3 origin) {\n          return vec3(0.0, 0.0, 1.0); // WARNING: up-axis dependent code\n      }\n    "],["\n      vec3 getLocalUp(in vec3 pos, in vec3 origin) {\n          return vec3(0.0, 0.0, 1.0); // WARNING: up-axis dependent code\n      }\n    "]))),0===t.viewingMode?e.vertex.code.add(i.glsl(a=a||n(["\n        mat3 getTBNMatrix(in vec3 n) {\n            vec3 t = normalize(cross(vec3(0.0, 0.0, 1.0), n));\n            vec3 b = normalize(cross(n, t));\n            return mat3(t, b, n);\n        }\n    "],["\n        mat3 getTBNMatrix(in vec3 n) {\n            vec3 t = normalize(cross(vec3(0.0, 0.0, 1.0), n));\n            vec3 b = normalize(cross(n, t));\n            return mat3(t, b, n);\n        }\n    "]))):e.vertex.code.add(i.glsl(s=s||n(["\n        mat3 getTBNMatrix(in vec3 n) {\n            vec3 t = vec3(1.0, 0.0, 0.0);\n            vec3 b = normalize(cross(n, t));\n            return mat3(t, b, n);\n        }\n    "],["\n        mat3 getTBNMatrix(in vec3 n) {\n            vec3 t = vec3(1.0, 0.0, 0.0);\n            vec3 b = normalize(cross(n, t));\n            return mat3(t, b, n);\n        }\n    "])))}}.apply(null,i))||(e.exports=r)},2711:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(2712),n(1855),n(1629)],void 0===(r=function(e,t,n,i,r,o){var a;Object.defineProperty(t,"__esModule",{value:!0}),t.Water=function(e,t){e.include(r.PhysicallyBasedRendering,t),e.include(i.Gamma),e.fragment.code.add(o.glsl(a=a||n(["\n    const vec3 fresnelSky =  vec3(0.02, 1.0, 5.0); // f0, f0max, exp\n    const vec2 fresnelMaterial =  vec2(0.02, 0.1); // f0, f0max for specular term\n    const float roughness = 0.06;\n\n    const vec3 skyZenitColor = vec3(0, 0.6, 0.9);\n    const vec3 skyColor = vec3(0.72, 0.92, 1.0);\n\n    PBRShadingWater shadingInfo;\n\n    /*\n    *   This function is an approximation for the sky gradient reflected\n    *   the water surface and describes a combination of two fresnel terms.\n    *   @parameter: cosTheta = is the result of max(dot(n,v), 0.0)\n    *   @parameter: horizon = the dominant color of the sky horizon\n    *   @parameter: cosTheta = the dominant color of the sky zenit\n    */\n    vec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {\n      float exponent = pow((1.0 - cosTheta), fresnelSky[2]);\n      return mix(zenit, horizon, exponent);\n    }\n\n    /*\n    *   This function determines the water color per pixel.\n    *   @parameter: n = normal facing away from the surface\n    *   @parameter: v = view direction facing away from the surface.\n    *   @parameter: l = light direction facing away from the surface\n    *   @parameter: lightIntensity = light intensity, currently between 0...PI\n    *   @parameter: localUp = a normal for the general direction of the surface\n    *   @parameter: shadow = the amount of shadow at this pixel (0 = no shadow)\n    */\n    vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow) {\n\n      vec3 seaWaterColor = linearizeGamma(color);\n      // using half vector to determine the specular light\n      vec3 h = normalize(l + v);\n      shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);\n      shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);\n      shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);\n      shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);\n      shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);\n      shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);\n\n      // angle between vertex normal and view direction\n      float upDotV = max(dot(localUp,v), 0.0);\n      // reflected sky color: the reflected sky color consists of two main colors, the\n      // reflected color at the horizon and the reflected color of the zenit.\n      // the reflected sky color is then an approximation based on the fresnel term.\n      vec3 skyHorizon = linearizeGamma(skyColor);\n      vec3 skyZenit = linearizeGamma(skyZenitColor);\n      vec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );\n\n      // we use the upDotL to smoothen out the\n      // reflected color of the water\n      float upDotL = max(dot(localUp,l),0.0);\n\n      // The approximated sky color is adjusted according to the sun position.\n      // This is done as approximation for e.g. night views.\n      skyColor *= 0.1 + upDotL * 0.9;\n\n      // If a water surface is in shadow we just use a slight darkening of the\n      // water surface expressed with this shadowModifier.\n      float shadowModifier = clamp(shadow, 0.8, 1.0);\n\n      // The reflected sky color consists of the fresnel reflection multiplied with the approximated sky color.\n      // The shadow is influencing the frensel term to keep the shadow impression for really near views. As long\n      // as reflection are absent there is a need to have a slight shadow for depth perception.\n      vec3 reflSky = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]) * skyColor * shadowModifier;\n\n      // The reflected sea color is the input water color combined with the reflected sky color.\n      // The reflected sky color is modified by the incoming light.\n      vec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;\n\n      vec3 specular = vec3(0.0);\n      // This prevents the specular light to be rendered when:\n      // - sun is behind a polygon (e.g. sundown for elevated polygons where nDotL might be still ok)\n      // - viewer is under water (for this localUp is better than n)\n      if(upDotV > 0.0 && upDotL > 0.0) {\n        // calculate the cook torrance BRDF but with simplified occlusion\n        vec3 specularSun = brdfWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);\n        // Normalize light intensity to be between 0...1. Shadow cancels out specular light here\n        vec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;\n\n        specular = shadingInfo.NdotL * incidentLight * specularSun;\n      }\n      // combining reflected sky, reflected sea and specular highlight.\n      return tonemapACES(reflSky + reflSea + specular);\n    }\n  "],["\n    const vec3 fresnelSky =  vec3(0.02, 1.0, 5.0); // f0, f0max, exp\n    const vec2 fresnelMaterial =  vec2(0.02, 0.1); // f0, f0max for specular term\n    const float roughness = 0.06;\n\n    const vec3 skyZenitColor = vec3(0, 0.6, 0.9);\n    const vec3 skyColor = vec3(0.72, 0.92, 1.0);\n\n    PBRShadingWater shadingInfo;\n\n    /*\n    *   This function is an approximation for the sky gradient reflected\n    *   the water surface and describes a combination of two fresnel terms.\n    *   @parameter: cosTheta = is the result of max(dot(n,v), 0.0)\n    *   @parameter: horizon = the dominant color of the sky horizon\n    *   @parameter: cosTheta = the dominant color of the sky zenit\n    */\n    vec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {\n      float exponent = pow((1.0 - cosTheta), fresnelSky[2]);\n      return mix(zenit, horizon, exponent);\n    }\n\n    /*\n    *   This function determines the water color per pixel.\n    *   @parameter: n = normal facing away from the surface\n    *   @parameter: v = view direction facing away from the surface.\n    *   @parameter: l = light direction facing away from the surface\n    *   @parameter: lightIntensity = light intensity, currently between 0...PI\n    *   @parameter: localUp = a normal for the general direction of the surface\n    *   @parameter: shadow = the amount of shadow at this pixel (0 = no shadow)\n    */\n    vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow) {\n\n      vec3 seaWaterColor = linearizeGamma(color);\n      // using half vector to determine the specular light\n      vec3 h = normalize(l + v);\n      shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);\n      shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);\n      shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);\n      shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);\n      shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);\n      shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);\n\n      // angle between vertex normal and view direction\n      float upDotV = max(dot(localUp,v), 0.0);\n      // reflected sky color: the reflected sky color consists of two main colors, the\n      // reflected color at the horizon and the reflected color of the zenit.\n      // the reflected sky color is then an approximation based on the fresnel term.\n      vec3 skyHorizon = linearizeGamma(skyColor);\n      vec3 skyZenit = linearizeGamma(skyZenitColor);\n      vec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );\n\n      // we use the upDotL to smoothen out the\n      // reflected color of the water\n      float upDotL = max(dot(localUp,l),0.0);\n\n      // The approximated sky color is adjusted according to the sun position.\n      // This is done as approximation for e.g. night views.\n      skyColor *= 0.1 + upDotL * 0.9;\n\n      // If a water surface is in shadow we just use a slight darkening of the\n      // water surface expressed with this shadowModifier.\n      float shadowModifier = clamp(shadow, 0.8, 1.0);\n\n      // The reflected sky color consists of the fresnel reflection multiplied with the approximated sky color.\n      // The shadow is influencing the frensel term to keep the shadow impression for really near views. As long\n      // as reflection are absent there is a need to have a slight shadow for depth perception.\n      vec3 reflSky = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]) * skyColor * shadowModifier;\n\n      // The reflected sea color is the input water color combined with the reflected sky color.\n      // The reflected sky color is modified by the incoming light.\n      vec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;\n\n      vec3 specular = vec3(0.0);\n      // This prevents the specular light to be rendered when:\n      // - sun is behind a polygon (e.g. sundown for elevated polygons where nDotL might be still ok)\n      // - viewer is under water (for this localUp is better than n)\n      if(upDotV > 0.0 && upDotL > 0.0) {\n        // calculate the cook torrance BRDF but with simplified occlusion\n        vec3 specularSun = brdfWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);\n        // Normalize light intensity to be between 0...1. Shadow cancels out specular light here\n        vec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;\n\n        specular = shadingInfo.NdotL * incidentLight * specularSun;\n      }\n      // combining reflected sky, reflected sea and specular highlight.\n      return tonemapACES(reflSky + reflSea + specular);\n    }\n  "])))}}.apply(null,i))||(e.exports=r)},2712:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.Gamma=function(e){e.fragment.code.add(i.glsl(r=r||n(["\n    const float GAMMA = 2.2;\n    const float INV_GAMMA = 0.4545454545; // 1 / GAMMA\n\n    // gamma correction\n    vec4 delinearizeGamma(vec4 color) {\n      return vec4(pow(color.rgb, vec3(INV_GAMMA)), color.w);\n    }\n\n    vec3 linearizeGamma(vec3 color) {\n      return pow(color, vec3(GAMMA));\n    }\n    "],["\n    const float GAMMA = 2.2;\n    const float INV_GAMMA = 0.4545454545; // 1 / GAMMA\n\n    // gamma correction\n    vec4 delinearizeGamma(vec4 color) {\n      return vec4(pow(color.rgb, vec3(INV_GAMMA)), color.w);\n    }\n\n    vec3 linearizeGamma(vec3 color) {\n      return pow(color, vec3(GAMMA));\n    }\n    "])))}}.apply(null,i))||(e.exports=r)},2713:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r,o,a;Object.defineProperty(t,"__esModule",{value:!0}),t.AnalyticalSkyModel=function(e){var t=e.fragment.code;t.add(i.glsl(r=r||n(["\n    vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG)\n    {\n      return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;\n    }\n    "],["\n    vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG)\n    {\n      return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;\n    }\n    "]))),t.add(i.glsl(o=o||n(["\n    float integratedRadiance(float cosTheta2, float roughness)\n    {\n      return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);\n    }\n    "],["\n    float integratedRadiance(float cosTheta2, float roughness)\n    {\n      return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);\n    }\n    "]))),t.add(i.glsl(a=a||n(["\n    vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness)\n    {\n      float cosTheta2 = 1.0 - RdotNG * RdotNG;\n      float intRadTheta = integratedRadiance(cosTheta2, roughness);\n\n      // Calculate the integrated directional radiance of the ground and the sky\n      float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;\n      float sky = 2.0 - ground;\n      return (ground * ambientGround + sky * ambientSky) * 0.5;\n    }\n    "],["\n    vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness)\n    {\n      float cosTheta2 = 1.0 - RdotNG * RdotNG;\n      float intRadTheta = integratedRadiance(cosTheta2, roughness);\n\n      // Calculate the integrated directional radiance of the ground and the sky\n      float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;\n      float sky = 2.0 - ground;\n      return (ground * ambientGround + sky * ambientSky) * 0.5;\n    }\n    "])))}}.apply(null,i))||(e.exports=r)},2714:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.WaterDistortion=function(e){e.fragment.uniforms.add("texWaveNormal","sampler2D"),e.fragment.uniforms.add("texWavePerturbation","sampler2D"),e.fragment.uniforms.add("octaveTextureRepeat","vec3"),e.fragment.uniforms.add("waveParams","vec4"),e.fragment.uniforms.add("waveDirection","vec2"),e.fragment.code.add(i.glsl(r=r||n(["\n      // uniform vec3 octaveTextureRepeat;\n\n      // // 0: waveStrength\n      // // 1: waveTextureRepeat\n      // // 2: flowStrength\n      // // 3: flowOffset\n      // uniform vec4 waveParams;\n\n      // uniform vec2 waveDirection;\n\n      const vec2  FLOW_JUMP = vec2(6.0/25.0, 5.0/24.0);\n\n      vec2 textureDenormalized2D(sampler2D _tex, vec2 _uv) {\n        return 2.0 * texture2D(_tex, _uv).rg - 1.0;\n      }\n\n      float sampleNoiseTexture(vec2 _uv) {\n        return texture2D(texWavePerturbation, _uv).b;\n      }\n\n      vec3 textureDenormalized3D(sampler2D _tex, vec2 _uv) {\n        return 2.0 * texture2D(_tex, _uv).rgb - 1.0;\n      }\n\n      float computeProgress(vec2 uv, float time) {\n        return fract(time);\n      }\n\n      float computeWeight(vec2 uv, float time) {\n        float progress = computeProgress(uv, time);\n        return 1.0 - abs(1.0 - 2.0 * progress);\n      }\n\n      vec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, float time, float phaseOffset) {\n        float flowStrength = waveParams[2];\n        float flowOffset = waveParams[3];\n\n        vec2 flowVector = textureDenormalized2D(texFlow, uv) * flowStrength;\n\n        float progress = computeProgress(uv, time + phaseOffset);\n        float weight = computeWeight(uv, time + phaseOffset);\n\n        vec2 result = uv;\n        result -= flowVector * (progress + flowOffset);\n        result += phaseOffset;\n        result += (time - progress) * FLOW_JUMP;\n\n        return vec3(result, weight);\n      }\n\n      const float TIME_NOISE_TEXTURE_REPEAT = 0.3737;\n      const float TIME_NOISE_STRENGTH = 7.77;\n\n      vec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {\n        float waveStrength = waveParams[0];\n\n        // overall directional shift in uv's for directional wave movement for\n        // now we do a hard coded scale for wave speed such that a unit length\n        // direction is not too fast.\n        vec2 waveMovement = time * -_waveDir;\n\n        float timeNoise = sampleNoiseTexture(_uv * TIME_NOISE_TEXTURE_REPEAT) * TIME_NOISE_STRENGTH;\n\n        // compute two perturbed uvs and blend weights\n        // then sample the wave normals at the two positions and blend\n        vec3 uv_A = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.0);\n        vec3 uv_B = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.5);\n\n        vec3 normal_A = textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;\n        vec3 normal_B = textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;\n\n        // logic to flatten the wave pattern\n        // scale xy components of the normal, then adjust z (up) component\n        vec3 mixNormal = normalize(normal_A + normal_B);\n        mixNormal.xy *= waveStrength;\n        mixNormal.z = sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));\n\n        return mixNormal;\n      }\n\n      vec3 getSurfaceNormal(vec2 _uv, float _time) {\n        float waveTextureRepeat = waveParams[1];\n        return getWaveLayer(texWaveNormal, texWavePerturbation, _uv * waveTextureRepeat, waveDirection, _time);\n      }\n    "],["\n      // uniform vec3 octaveTextureRepeat;\n\n      // // 0: waveStrength\n      // // 1: waveTextureRepeat\n      // // 2: flowStrength\n      // // 3: flowOffset\n      // uniform vec4 waveParams;\n\n      // uniform vec2 waveDirection;\n\n      const vec2  FLOW_JUMP = vec2(6.0/25.0, 5.0/24.0);\n\n      vec2 textureDenormalized2D(sampler2D _tex, vec2 _uv) {\n        return 2.0 * texture2D(_tex, _uv).rg - 1.0;\n      }\n\n      float sampleNoiseTexture(vec2 _uv) {\n        return texture2D(texWavePerturbation, _uv).b;\n      }\n\n      vec3 textureDenormalized3D(sampler2D _tex, vec2 _uv) {\n        return 2.0 * texture2D(_tex, _uv).rgb - 1.0;\n      }\n\n      float computeProgress(vec2 uv, float time) {\n        return fract(time);\n      }\n\n      float computeWeight(vec2 uv, float time) {\n        float progress = computeProgress(uv, time);\n        return 1.0 - abs(1.0 - 2.0 * progress);\n      }\n\n      vec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, float time, float phaseOffset) {\n        float flowStrength = waveParams[2];\n        float flowOffset = waveParams[3];\n\n        vec2 flowVector = textureDenormalized2D(texFlow, uv) * flowStrength;\n\n        float progress = computeProgress(uv, time + phaseOffset);\n        float weight = computeWeight(uv, time + phaseOffset);\n\n        vec2 result = uv;\n        result -= flowVector * (progress + flowOffset);\n        result += phaseOffset;\n        result += (time - progress) * FLOW_JUMP;\n\n        return vec3(result, weight);\n      }\n\n      const float TIME_NOISE_TEXTURE_REPEAT = 0.3737;\n      const float TIME_NOISE_STRENGTH = 7.77;\n\n      vec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {\n        float waveStrength = waveParams[0];\n\n        // overall directional shift in uv's for directional wave movement for\n        // now we do a hard coded scale for wave speed such that a unit length\n        // direction is not too fast.\n        vec2 waveMovement = time * -_waveDir;\n\n        float timeNoise = sampleNoiseTexture(_uv * TIME_NOISE_TEXTURE_REPEAT) * TIME_NOISE_STRENGTH;\n\n        // compute two perturbed uvs and blend weights\n        // then sample the wave normals at the two positions and blend\n        vec3 uv_A = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.0);\n        vec3 uv_B = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.5);\n\n        vec3 normal_A = textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;\n        vec3 normal_B = textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;\n\n        // logic to flatten the wave pattern\n        // scale xy components of the normal, then adjust z (up) component\n        vec3 mixNormal = normalize(normal_A + normal_B);\n        mixNormal.xy *= waveStrength;\n        mixNormal.z = sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));\n\n        return mixNormal;\n      }\n\n      vec3 getSurfaceNormal(vec2 _uv, float _time) {\n        float waveTextureRepeat = waveParams[1];\n        return getWaveLayer(texWaveNormal, texWavePerturbation, _uv * waveTextureRepeat, waveDirection, _time);\n      }\n    "])))}}.apply(null,i))||(e.exports=r)},2715:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(9),n(10),n(3),n(127),n(2716),n(344)],void 0===(r=function(e,t,a,n,i,r,s,l){Object.defineProperty(t,"__esModule",{value:!0});var c=i.getLogger("esri.views.3d.webgl-engine.materials.internal.waterMaterialUtils");t.waterParameterDefaultsLocal={waveTexture:e.toUrl("../../../../../images/materials/water/normals.jpg"),perturbationTexture:e.toUrl("../../../../../images/materials/water/perturbation.jpg"),waveStrength:.06,waveTextureRepeat:32,waveDirection:r.vec2f64.fromValues(1,0),waveVelocity:.05,flowStrength:.015,flowOffset:-.5,animationSpeed:.35,color:[0,.35686,.4,1],transparent:!1,writeDepth:!0,slicePlaneEnabled:!1,isDraped:!1,receiveShadows:!0},t.wavePresets={"calm-small":{waveStrength:.005,perturbationStrength:.02,textureRepeat:12,waveVelocity:.01},"rippled-small":{waveStrength:.02,perturbationStrength:.09,textureRepeat:32,waveVelocity:.07},"slight-small":{waveStrength:.05,perturbationStrength:.07,textureRepeat:28,waveVelocity:.1},"moderate-small":{waveStrength:.075,perturbationStrength:.07,textureRepeat:24,waveVelocity:.1},"calm-medium":{waveStrength:.003125,perturbationStrength:.01,textureRepeat:8,waveVelocity:.02},"rippled-medium":{waveStrength:.035,perturbationStrength:.015,textureRepeat:12,waveVelocity:.07},"slight-medium":{waveStrength:.06,perturbationStrength:.015,textureRepeat:8,waveVelocity:.12},"moderate-medium":{waveStrength:.09,perturbationStrength:.03,textureRepeat:4,waveVelocity:.12},"calm-large":{waveStrength:.01,perturbationStrength:0,textureRepeat:4,waveVelocity:.05},"rippled-large":{waveStrength:.025,perturbationStrength:.01,textureRepeat:8,waveVelocity:.11},"slight-large":{waveStrength:.06,perturbationStrength:.02,textureRepeat:3,waveVelocity:.13},"moderate-large":{waveStrength:.14,perturbationStrength:.03,textureRepeat:2,waveVelocity:.15}};var o=(u.prototype.loadTexture=function(i,r,o){return n(this,void 0,void 0,function(){var t,n;return a(this,function(e){switch(e.label){case 0:this.loadingCount++,e.label=1;case 1:return e.trys.push([1,3,,4]),[4,s.requestImage(o)];case 2:return t=e.sent(),this.data[r]=new l(i,this.getTextureProps(t.width,t.height,!0),t),[3,4];case 3:return n=e.sent(),c.warn("Failed to load texture for water material.",n),this.data[r]=new l(i,this.getTextureProps(1,1,!0)),[3,4];case 4:return this.loadingCount--,[2]}})})},u.prototype.getTextureProps=function(e,t,n){return void 0===n&&(n=!1),{target:3553,pixelFormat:6408,dataType:5121,wrapMode:10497,samplingMode:9987,hasMipmap:n,maxAnisotropy:8,width:e,height:t}},u.prototype.ready=function(){return 2===this.loadingState||1===this.loadingState&&0===this.loadingCount&&(this.loadingState=2,!0)},u.prototype.loading=function(){return 1===this.loadingState},u.prototype.initialize=function(e,t){for(var n=0;n<t.length;n++)this.loadTexture(e,n,t[n]);this.loadingState=1},u.prototype.bindRepo=function(e){for(var t=0;t<this.data.length;t++)e.bindTexture(this.data[t],t)},u);function u(){this.loadingCount=0,this.data=[],this.loadingState=0}t.waterTextureRepo=new o}.apply(null,i))||(e.exports=r)},2716:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(5),n(29)],void 0===(r=function(e,t,n,i){Object.defineProperty(t,"__esModule",{value:!0}),t.dataURItoBlob=function(e){for(var t=atob(e.split(",")[1]),n=e.split(",")[0].split(":")[1].split(";")[0],i=new ArrayBuffer(t.length),r=new Uint8Array(i),o=0;o<t.length;o++)r[o]=t.charCodeAt(o);return new Blob([i],{type:n})},t.requestImage=function(e,t){return i(e,n({responseType:"image"},t)).then(function(e){return e.data})}}.apply(null,i))||(e.exports=r)},2717:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(11),n(0),n(1857),n(1973),n(1858),n(1976),n(1741),n(1742),n(1743),n(1704),n(1678),n(2721),n(314)],void 0===(r=function(e,t,n,i,r,o,a,s,l,c,u,d,p,f,h){Object.defineProperty(t,"__esModule",{value:!0});var v,m=(v=c.ShaderTechnique,n(g,v),g.prototype.initializeProgram=function(e){var t=g.shader.get(),n=this.configuration,i=t.build({output:n.output,viewingMode:e.viewingMode,receiveShadows:n.receiveShadows,slicePlaneEnabled:n.slice,sliceHighlightDisabled:n.sliceHighlightDisabled,symbolColor:n.symbolColors,vvSize:n.vvSize,vvColor:n.vvColor,instanced:n.instanced,instancedColor:n.instancedColor,instancedDoublePrecision:n.instancedDoublePrecision,useOldSceneLightInterface:!1,usePBR:n.usePBR,hasMetalnessAndRoughnessTexture:n.hasMetalnessAndRoughnessTexture,hasEmissionTexture:n.hasEmissionTexture,hasOcclusionTexture:n.hasOcclusionTexture,hasNormalTexture:n.hasNormalTexture,hasColorTexture:n.hasColorTexture,receiveAmbientOcclusion:n.receiveAmbientOcclusion,usePBRforWater:!1,useCustomDTRExponentForWater:!1,normalType:n.normalsTypeDerivate?3:0,doubleSidedMode:n.doubleSidedMode,vertexTangets:n.vertexTangents,attributeTextureCoordinates:n.hasMetalnessAndRoughnessTexture||n.hasEmissionTexture||n.hasOcclusionTexture||n.hasNormalTexture||n.hasColorTexture?1:0,textureAlphaPremultiplied:n.textureAlphaPremultiplied,attributeColor:n.vertexColors,screenSizePerspectiveEnabled:n.screenSizePerspective,verticalOffsetEnabled:n.verticalOffset,offsetBackfaces:n.offsetBackfaces,doublePrecisionRequiresObfuscation:s.doublePrecisionRequiresObfuscation(e.rctx),alphaDiscardMode:n.alphaDiscardMode,treeRendering:n.treeRendering,supportsTextureAtlas:!1});return new h(e.rctx,i.generateSource("vertex"),i.generateSource("fragment"),d.Default3D)},g.prototype.bindPass=function(e,t,n){var i=this.configuration.output;0===i?(this.program.setUniform3fv("ambient",t.ambient),this.program.setUniform3fv("diffuse",t.diffuse),this.program.setUniform3fv("specular",t.specular),this.program.setUniform4fv("externalColor",t.externalColor),this.program.setUniform1i("colorMixMode",p.colorMixModes[t.colorMixMode]),this.program.setUniform1f("opacity",t.opacity),this.program.setUniform1f("layerOpacity",t.layerOpacity),this.configuration.usePBR&&o.PhysicallyBasedRenderingParameters.bindUniforms(this.program,t)):1===i||3===i?this.program.setUniform2fv("nearFar",n.nearFar):4===i&&r.OutputHighlight.bindOutputHighlight(e,this.program,n),a.VisualVariables.bindUniformsForSymbols(this.program,t),"mask"!==t.textureAlphaMode&&"maskBlend"!==t.textureAlphaMode||this.program.setUniform1f("textureAlphaCutoff",t.textureAlphaCutoff)},g.prototype.initializePipeline=function(){return null},g.shader=new l.ReloadableShaderModule(f,"./DefaultMaterial.glsl",e),g);function g(){return null!==v&&v.apply(this,arguments)||this}t.DefaultMaterialTechnique=m;var y,b=(y=u.ShaderTechniqueConfiguration,n(_,y),i([u.parameter({count:6})],_.prototype,"output",void 0),i([u.parameter({count:4})],_.prototype,"alphaDiscardMode",void 0),i([u.parameter({count:3})],_.prototype,"doubleSidedMode",void 0),i([u.parameter()],_.prototype,"vertexColors",void 0),i([u.parameter()],_.prototype,"offsetBackfaces",void 0),i([u.parameter()],_.prototype,"symbolColors",void 0),i([u.parameter()],_.prototype,"vvSize",void 0),i([u.parameter()],_.prototype,"vvColor",void 0),i([u.parameter()],_.prototype,"verticalOffset",void 0),i([u.parameter()],_.prototype,"receiveShadows",void 0),i([u.parameter()],_.prototype,"slice",void 0),i([u.parameter()],_.prototype,"sliceHighlightDisabled",void 0),i([u.parameter()],_.prototype,"receiveAmbientOcclusion",void 0),i([u.parameter()],_.prototype,"screenSizePerspective",void 0),i([u.parameter()],_.prototype,"textureAlphaPremultiplied",void 0),i([u.parameter()],_.prototype,"treeRendering",void 0),i([u.parameter()],_.prototype,"hasColorTexture",void 0),i([u.parameter()],_.prototype,"usePBR",void 0),i([u.parameter()],_.prototype,"hasMetalnessAndRoughnessTexture",void 0),i([u.parameter()],_.prototype,"hasEmissionTexture",void 0),i([u.parameter()],_.prototype,"hasOcclusionTexture",void 0),i([u.parameter()],_.prototype,"hasNormalTexture",void 0),i([u.parameter()],_.prototype,"instanced",void 0),i([u.parameter()],_.prototype,"instancedColor",void 0),i([u.parameter()],_.prototype,"instancedDoublePrecision",void 0),i([u.parameter()],_.prototype,"vertexTangents",void 0),i([u.parameter()],_.prototype,"normalsTypeDerivate",void 0),_);function _(){var e=null!==y&&y.apply(this,arguments)||this;return e.output=0,e.alphaDiscardMode=1,e.doubleSidedMode=0,e.vertexColors=!1,e.offsetBackfaces=!1,e.symbolColors=!1,e.vvSize=!1,e.vvColor=!1,e.verticalOffset=!1,e.receiveShadows=!1,e.slice=!1,e.sliceHighlightDisabled=!1,e.receiveAmbientOcclusion=!1,e.screenSizePerspective=!1,e.textureAlphaPremultiplied=!1,e.treeRendering=!1,e.hasColorTexture=!1,e.usePBR=!1,e.hasMetalnessAndRoughnessTexture=!1,e.hasEmissionTexture=!1,e.hasOcclusionTexture=!1,e.hasNormalTexture=!1,e.instanced=!1,e.instancedColor=!1,e.instancedDoublePrecision=!1,e.vertexTangents=!1,e.normalsTypeDerivate=!1,e}t.DefaultMaterialTechniqueConfiguration=b}.apply(null,i))||(e.exports=r)},2718:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.TextureAtlasLookup=function(e){e.extensions.add("GL_EXT_shader_texture_lod"),e.extensions.add("GL_OES_standard_derivatives"),e.fragment.code.add(i.glsl(r=r||n(["\n    #ifndef GL_EXT_shader_texture_lod\n      float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\n        float deltaMaxSqr = max(dot(ddx, ddx), dot(ddy, ddy));\n        return max(0.0, 0.5 * log2(deltaMaxSqr));\n      }\n    #endif\n\n    vec4 textureAtlasLookup(sampler2D texture, vec2 textureSize, vec2 textureCoordinates, vec4 atlasRegion) {\n      //[umin, vmin, umax, vmax]\n      vec2 atlasScale = atlasRegion.zw - atlasRegion.xy;\n      vec2 uvAtlas = fract(textureCoordinates) * atlasScale + atlasRegion.xy;\n\n      // calculate derivative of continuous texture coordinate\n      // to avoid mipmapping artifacts caused by manual wrapping in shader\n      vec2 dUVdx = dFdx(textureCoordinates) * atlasScale;\n      vec2 dUVdy = dFdy(textureCoordinates) * atlasScale;\n\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DGradEXT(texture, uvAtlas, dUVdx, dUVdy);\n      #else\n        // use bias to compensate for difference in automatic vs desired mipmap level\n        vec2 dUVdxAuto = dFdx(uvAtlas);\n        vec2 dUVdyAuto = dFdy(uvAtlas);\n        float mipMapLevel = calcMipMapLevel(dUVdx * textureSize, dUVdy * textureSize);\n        float autoMipMapLevel = calcMipMapLevel(dUVdxAuto * textureSize, dUVdyAuto * textureSize);\n\n        return texture2D(texture, uvAtlas, mipMapLevel - autoMipMapLevel);\n      #endif\n    }\n  "],["\n    #ifndef GL_EXT_shader_texture_lod\n      float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\n        float deltaMaxSqr = max(dot(ddx, ddx), dot(ddy, ddy));\n        return max(0.0, 0.5 * log2(deltaMaxSqr));\n      }\n    #endif\n\n    vec4 textureAtlasLookup(sampler2D texture, vec2 textureSize, vec2 textureCoordinates, vec4 atlasRegion) {\n      //[umin, vmin, umax, vmax]\n      vec2 atlasScale = atlasRegion.zw - atlasRegion.xy;\n      vec2 uvAtlas = fract(textureCoordinates) * atlasScale + atlasRegion.xy;\n\n      // calculate derivative of continuous texture coordinate\n      // to avoid mipmapping artifacts caused by manual wrapping in shader\n      vec2 dUVdx = dFdx(textureCoordinates) * atlasScale;\n      vec2 dUVdy = dFdy(textureCoordinates) * atlasScale;\n\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DGradEXT(texture, uvAtlas, dUVdx, dUVdy);\n      #else\n        // use bias to compensate for difference in automatic vs desired mipmap level\n        vec2 dUVdxAuto = dFdx(uvAtlas);\n        vec2 dUVdyAuto = dFdy(uvAtlas);\n        float mipMapLevel = calcMipMapLevel(dUVdx * textureSize, dUVdy * textureSize);\n        float autoMipMapLevel = calcMipMapLevel(dUVdxAuto * textureSize, dUVdyAuto * textureSize);\n\n        return texture2D(texture, uvAtlas, mipMapLevel - autoMipMapLevel);\n      #endif\n    }\n  "])))}}.apply(null,i))||(e.exports=r)},2719:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(12),n(150),n(20),n(1968),n(1642),n(2720)],void 0===(r=function(e,t,n,m,g,y,b,_){function i(s,l){var e=new g.FramebufferObject(s,{colorTarget:0,depthStencilTarget:0},{target:3553,wrapMode:33071,pixelFormat:6408,dataType:5121,samplingMode:9728,width:1,height:1}),t=g.BufferObject.createVertex(s,35044,new Uint16Array([0,0,1,0,0,1,1,1])),n=new g.VertexArrayObject(s,{a_pos:0},{geometry:[{name:"a_pos",count:2,type:5123,offset:0,stride:4,normalized:!1}]},{geometry:t}),i=m.vec3f64.fromValues(5633261.287538229,2626832.878767164,1434988.0495278358),r=m.vec3f64.fromValues(5633271.46742708,2626873.6381334523,1434963.231608387);s.bindFramebuffer(e);var o=function(e,t){var n=_.util["doublePrecision.glsl"],i="\n\n  precision highp float;\n\n  attribute vec2 a_pos;\n\n  uniform vec3 u_highA;\n  uniform vec3 u_lowA;\n  uniform vec3 u_highB;\n  uniform vec3 u_lowB;\n\n  varying vec4 v_color;\n\n  "+(l?"#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION":"")+"\n\n  "+n+"\n\n  const float MAX_RGBA_FLOAT =\n    255.0 / 256.0 +\n    255.0 / 256.0 / 256.0 +\n    255.0 / 256.0 / 256.0 / 256.0 +\n    255.0 / 256.0 / 256.0 / 256.0 / 256.0;\n\n  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\n\n  vec4 float2rgba(const float value) {\n    // Make sure value is in the domain we can represent\n    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\n\n    // Decompose value in 32bit fixed point parts represented as\n    // uint8 rgba components. Decomposition uses the fractional part after multiplying\n    // by a power of 256 (this removes the bits that are represented in the previous\n    // component) and then converts the fractional part to 8bits.\n    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\n\n    // Convert uint8 values (from 0 to 255) to floating point representation for\n    // the shader\n    const float toU8AsFloat = 1.0 / 255.0;\n\n    return fixedPointU8 * toU8AsFloat;\n  }\n\n  void main() {\n    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);\n\n    v_color = float2rgba(val.z / 25.0);\n\n    gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n  }\n  ",r=new g.Program(s,i,"\n  precision highp float;\n\n  varying vec4 v_color;\n\n  void main() {\n    gl_FragColor = v_color;\n  }\n  ",{a_pos:0}),o=new Float32Array(6);y.encodeDoubleArray(e,o,3);var a=new Float32Array(6);return y.encodeDoubleArray(t,a,3),s.bindProgram(r),r.setUniform3f("u_highA",o[0],o[2],o[4]),r.setUniform3f("u_lowA",o[1],o[3],o[5]),r.setUniform3f("u_highB",a[0],a[2],a[4]),r.setUniform3f("u_lowB",a[1],a[3],a[5]),r}(i,r),a=s.getViewport(),c=a.x,u=a.y,d=a.width,p=a.height;s.setViewport(0,0,1,1),s.bindVAO(n),s.drawArrays(5,0,4),s.setViewport(c,u,d,p);var f=new Uint8Array(4);e.readPixels(0,0,1,1,6408,5121,f),o.dispose(),n.dispose(!1),t.dispose(),e.dispose();var h=(i[2]-r[2])/25,v=b.unpackFloatRGBA(f);return Math.abs(h-v)}Object.defineProperty(t,"__esModule",{value:!0});var r=(Object.defineProperty(a.prototype,"doublePrecisionRequiresObfuscation",{get:function(){if(n.isNone(this._doublePrecisionRequiresObfuscation)){var e=i(this.context,!1),t=i(this.context,!0);this._doublePrecisionRequiresObfuscation=0!==e&&(0===t||5<e/t)}return this._doublePrecisionRequiresObfuscation},enumerable:!0,configurable:!0}),a),o=null;function a(e){this.context=e,this._doublePrecisionRequiresObfuscation=null}t.testWebGLDriver=function(e){return!n.isNone(o)&&o.context===e||(o=new r(e)),o}}.apply(null,i))||(e.exports=r)},2720:function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=function(e,t){return{environment:{"realisticAtmosphere.frag":"#include <util/fsPrecision.glsl>\n#include <util/encoding.glsl>\n#include <util/color.glsl>\nuniform vec3 lightingMainDirection;\nuniform vec3 invWavelength;\nuniform vec3 invWavelengthScaled;\nconst float krESun = 0.075;\nconst float kmESun = 0.015;\nuniform vec2 radii;\n#define innerRadius radii[0]\n#define outerRadius radii[1]\nuniform vec4 atmosParams1;\nuniform vec4 atmosParams2;\n#define shellScale atmosParams1.x\n#define shellDepth vec2(atmosParams1.y, atmosParams2.y)\n#define scaleOverScaleDepth vec2(atmosParams1.z, atmosParams2.z)\n#define oneOverScaleDepth vec2(atmosParams1.w, atmosParams2.w)\n#ifndef HAZE\nuniform vec3 atmosParams3;\nuniform float innerFadeDistance;\nuniform float altitudeFade;\n#define g atmosParams2.x\n#define gSq atmosParams3.x\n#define miePhaseCoefficients atmosParams3.y\n#define lowerAlphaBlendBound atmosParams3.z\n#endif\nuniform vec3 cameraPosition;\nuniform vec2 nearFar;\nuniform vec4 sphereComp;\n#define cameraHeight sphereComp[0]\n#define cameraHeightSq sphereComp[1]\n#define C sphereComp[2]\n#define CSur sphereComp[3]\n#ifdef HAZE\nconst float exposure = 1.5;\n#else\nconst float exposure = 2.0;\n#endif\n#ifdef HAZE\nuniform sampler2D depthTex;\n#endif\nvarying vec3 eyeDir;\nvarying vec3 worldRay;\nvarying vec2 vtc;\nconst float samples = 5.0;\nconst int maxSamples = 5;\n#ifdef HAZE\n  const vec3 oneOverGamma = vec3(1.0);\n#else\n  const vec3 oneOverGamma = vec3(0.454545);\n#endif\nvec3 expTM(vec3 inputColor,float _exposure) {\n    return pow(1.0 - exp(inputColor * -_exposure), oneOverGamma);\n}\n#ifndef HAZE\nvec3 reinhardTM(vec3 inputColor, float _exposure) {\n  vec3 intermediate = inputColor * _exposure;\n  intermediate /= ( 1.0 + intermediate );\n  return pow(intermediate, oneOverGamma);\n}\n#endif\nfloat scale(float _cos) {\n  float x = 1.0 - _cos;\n  return exp( -0.00287 + x * ( 0.459 + x * ( 3.83 + x * (-6.80 + x * 5.25 ))));\n}\nvoid main() {\n  vec3 worldSpaceRay = normalize(worldRay);\n  float B = 2.0 * dot(cameraPosition, worldSpaceRay);\n  float det = B * B - 4.0 * C;\n  float detSur = B * B - 4.0 * CSur;\n  float minRayStart = 0.0;\n#ifndef HAZE\n  float surfaceBlend = 0.0;\n  vec4 surfaceColor = vec4(0.0);\n  if (detSur >= 0.0) {\n    float nearSurface = max(0.0, 0.5 *(-B - sqrt(detSur)));\n    float farSurface = max(0.0, 0.5 *(-B + sqrt(detSur)));\n    if (nearSurface == 0.0) {\n      minRayStart = farSurface;\n    }\n    vec3 vPos = cameraPosition + worldSpaceRay * nearSurface;\n    float lightAngle = dot(-lightingMainDirection, normalize(vPos));\n    float brightness = max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)));\n    surfaceColor = vec4(brightness, brightness, brightness, 1.0 - altitudeFade);\n    float relDist = (farSurface - nearSurface) / innerFadeDistance;\n    if (relDist > 1.0) {\n      gl_FragColor = surfaceColor;\n      return;\n    }\n    surfaceBlend = smoothstep(0.0, 1.0, relDist * relDist);\n  }\n#endif\n  if (det >= 0.0) {\n#ifdef HAZE\n    float depthSample = texture2D(depthTex, vtc).r;\n    float zNear = nearFar[0];\n    float zFar = nearFar[1];\n    float zNorm = 2.0 * depthSample - 1.0;\n    float linDepth = 2.0 * zNear * zFar /\n      (zFar + zNear - zNorm * (zFar - zNear));\n    float rayEnd;\n    float altitudeAlpha = 1.0;\n    if (depthSample < 1.0 && depthSample > 0.0) {\n      vec3 cameraSpaceRay = normalize(eyeDir);\n      cameraSpaceRay /= cameraSpaceRay.z;\n      cameraSpaceRay *= linDepth;\n      float cameraSpaceRayLength = length(cameraSpaceRay);\n      vec3 world = cameraPosition + worldSpaceRay * cameraSpaceRayLength;\n      float worldRadiusSq = dot(world, world);\n      float transitionStart = innerRadius + 20000.0;\n      float transitionHeight = 25000.0;\n      float transitionEnd = transitionStart + transitionHeight;\n      float edge0 = transitionStart * transitionStart;\n      float edge1 = transitionEnd * transitionEnd;\n      altitudeAlpha = 1.0 - clamp((worldRadiusSq - edge0) / (edge1 - edge0), 0.0, 1.0);\n      rayEnd = cameraSpaceRayLength;\n      if (altitudeAlpha > 0.0 && detSur > 0.0) {\n        float nearSurface = 0.5 * ( -B - sqrt(detSur) );\n        float interp = clamp(((cameraHeight - innerRadius) - 2000000.0) / 6000000.0, 0.0, 1.0);\n        rayEnd = mix(cameraSpaceRayLength, nearSurface, interp);\n      }\n    }\n#endif\n    float rayStart = 0.5 *(-B - sqrt(det));\n#ifdef HAZE\n    float near = abs(rayStart);\n    float far = abs(rayEnd);\n#else\n    float rayEnd = 0.5 *(-B + sqrt(det));\n#endif\n    float scatterDistance;\n    if (rayStart < minRayStart)\n    {\n      rayStart = minRayStart;\n#ifndef HAZE\n      scatterDistance = shellScale * min(0.0, innerRadius - cameraHeight);\n#endif\n    }\n#ifndef HAZE\n    else\n    {\n      scatterDistance = -1.0;\n    }\n#endif\n    vec3 start = cameraPosition + worldSpaceRay * rayStart;\n#ifdef HAZE\n    vec3 end = cameraPosition + worldSpaceRay * rayEnd;\n    float endLength = length(end);\n    float altitudeEnd = endLength - innerRadius;\n    float altitudeStart = length(start) - innerRadius;\n    if (altitudeStart < 0.0) {\n      altitudeStart = -altitudeStart;\n      altitudeEnd = -altitudeEnd;\n    }\n    float lightAngle = dot(-lightingMainDirection, end) / endLength;\n    if (near > far)\n    {\n      if (altitudeStart < altitudeEnd)\n      {\n        end = cameraPosition + worldSpaceRay * rayStart;\n        start = cameraPosition + worldSpaceRay * rayEnd;\n        worldSpaceRay *= -1.0;\n        float tmp = altitudeStart;\n        altitudeStart = altitudeEnd;\n        altitudeEnd = tmp;\n      }\n      else if (altitudeStart == altitudeEnd)\n      {\n        altitudeStart += 1.0;\n      }\n    }\n    if (altitudeStart > outerRadius - innerRadius)\n    {\n      scatterDistance = innerRadius - outerRadius;\n    } else\n    {\n      scatterDistance = altitudeEnd - altitudeStart;\n    }\n#endif\n    vec2 opticalStartDepth = exp(scatterDistance * oneOverScaleDepth);\n    float rayLength = rayEnd - rayStart;\n    float sampleLength = rayLength / samples;\n    float scaledLength = sampleLength * shellScale;\n    vec3 sampleRay = worldSpaceRay * sampleLength;\n    vec3 samplePoint = start + sampleRay * 0.5;\n#ifdef HAZE\n    float cameraAngle = dot(-worldSpaceRay, end) / length(end);\n    float scaleCameraAngle = scale(cameraAngle);\n    vec2 cameraOffset = scaleCameraAngle * opticalStartDepth;\n    float scaledValues = scale(lightAngle) + scaleCameraAngle;\n    vec2 scaledValuesDepth = scaledValues * shellDepth;\n#else\n    float cameraAngle = dot(worldSpaceRay, start / length(start));\n    float angleMultiplier = cameraAngle > 0.0 ? cameraAngle : 0.0;\n    float scaleCameraAngle = scale(cameraAngle);\n    vec2 cameraOffset = scaleCameraAngle * opticalStartDepth * shellDepth;\n#endif\n    vec3 frontColor = vec3(0.0);\n    vec3 frontColorBlue = vec3(0.0);\n    vec3 attenuate = vec3(0.0);\n    vec3 attenuateBlue = vec3(0.0);\n    for(int i=0; i<maxSamples; i++) {\n      float height = length(samplePoint);\n      float altitude = abs(height - innerRadius);\n      vec2 depth = exp(-altitude * scaleOverScaleDepth);\n#ifdef HAZE\n      vec2 scatter = depth * scaledValuesDepth - cameraOffset;\n#else\n      float lightAngle = dot(-lightingMainDirection, samplePoint) / height;\n      float cameraAngle = dot(worldSpaceRay, samplePoint) / height;\n      float tmpScaledValues = scale(lightAngle) - scale(cameraAngle);\n      vec2 scatter = cameraOffset + tmpScaledValues * depth * shellDepth;\n#endif\n      attenuate = exp(-scatter.x * invWavelengthScaled);\n      attenuateBlue = exp(-scatter.y * invWavelengthScaled);\n      frontColor += attenuate * depth.x;\n      frontColorBlue += attenuateBlue * depth.y;\n      samplePoint += sampleRay;\n    }\n    float LdotR = clamp(dot(-lightingMainDirection, -worldSpaceRay ),-0.9999999,1.0);\n    float LdotRSq = LdotR * LdotR + 1.0;\n#ifdef HAZE\n    vec3 colorCoefficients = (scaledLength * 0.75 * LdotRSq) * (krESun * invWavelength + kmESun );\n    vec3 color = colorCoefficients * frontColor;\n    vec3 colorBlue = colorCoefficients * frontColorBlue;\n#else\n    vec3 rayleighCoefficients = (scaledLength * 0.75 * LdotRSq * krESun) * invWavelength;\n    float mieCoefficients = scaledLength * kmESun * miePhaseCoefficients * LdotRSq / pow(1.0 + gSq - 2.0 * g * LdotR, 1.5);\n    vec3 color = rayleighCoefficients * frontColor + mieCoefficients * frontColor;\n    vec3 colorBlue = rayleighCoefficients * frontColorBlue + mieCoefficients * frontColorBlue;\n#endif\n    vec3 ldrBlue = expTM(colorBlue, 2.0 * exposure);\n    vec3 ldrRed = expTM(color, exposure);\n    vec3 LDR = mix(ldrBlue, ldrRed, 0.2);\n#ifdef HAZE\n    LDR *= (1.0 - cameraAngle);\n    vec3 hsv = rgb2hsv(LDR);\n    hsv.y = clamp(hsv.y * 1.5, 0.0, 1.0);\n    LDR = hsv2rgb(hsv);\n    vec3 finalColor = LDR;\n#else\n    vec3 ldrReinhard = reinhardTM(color, exposure);\n    LDR += angleMultiplier * ldrReinhard;\n    float side = (rayEnd + rayStart) * 0.5;\n    float atmoHeight = sqrt(cameraHeightSq - side * side);\n    float h2 = clamp(1.0 - ( atmoHeight - lowerAlphaBlendBound ) / ( outerRadius - lowerAlphaBlendBound ), 0.0, 1.0);\n    vec3 finalColor = LDR * h2;\n    vec3 hsv = rgb2hsv(finalColor);\n    hsv.y = clamp(hsv.y * 1.5, 0.0, 1.0);\n    finalColor = hsv2rgb(hsv);\n#endif\n#ifndef HAZE\n    float atmosStrength = clamp((length(ldrRed) - 0.05) * 1.05, 0.0, 1.0);\n    gl_FragColor = vec4(finalColor, atmosStrength * clamp(1.0 - ( atmoHeight - innerRadius ) / (outerRadius - innerRadius), 0.0, 1.0));\n    if (surfaceBlend > 0.0) {\n      gl_FragColor = mix(gl_FragColor, surfaceColor, surfaceBlend);\n    }\n#else\n    gl_FragColor = vec4(finalColor, 1.0) * altitudeAlpha;\n#endif\n  } else {\n    gl_FragColor = vec4(0.0);\n  }\n}","realisticAtmosphere.vert":"#include <util/vsPrecision.glsl>\nuniform vec2 halfSizeNearPlane;\nuniform vec3 cameraUp;\nuniform vec3 cameraRight;\nuniform vec3 cameraDir;\nuniform vec2 cameraCenterOffset;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec3 worldRay;\nvarying vec2 vtc;\n#ifdef HAZE\nvarying vec3 eyeDir;\n#endif\nvoid main(void) {\n  vec3 v3Pos = position;\n  vtc = uv0;\n  vec2 rayvtc = uv0 - cameraCenterOffset;\n#ifdef HAZE\n  eyeDir = vec3((2.0 * halfSizeNearPlane * rayvtc) - halfSizeNearPlane, -1.0);\n#else\n  vec3 eyeDir = vec3((2.0 * halfSizeNearPlane * rayvtc) - halfSizeNearPlane, -1.0);\n#endif\n  worldRay = eyeDir.z * cameraDir + eyeDir.y * cameraUp + eyeDir.x * cameraRight;\n  gl_Position = vec4(v3Pos, 1.0);\n}","simpleAtmosphere.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nvarying vec2 vtc;\nvarying float falloff;\n#ifndef PANORAMIC\nuniform float altitudeFade;\nvarying float innerFactor;\n#endif\nvoid main() {\n  vec4 texColor = texture2D(tex, vtc);\n#ifdef PANORAMIC\n  gl_FragColor = texColor * falloff;\n#else\n  vec4 atmosphereColor = texColor * falloff;\n  vec4 innerColor = vec4(texColor.rgb * falloff, 1.0 - altitudeFade);\n  gl_FragColor = mix(atmosphereColor, innerColor, smoothstep(0.0, 1.0, innerFactor));\n#endif\n}","simpleAtmosphere.vert":"#include <util/vsPrecision.glsl>\n#include <util/transform.glsl>\nuniform mat4 proj;\nuniform mat4 view;\n#ifndef PANORAMIC\nconst float TWICEPI = 2.0*3.14159265;\nconst float ATMOSPHERE_RIM_SEGMENTS = 128.0;\nuniform vec3 silCircleCenter;\nuniform vec3 silCircleV1;\nuniform vec3 silCircleV2;\nuniform vec2 texV;\nuniform float innerScale;\nvarying float innerFactor;\n#endif\nuniform vec3 lightingMainDirection;\nattribute vec3 position;\nvarying vec2 vtc;\nvarying float falloff;\nvoid main(void) {\n  vec3 lightDirection = -lightingMainDirection;\n#ifdef PANORAMIC\n  vec3 pos = position;\n  float ndotl = lightDirection.z;\n  vtc = vec2(0.0, position.z+0.05);\n#else\n  innerFactor = clamp(-position.z, 0.0, 1.0);\n  float scale = position.y * (1.0 + innerFactor * innerScale);\n  float phi = position.x * (TWICEPI / ATMOSPHERE_RIM_SEGMENTS) + 1.0;\n  vec3 pos =  (silCircleCenter + sin(phi) * silCircleV1 + cos(phi) * silCircleV2) * scale;\n  float ndotl = dot(normalize(position.y > 0.0 ? pos: silCircleCenter), lightDirection);\n  vtc.x = position.x / ATMOSPHERE_RIM_SEGMENTS;\n  vtc.y = texV.x * (1.0 - position.z) + texV.y * position.z;\n#endif\n  falloff = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\n  gl_Position = transformPosition(proj, view, pos);\n  gl_Position.z = gl_Position.w;\n}","simpleAtmosphereFade.frag":"#include <util/fsPrecision.glsl>\nvarying vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}","simpleAtmosphereFade.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nuniform vec3 lightingMainDirection;\nuniform vec3 cameraPosition;\nuniform float undergroundFadeAlpha;\nvarying vec4 color;\nvoid main(void) {\n  float ndotl = dot(normalize(cameraPosition), -lightingMainDirection);\n  float lighting = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\n  color = vec4(vec3(lighting), undergroundFadeAlpha);\n  gl_Position = vec4(position.xy, 1.0, 1.0);\n}","stars.frag":"#include <util/fsPrecision.glsl>\nvarying vec4 vcolor;\nvarying float vsize;\nvoid main() {\n  float cap = 0.7;\n  float scale = 1.0/cap;\n  float helper = clamp(length(abs(gl_PointCoord-vec2(0.5))),0.0,cap);\n  float alpha = clamp((cap-helper)*scale,0.0,1.0);\n  float intensity = alpha*alpha*alpha;\n  if (vsize < 3.0)\n    intensity *= 0.5;\n  gl_FragColor = vec4(1.0,1.0,1.0,intensity);\n  gl_FragColor.xyz *= vcolor.xyz;\n}","stars.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform vec4 viewport;\nuniform float pixelRatio;\nattribute vec3 position;\nattribute vec4 color;\nattribute float size;\nvarying vec4 vcolor;\nvarying float vsize;\nvoid main(void) {\n  vec4 posProj = proj * view * model*vec4(position*1.0e25,1.0);\n  gl_Position = alignToPixelCenter(posProj, viewport.zw);\n  gl_Position.z = gl_Position.w;\n  vcolor = color / 1.2;\n  vsize = size * 5.0 * pixelRatio;\n  gl_PointSize = vsize;\n}"},materials:{hud:{"colorPass.frag":"#include <materials/hud/hudHeader.glsl>\nvoid main() {\n#include <materials/hud/hudMain.glsl>\n}","highlightPass.frag":"#include <materials/hud/hudHeader.glsl>\n#include <util/highlight.glsl>\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\nvoid main() {\n#include <materials/hud/hudMain.glsl>\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\n  if (voccluded == 1.0) {\n    gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n  } else {\n    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n  }\n#else\n  gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n#endif\n}","hud.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\n#include <util/hud.glsl>\n#include <util/visualVariables.glsl>\n#include <util/slice.glsl>\nuniform vec2 screenOffset;\nuniform vec2 anchorPos;\nuniform vec2 textureCoordinateScaleFactor;\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspective;\n#endif\n#ifdef DEBUG_DRAW_BORDER\nvarying vec4 debugBorderCoords;\n#endif\nattribute vec2 uv0;\nattribute vec4 color;\nattribute vec2 size;\nattribute vec4 auxpos2;\nvarying vec4 vcolor;\nvarying vec2 vtc;\nvarying vec2 vsize;\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\nvarying float voccluded;\n#endif\nvoid main(void) {\n  ProjectHUDAux projectAux;\n  vec4 posProj = projectPositionHUD(projectAux);\n  if (rejectBySlice(projectAux.posModel)) {\n    gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    return;\n  }\n  vec2 inputSize;\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\n  vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n#else\n  inputSize = size;\n  vec2 screenOffsetScaled = screenOffset;\n#endif\n#ifdef VV_SIZE\n  inputSize *= vvGetScale(auxpos2).xx;\n#endif\n  vec2 combinedSize = inputSize * pixelRatio;\n  vec4 quadOffset = vec4(0.0);\n#if defined(OCCL_TEST) || defined(BINARY_HIGHLIGHT_OCCLUSION)\n  bool visible = testVisibilityHUD(posProj);\n#endif\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\nvoccluded = visible ? 0.0 : 1.0;\n#endif\n#ifdef OCCL_TEST\n  if (visible) {\n#endif\n    vec2 uv01 = floor(uv0);\n    vec2 uv = uv0 - uv01;\n    quadOffset.xy = ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;\n#ifdef SIGNED_DISTANCE_FIELD\n    posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;\n#else\n    posProj += quadOffset;\n    if (inputSize.x == size.x) {\n      posProj = alignToPixelOrigin(posProj, viewport.zw);\n    }\n#endif\n    gl_Position = posProj;\n    vtc = uv * textureCoordinateScaleFactor;\n#ifdef DEBUG_DRAW_BORDER\n    debugBorderCoords = vec4(uv01, 1.5 / combinedSize);\n#endif\n    vsize = inputSize;\n#ifdef OCCL_TEST\n  } else {\n    vtc = vec2(.0);\n#ifdef DEBUG_DRAW_BORDER\n    debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);\n#endif\n  }\n#endif\n  gl_Position = posProj;\n#ifdef VV_COLOR\n  vcolor = vvGetColor(auxpos2, vvColorValues, vvColorColors);\n#else\n  vcolor = color / 255.0;\n#endif\n}","hudHeader.glsl":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/encoding.glsl>\n#include <util/color.glsl>\nuniform sampler2D tex;\nuniform vec4 overrideColor;\nuniform vec4 outlineColor;\nuniform float outlineSize;\nvarying vec4 vcolor;\nvarying vec2 vtc;\nvarying vec2 vsize;\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\nvarying float voccluded;\n#endif\n#ifdef DEBUG_DRAW_BORDER\nvarying vec4 debugBorderCoords;\n#endif","hudMain.glsl":"#ifdef SIGNED_DISTANCE_FIELD\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 fillPixelColor = overrideColor * vcolor;\n  const float txSize = 128.0;\n  const float texelSize = 1.0 / txSize;\n  vec2 scaleFactor = (vsize - txSize) * texelSize;\n  vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;\n  float d = rgba2float(texture2D(tex, samplePos)) - 0.5;\n  float dist = d * vsize.x;\n  fillPixelColor.a *= clamp(0.5 - dist, 0.0, 1.0);\n  if (outlineSize > 0.25) {\n    vec4 outlinePixelColor = outlineColor;\n    float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);\n    outlinePixelColor.a *= clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\n    float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\n    vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +\n      vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\n    gl_FragColor = vec4(compositeColor, compositeAlpha);\n  }\n  else {\n    gl_FragColor = premultiplyAlpha(fillPixelColor);\n  }\n#else\n  gl_FragColor = texture2D(tex, vtc, -0.5) * premultiplyAlpha(overrideColor * vcolor);\n#endif\n#ifdef DEBUG_DRAW_BORDER\n   float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));\n   gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder);\n#endif\n  if (gl_FragColor.a < 0.1) {\n    discard;\n  }","occlusionTest.frag":"#include <util/fsPrecision.glsl>\nuniform vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}","occlusionTest.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\n#include <util/hud.glsl>\n#include <util/slice.glsl>\nvoid main(void) {\n  vec4 posProjCenter;\n  if (dot(position, position) > 0.0) {\n    ProjectHUDAux projectAux;\n    vec4 posProj = projectPositionHUD(projectAux);\n    posProjCenter = alignToPixelCenter(posProj, viewport.zw);\n    vec3 vpos = projectAux.posModel;\n    if (rejectBySlice(vpos)) {\n      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n  }\n  else {\n    posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n  }\n  gl_Position = posProjCenter;\n  gl_PointSize = 1.0;\n}"},lineCallout:{"lineCallout.frag":"#include <util/fsPrecision.glsl>\nuniform vec4 color;\nuniform vec4 borderColor;\nvarying vec4 coverageSampling;\nvarying vec2 lineSizes;\nvoid main() {\n  vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n  float borderAlpha = color.a * borderColor.a * coverage.y;\n  float colorAlpha = color.a * coverage.x;\n  float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n#ifdef DEPTH_HUD\n  if (finalAlpha < 0.01) {\n    discard;\n  }\n#else\n  vec3 finalRgb = mix(borderColor.rgb * borderAlpha, color.rgb, colorAlpha);\n  gl_FragColor = vec4(finalRgb, finalAlpha);\n#endif\n}","lineCallout.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\n#include <util/hud.glsl>\n#include <util/slice.glsl>\nattribute vec2 uv0;\nuniform float lineSize;\nuniform vec2 pixelToNDC;\nuniform float borderSize;\nuniform vec2 screenOffset;\nvarying vec4 coverageSampling;\nvarying vec2 lineSizes;\nvoid main(void) {\n  ProjectHUDAux projectAux;\n  vec4 endPoint = projectPositionHUD(projectAux);\n  vec3 vpos = projectAux.posModel;\n  if (rejectBySlice(vpos)) {\n    gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n    return;\n  }\n#ifdef OCCL_TEST\n  if (!testVisibilityHUD(endPoint)) {\n    gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n    return;\n  }\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n  vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);\n#else\n  vec2 screenOffsetScaled = screenOffset;\n#endif\n  vec3 posView = (view * (model * vec4(position, 1.0))).xyz;\n  applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);\n  vec4 startPoint = proj * vec4(posView, 1.0);\n  vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n  startPoint.xy += screenOffsetNorm * startPoint.w;\n  endPoint.xy += screenOffsetNorm * endPoint.w;\n  vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n  vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n#ifdef DEPTH_HUD\n#ifdef DEPTH_HUD_ALIGN_START\n  endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);\n#else\n  startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);\n#endif\n#endif\n  vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n  vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n  vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n  float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);\n#else\n  float lineSizeScaled = lineSize;\n  float borderSizeScaled = borderSize;\n#endif\n  float halfPixelSize = lineSizeScaled * 0.5;\n  float halfWholePixelSize = floor(lineSizeScaled) * 0.5;\n  float halfPixelSizeInt = floor(halfWholePixelSize);\n  float subpixelOffset = -fract(lineSizeScaled) * float(halfWholePixelSize > 0.0);\n  float pixelOffset = -halfPixelSizeInt + subpixelOffset;\n  float padding = 1.0 + borderSizeScaled;\n  vec2 ndcOffset = (pixelOffset - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n  projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n  float edgeDirection = (uv0.x * 2.0 - 1.0);\n  float halfBorderSize = 0.5 * borderSizeScaled;\n  float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n  float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n  float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n  coverageSampling = vec4(\n    outerEdgeCoverageSampler,\n    outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n    halfPixelSize - 0.5,\n    halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n  );\n  lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n  gl_Position = projectedPosition;\n}"},measurementArrow:{"measurementArrow.frag":"#include <util/fsPrecision.glsl>\nuniform float outlineSize;\nuniform vec4 outlineColor;\nuniform float stripeLength;\nuniform vec4 stripeEvenColor;\nuniform vec4 stripeOddColor;\nvarying vec2 vtc;\nvarying float vlength;\nvarying float vradius;\n#define INV_SQRT2 (1.0 / sqrt(2.0))\nvec4 arrowColor(vec2 tc, float len) {\n  float d = INV_SQRT2 * (tc.x - abs(tc.y));\n  d = min(d, INV_SQRT2 * (len - tc.x - abs(tc.y)));\n  d = min(d, 1.0 - abs(tc.y));\n  if (d < 0.0) {\n    return vec4(0.0);\n  } else if (d < outlineSize) {\n    return outlineColor;\n  } else {\n    return fract(0.5 / stripeLength * tc.x * vradius) >= 0.5 ? stripeOddColor : stripeEvenColor;\n  }\n}\nvoid main(void) {\n  vec2 ntc = vec2(vtc.x / vradius, vtc.y);\n  vec4 color = arrowColor(ntc, vlength / vradius);\n  if (color.a == 0.0) {\n    discard;\n  }\n  gl_FragColor = color;\n}","measurementArrow.vert":"#include <util/vsPrecision.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform float width;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv0;\nattribute float auxpos1;\nvarying vec2 vtc;\nvarying float vlength;\nvarying float vradius;\nvoid main(void) {\n  vec3 bitangent = normal;\n  vtc = uv0;\n  vlength = auxpos1;\n  vradius = 0.5 * width;\n  vec4 pos = view * vec4((model * vec4(position + vradius * bitangent * uv0.y, 1.0)).xyz, 1.0);\n  gl_Position = proj * pos;\n}"},slicePlane:{"slicePlane.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\nuniform vec4 backgroundColor;\nuniform vec4 gridColor;\nuniform float ratio;\nuniform float gridWidth;\nvarying vec2 vUV;\nvoid main() {\n  const float LINE_WIDTH = 1.0;\n  vec2 uvScaled = vUV * gridWidth;\n  vec2 gridUV = (fract(uvScaled + 0.5) - 0.5) / (LINE_WIDTH * fwidth(uvScaled));\n  vec2 grid = (1.0 - step(0.5, gridUV)) * step(-0.5, gridUV);\n  grid.x *= step(0.5, uvScaled.x) * step(uvScaled.x, gridWidth - 0.5);\n  grid.y *= step(0.5, uvScaled.y) * step(uvScaled.y, gridWidth - 0.5);\n  float gridFade = max(grid.x, grid.y);\n  float gridAlpha = gridColor.a * gridFade;\n  gl_FragColor =\n    vec4(backgroundColor.rgb * backgroundColor.a, backgroundColor.a) * (1.0 - gridAlpha) +\n    vec4(gridColor.rgb, 1.0) * gridAlpha;\n}","slicePlane.vert":"#include <util/vsPrecision.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec2 vUV;\nvoid main(void) {\n  vUV = uv0;\n  gl_Position = proj * view * vec4((model * vec4(position, 1.0)).xyz, 1.0);\n}"}},pointRenderer:{"pointRenderer.frag":"#include <util/fsPrecision.glsl>\n#include <util/encoding.glsl>\n#ifdef HIGHLIGHT_PASS\n#include <util/highlight.glsl>\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\n#endif\n#ifdef DEPTH_PASS\nvarying float depth;\n#elif defined(HIGHLIGHT_PASS)\n#else\nvarying vec3 vColor;\n#endif\nvoid main(void) {\n  vec2 vOffset = gl_PointCoord - vec2(0.5, 0.5);\n  float r2 = dot(vOffset, vOffset);\n  if (r2 > 0.25) {\n    discard;\n  }\n#ifdef DEPTH_PASS\n  gl_FragColor = float2rgba(depth);\n#elif defined(HIGHLIGHT_PASS)\n  gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n#else\n  gl_FragColor = vec4(vColor, 1.0);\n#endif\n}","pointRenderer.vert":"#include <util/slice.glsl>\n#include <util/vsPrecision.glsl>\nattribute vec3 aPosition;\nattribute vec3 aColor;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform vec2 uScreenMinMaxSize;\nuniform vec2 uPointScale;\nuniform vec3 uClipMin;\nuniform vec3 uClipMax;\n#ifdef DEPTH_PASS\nuniform vec2 nearFar;\nvarying float depth;\n#else\nvarying vec3 vColor;\n#endif\nvoid main(void) {\n  if (aPosition.x < uClipMin.x || aPosition.y < uClipMin.y || aPosition.z < uClipMin.z ||\n      aPosition.x > uClipMax.x || aPosition.y > uClipMax.y || aPosition.z > uClipMax.z) {\n    gl_Position = vec4(0.0,0.0,0.0,2.0);\n    gl_PointSize = 0.0;\n    return;\n  }\n  if (rejectBySlice(aPosition)) {\n    gl_Position = vec4(0.0,0.0,0.0,2.0);\n    gl_PointSize = 0.0;\n    return;\n  }\n  vec4 camera = uModelViewMatrix * vec4(aPosition, 1.0);\n  float pointSize = uPointScale.x;\n  vec4 position = uProjectionMatrix * camera;\n#ifdef DRAW_SCREEN_SIZE\n    float clampedScreenSize = pointSize;\n#else\n    float pointRadius = 0.5 * pointSize;\n    vec4 cameraOffset = camera + vec4(0.0, pointRadius, 0.0, 0.0);\n    vec4 positionOffset = uProjectionMatrix * cameraOffset;\n    float radius = abs(positionOffset.y - position.y);\n    float viewHeight = uPointScale.y;\n    float screenPointSize = (radius / position.w) * viewHeight;\n    float clampedScreenSize = clamp(screenPointSize, uScreenMinMaxSize.x, uScreenMinMaxSize.y);\n    camera.xyz -= normalize(camera.xyz) * pointRadius * clampedScreenSize / screenPointSize;\n    position = uProjectionMatrix * camera;\n#endif\n  gl_PointSize = clampedScreenSize;\n  gl_Position = position;\n#ifdef DEPTH_PASS\n  depth = (-camera.z - nearFar[0]) / (nearFar[1] - nearFar[0]);\n#else\n  vColor = aColor;\n#endif\n}"},renderer:{highlight:{"apply.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nuniform sampler2D origin;\nuniform vec4 color;\nuniform vec4 haloColor;\nuniform float outlineSize;\nuniform float blurSize;\nuniform vec4 opacities;\nvarying vec2 uv;\nvoid main() {\n  #if defined(GRID_OPTIMIZATION) && defined(GRID_DEBUG)\n    gl_FragColor = vec4(uv, 0.0, 1.0);\n  #else\n    vec4 blurredHighlightValue = texture2D(tex, uv);\n    float highlightIntensity = blurredHighlightValue.a;\n    if (highlightIntensity == 0.0) {\n      discard;\n    }\n    vec4 origin_color = texture2D(origin, uv);\n    float outlineIntensity;\n    float fillIntensity;\n    if (blurredHighlightValue.g > blurredHighlightValue.b) {\n      outlineIntensity = haloColor.w * opacities[1];\n      fillIntensity = color.w * opacities[3];\n    }\n    else {\n      outlineIntensity = haloColor.w * opacities[0];\n      fillIntensity = color.w * opacities[2];\n    }\n    float inner = 1.0 - outlineSize / 9.0;\n    float outer = 1.0 - (outlineSize + blurSize) / 9.0;\n    float outlineFactor = smoothstep(outer, inner, highlightIntensity);\n    float fillFactor = any(notEqual(origin_color, vec4(0.0, 0.0, 0.0, 0.0))) ? 1.0 : 0.0;\n    float intensity = outlineIntensity * outlineFactor * (1.0 - fillFactor) + fillIntensity * fillFactor;\n    gl_FragColor = vec4(mix(haloColor.rgb, color.rgb, fillFactor), intensity);\n  #endif\n}","apply.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvarying vec2 uv;\n#ifdef GRID_OPTIMIZATION\n  attribute vec2 uv0;\n  uniform sampler2D coverageTex;\n#endif\nvoid main() {\n  #ifdef GRID_OPTIMIZATION\n    #ifdef GRID_DEBUG\n      vec4 cov = texture2D(coverageTex, uv0);\n      if (cov.r == 0.0 || cov.g == 1.0 || cov.b == 1.0) {\n        gl_Position = vec4(0.0);\n        return;\n      }\n      gl_Position = vec4(position, .0, 1.0);\n      uv = uv0;\n      return;\n    #else\n      vec4 cov = texture2D(coverageTex, uv0);\n      if (cov.r == 0.0) {\n        gl_Position = vec4(0.0);\n        return;\n      }\n    #endif\n  #endif\n  gl_Position = vec4(position, .0, 1.0);\n  uv = position.xy * .5 + vec2(.5);\n}","blur.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\n#ifdef GRID_OPTIMIZATION\n  uniform vec2 blurSize;\n  varying vec3 blurCoordinate;\n#else\n  varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n#endif\nvoid main() {\n  #ifdef GRID_OPTIMIZATION\n    vec2 uv = blurCoordinate.xy;\n    vec4 center = texture2D(tex, uv);\n    if (blurCoordinate.z == 1.0) {\n      gl_FragColor = center;\n    }\n    else {\n      vec4 sum = vec4(0.0);\n      #if GAUSSIAN_SAMPLES == 3\n        sum += center * 0.204164;\n        sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n      #elif GAUSSIAN_SAMPLES == 5\n        sum += center * 0.204164;\n        sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv + blurSize * 3.294215) * 0.093913;\n        sum += texture2D(tex, uv - blurSize * 3.294215) * 0.093913;\n      #elif GAUSSIAN_SAMPLES == 7\n        sum += center * 0.204164;\n        sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv + blurSize * 3.294215) * 0.093913;\n        sum += texture2D(tex, uv - blurSize * 3.294215) * 0.093913;\n        sum += texture2D(tex, uv + blurSize * 5.1) * 0.03;\n        sum += texture2D(tex, uv - blurSize * 5.1) * 0.03;\n      #elif GAUSSIAN_SAMPLES == 9\n        sum += center * 0.154164;\n        sum += texture2D(tex, uv + blurSize * 1.5) * 0.204005;\n        sum += texture2D(tex, uv - blurSize * 1.5) * 0.204005;\n        sum += texture2D(tex, uv + blurSize * 3.5) * 0.123913;\n        sum += texture2D(tex, uv - blurSize * 3.5) * 0.123913;\n        sum += texture2D(tex, uv + blurSize * 5.5) * 0.123913;\n        sum += texture2D(tex, uv - blurSize * 5.5) * 0.123913;\n        sum += texture2D(tex, uv + blurSize * 7.5) * 0.05;\n        sum += texture2D(tex, uv - blurSize * 7.5) * 0.05;\n      #endif\n      gl_FragColor = sum;\n    }\n  #else\n    vec4 sum = vec4(0.0);\n    #if GAUSSIAN_SAMPLES == 3\n      sum += texture2D(tex, blurCoordinates[0]) * 0.204164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.304005;\n    #elif GAUSSIAN_SAMPLES == 5\n      sum += texture2D(tex, blurCoordinates[0]) * 0.204164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[3]) * 0.093913;\n      sum += texture2D(tex, blurCoordinates[4]) * 0.093913;\n    #elif GAUSSIAN_SAMPLES == 7\n      sum += texture2D(tex, blurCoordinates[0]) * 0.204164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[3]) * 0.093913;\n      sum += texture2D(tex, blurCoordinates[4]) * 0.093913;\n      sum += texture2D(tex, blurCoordinates[5]) * 0.03;\n      sum += texture2D(tex, blurCoordinates[6]) * 0.03;\n    #elif GAUSSIAN_SAMPLES == 9\n      sum += texture2D(tex, blurCoordinates[0]) * 0.154164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.204005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.204005;\n      sum += texture2D(tex, blurCoordinates[3]) * 0.123913;\n      sum += texture2D(tex, blurCoordinates[4]) * 0.123913;\n      sum += texture2D(tex, blurCoordinates[5]) * 0.09;\n      sum += texture2D(tex, blurCoordinates[6]) * 0.09;\n      sum += texture2D(tex, blurCoordinates[7]) * 0.05;\n      sum += texture2D(tex, blurCoordinates[8]) * 0.05;\n    #endif\n    gl_FragColor = sum;\n  #endif\n}","blur.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nattribute vec2 uv0;\n#ifdef GRID_OPTIMIZATION\n  uniform sampler2D coverageTex;\n  varying vec3 blurCoordinate;\n#else\n  uniform vec2 blurSize;\n  varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n#endif\nvoid main() {\n  gl_Position = vec4(position, 0.0, 1.0);\n  #ifdef GRID_OPTIMIZATION\n    vec4 cov = texture2D(coverageTex, uv0);\n    if (cov.r == 0.0) {\n      gl_Position = vec4(0.0);\n    }\n    blurCoordinate = vec3(gl_Position.xy * .5 + vec2(.5), max(cov.g, cov.b));\n  #else\n    vec2 uv = position.xy * .5 + vec2(.5);\n    #if GAUSSIAN_SAMPLES == 3\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n    #elif GAUSSIAN_SAMPLES == 5\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n      blurCoordinates[3] = uv + blurSize * 3.294215;\n      blurCoordinates[4] = uv - blurSize * 3.294215;\n    #elif GAUSSIAN_SAMPLES == 7\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n      blurCoordinates[3] = uv + blurSize * 3.294215;\n      blurCoordinates[4] = uv - blurSize * 3.294215;\n      blurCoordinates[5] = uv + blurSize * 5.1;\n      blurCoordinates[6] = uv - blurSize * 5.1;\n    #elif GAUSSIAN_SAMPLES == 9\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n      blurCoordinates[3] = uv + blurSize * 3.294215;\n      blurCoordinates[4] = uv - blurSize * 3.294215;\n      blurCoordinates[5] = uv + blurSize * 5.1;\n      blurCoordinates[6] = uv - blurSize * 5.1;\n      blurCoordinates[7] = uv + blurSize * 7.1;\n      blurCoordinates[8] = uv - blurSize * 7.1;\n    #endif\n  #endif\n}","downsample.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nuniform vec2 invFramebufferDim;\nvoid main() {\n  vec2 coord = gl_FragCoord.xy * invFramebufferDim;\n  vec4 value = texture2D(tex, coord);\n  float mx = floor(max(value.g, value.b));\n  gl_FragColor = vec4(ceil(value.r), mx, mx, 1.0);\n}","downsample.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvoid main() {\n  gl_Position = vec4(vec2(1.0) - position * 2.0, .0, 1.0);\n}"},laserLine:{"laserLine.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/depth.glsl>\nuniform sampler2D depthMap;\nuniform vec2 nearFar;\nuniform vec4 projInfo;\nuniform vec2 zScale;\nuniform float maxPixelDistance;\nuniform vec4 focusPlane;\nuniform vec4 focusSphere;\nuniform vec4 segmentPlane;\nuniform vec3 segmentStart;\nuniform vec3 segmentEnd;\nuniform vec3 glowColor;\nuniform float glowWidth;\nuniform vec3 innerColor;\nuniform float innerWidth;\nuniform float globalAlpha;\nvarying vec2 uv;\n#define INFINITY 100000.0\nvec3 reconstructPosition(vec2 fragCoord, float depth) {\n  return vec3((fragCoord * projInfo.xy + projInfo.zw) * (zScale.x * depth + zScale.y), depth);\n}\nfloat planeDistancePixels(vec4 plane, vec3 pos) {\n  float dist = dot(plane.xyz, pos) + plane.w;\n  float width = fwidth(dist);\n  dist /= min(width, maxPixelDistance);\n  return abs(dist);\n}\nfloat sphereDistancePixels(vec4 sphere, vec3 pos) {\n  float dist = distance(sphere.xyz, pos) - sphere.w;\n  float width = fwidth(dist);\n  dist /= min(width, maxPixelDistance);\n  return abs(dist);\n}\nvec4 blendPremultiplied(vec4 source, vec4 dest) {\n  float oneMinusSourceAlpha = 1.0 - source.a;\n  return vec4(\n    source.rgb + dest.rgb * oneMinusSourceAlpha,\n    source.a + dest.a * oneMinusSourceAlpha\n  );\n}\nvec4 premultipliedColor(vec3 rgb, float alpha) {\n  return vec4(rgb * alpha, alpha);\n}\nvec4 laserLineProfile(float dist) {\n  if (dist > glowWidth) {\n    return vec4(0.0);\n  }\n  float innerAlpha = (1.0 - smoothstep(0.0, innerWidth, dist));\n  float glowAlpha = pow(max(0.0, 1.0 - dist / glowWidth), 8.0);\n  return blendPremultiplied(\n    premultipliedColor(innerColor, innerAlpha),\n    premultipliedColor(glowColor, glowAlpha)\n  );\n}\nvoid main() {\n  float depth = linearDepth(depthMap, uv, nearFar);\n  if (-depth == nearFar[0]) {\n    discard;\n  }\n  vec3 pos = reconstructPosition(gl_FragCoord.xy, depth);\n  float ddepth = fwidth(depth);\n  float depthDiscontinuityAlpha = 1.0 - smoothstep(0.0, 0.01, -ddepth / depth);\n  vec3 normal = normalize(cross(dFdx(pos), dFdy(pos)));\n  float focusPlaneDistance = planeDistancePixels(focusPlane, pos);\n  float focusSphereDistance = sphereDistancePixels(focusSphere, pos);\n  float segmentDistance = INFINITY;\n  float segmentLength = length(segmentEnd - segmentStart);\n  vec3 segmentDir = (segmentEnd - segmentStart) / segmentLength;\n  float t = dot(segmentDir, pos - segmentStart);\n  if (segmentLength > 0.0 && t >= 0.0 && t <= segmentLength) {\n    segmentDistance = planeDistancePixels(segmentPlane, pos);\n  }\n  vec4 focusPlaneColor = laserLineProfile(focusPlaneDistance);\n  vec4 focusSphereColor = laserLineProfile(focusSphereDistance);\n  vec4 segmentColor = laserLineProfile(segmentDistance);\n  float focusPlaneAlpha = 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, focusPlane.xyz)));\n  float focusSphereAlpha = 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, normalize(pos - focusSphere.xyz))));\n  float segmentAlpha = 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, segmentPlane.xyz)));\n  vec4 color = max(\n    focusPlaneColor * focusPlaneAlpha,\n    max(\n      focusSphereColor * focusSphereAlpha,\n      segmentColor * segmentAlpha\n    )\n  );\n  gl_FragColor = color * globalAlpha * depthDiscontinuityAlpha;\n}"},offscreen:{"composite.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nvarying vec2 vtc;\nvoid main() {\n  gl_FragColor = texture2D(tex, vtc);\n}","compositeOccluded.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D occludedColorMap;\nuniform float opacity;\nvarying vec2 vtc;\nvoid main() {\n  vec4 occludedColor = texture2D(occludedColorMap, vtc);\n  gl_FragColor = occludedColor * opacity;\n}","compositeTransparentToHUDVisibility.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nvarying vec2 vtc;\nvoid main() {\n  gl_FragColor = vec4(1.0 - texture2D(tex, vtc).a);\n}","offscreen.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvarying vec2 vtc;\nvoid main(void) {\n  gl_Position = vec4(position.xy, 0.0, 1.0);\n  vtc = position.xy * 0.5 + 0.5;\n}"}},util:{"alignPixel.glsl":"vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {\n  vec2 xy = vec2(.500123) + .5 * clipCoord.xy / clipCoord.w;\n  vec2 pixelSz = vec2(1.0) / widthHeight;\n  vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;\n  vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;\n  return vec4(result, clipCoord.zw);\n}\nvec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {\n  vec2 xy = vec2(.5) + .5 * clipCoord.xy / clipCoord.w;\n  vec2 pixelSz = vec2(1.0) / widthHeight;\n  vec2 ij = floor((xy + .5 * pixelSz) * widthHeight) * pixelSz;\n  vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;\n  return vec4(result, clipCoord.zw);\n}","color.glsl":"vec4 premultiplyAlpha(vec4 v) {\n  return vec4(v.rgb * v.a, v.a);\n}\nvec3 rgb2hsv(vec3 c) {\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n  vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);\n}\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat rgb2v(vec3 c) {\n  return max(c.x, max(c.y, c.z));\n}","depth.glsl":"#include <util/encoding.glsl>\nfloat linearDepth(sampler2D depthTex, vec2 uv, vec2 nearFar) {\n  return -(rgba2float(texture2D(depthTex, uv)) * (nearFar[1] - nearFar[0]) + nearFar[0]);\n}\nfloat calcFragDepth(const in float depth) {\n  const float SLOPE_SCALE = 2.0;\n  const float BIAS = 2.0 * .000015259;\n  float m = max(abs(dFdx(depth)), abs(dFdy(depth)));\n  float result = depth + SLOPE_SCALE * m + BIAS;\n  return clamp(result, .0, .999999);\n}","doublePrecision.glsl":"#ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION\nvec3 dpPlusFrc(vec3 a, vec3 b) {\n  return mix(a, a + b, vec3(notEqual(b, vec3(0))));\n}\nvec3 dpMinusFrc(vec3 a, vec3 b) {\n  return mix(vec3(0), a - b, vec3(notEqual(a, b)));\n}\nvec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n  vec3 t1 = dpPlusFrc(hiA, hiB);\n  vec3 e = dpMinusFrc(t1, hiA);\n  vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\n  return t1 + t2;\n}\n#else\nvec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n  vec3 t1 = hiA + hiB;\n  vec3 e = t1 - hiA;\n  vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n  return t1 + t2;\n}\n#endif","enableExtensions.glsl":"#define EXTENSIONS_ENABLED\n#extension GL_OES_standard_derivatives : enable\n#extension GL_EXT_shader_texture_lod : enable","encoding.glsl":"const float MAX_RGBA_FLOAT =\n  255.0 / 256.0 +\n  255.0 / 256.0 / 256.0 +\n  255.0 / 256.0 / 256.0 / 256.0 +\n  255.0 / 256.0 / 256.0 / 256.0 / 256.0;\nconst vec4 fixedPointFactors = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\nvec4 float2rgba(const float value) {\n  float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\n  vec4 fixedPointU8 = floor(fract(valueInValidDomain * fixedPointFactors) * 256.0);\n  const float toU8AsFloat = 1.0 / 255.0;\n  return fixedPointU8 * toU8AsFloat;\n}\nconst vec4 rgba2float_factors = vec4(\n  255.0 / (256.0),\n  255.0 / (256.0 * 256.0),\n  255.0 / (256.0 * 256.0 * 256.0),\n  255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\n  return dot(rgba, rgba2float_factors);\n}","fsPrecision.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\nprecision highp sampler2D;\n#else\nprecision mediump float;\nprecision mediump sampler2D;\n#endif","highlight.glsl":"vec4 highlightData(vec4 fragCoord, sampler2D depthTex, vec4 viewportPixelSize) {\n  float sceneDepth = texture2D(depthTex, (fragCoord.xy - viewportPixelSize.xy) * viewportPixelSize.zw).r;\n  if (fragCoord.z > sceneDepth + 5e-7) {\n    return vec4(1.0, 1.0, 0.0, 1.0);\n  }\n  else {\n    return vec4(1.0, 0.0, 1.0, 1.0);\n  }\n}","hud.glsl":"#include <util/screenSizePerspective.glsl>\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec4 auxpos1;\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 viewNormal;\nuniform mat4 model;\nuniform mat4 modelNormal;\nuniform vec4 viewport;\nuniform vec3 camPos;\nuniform float polygonOffset;\nuniform float cameraGroundRelative;\nuniform float pixelRatio;\nuniform float perDistancePixelRatio;\n#ifdef VERTICAL_OFFSET\nuniform vec4 verticalOffset;\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspectiveAlignment;\n#endif\nuniform sampler2D hudVisibilityTexture;\nconst float SMALL_OFFSET_ANGLE = 0.984807753012208;\nstruct ProjectHUDAux {\n  vec3 posModel;\n  vec3 posView;\n  vec3 vnormal;\n  float distanceToCamera;\n  float absCosAngle;\n};\nfloat applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {\n  float pointGroundSign = sign(pointGroundDistance);\n  if (pointGroundSign == 0.0) {\n    pointGroundSign = cameraGroundRelative;\n  }\n  float groundRelative = cameraGroundRelative * pointGroundSign;\n  if (polygonOffset > .0) {\n    float cosAlpha = clamp(absCosAngle, 0.01, 1.0);\n    float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\n    float factor = (1.0 - tanAlpha / viewport[2]);\n    if (groundRelative > 0.0) {\n      posView *= factor;\n    }\n    else {\n      posView /= factor;\n    }\n  }\n  return groundRelative;\n}\nvoid applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {\n  float distanceToCamera = length(posView);\n  float pixelOffset = distanceToCamera * perDistancePixelRatio * 0.5;\n  vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;\n  vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n  posModel += modelOffset;\n  posView += viewOffset;\n}\nvec4 projectPositionHUD(out ProjectHUDAux aux) {\n  vec3 centerOffset = auxpos1.xyz;\n  float pointGroundDistance = auxpos1.w;\n  aux.posModel = (model * vec4(position, 1.0)).xyz;\n  aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;\n  aux.vnormal = (modelNormal * vec4(normal, 1.0)).xyz;\n  applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);\n  aux.distanceToCamera = length(aux.posView);\n  vec3 viewDirObjSpace = normalize(camPos - aux.posModel);\n  float cosAngle = dot(aux.vnormal, viewDirObjSpace);\n  aux.absCosAngle = abs(cosAngle);\n#ifdef SCREEN_SIZE_PERSPECTIVE\n#if defined(VERTICAL_OFFSET) || defined(CENTER_OFFSET_UNITS_SCREEN)\n  vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);\n#endif\n#endif\n#ifdef VERTICAL_OFFSET\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);\n#else\n  float verticalOffsetScreenHeight = verticalOffset.x;\n#endif\n  float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);\n  vec3 modelOffset = aux.vnormal * worldOffset;\n  aux.posModel += modelOffset;\n  vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n  aux.posView += viewOffset;\n  pointGroundDistance += worldOffset;\n#endif\n  float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);\n#ifndef CENTER_OFFSET_UNITS_SCREEN\n  aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);\n  if (centerOffset.z != 0.0) {\n    aux.posView -= normalize(aux.posView) * centerOffset.z;\n  }\n#endif\n  vec4 posProj = proj * vec4(aux.posView, 1.0);\n#ifdef CENTER_OFFSET_UNITS_SCREEN\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);\n#else\n  float centerOffsetY = centerOffset.y;\n#endif\n  posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;\n#endif\n  posProj.z -= groundRelative * polygonOffset * posProj.w;\n  return posProj;\n}\nuniform float uRenderTransparentlyOccludedHUD;\nbool testVisibilityHUD(vec4 posProj) {\n  vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);\n  vec4 occlusionPixel = texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);\n  if (uRenderTransparentlyOccludedHUD > 0.5) {\n    return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * uRenderTransparentlyOccludedHUD < 1.0;\n  }\n  return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;\n}","quad.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvarying vec2 uv;\nvoid main(void) {\n  gl_Position = vec4(position.x, position.y, .0, 1.0);\n  uv = position * .5 + vec2(.5);\n}","screenSizePerspective.glsl":"float screenSizePerspectiveMinSize(float size, vec4 factor) {\n  float nonZeroSize = 1.0 - step(size, 0.0);\n  return (\n    factor.z * (\n      1.0 +\n      nonZeroSize *\n      2.0 * factor.w / (\n        size + (1.0 - nonZeroSize)\n      )\n    )\n  );\n}\nfloat screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {\n  return absCosAngle * absCosAngle * absCosAngle;\n}\nvec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {\n  return vec4(min(params.x / (distanceToCamera - params.y), 1.0), screenSizePerspectiveViewAngleDependentFactor(absCosAngle), params.z, params.w);\n}\nfloat applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {\n  return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));\n}\nfloat screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {\n  return applyScreenSizePerspectiveScaleFactorFloat(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n}\nvec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {\n  return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / size.y, 1.0), size, factor.y);\n}\nvec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {\n  return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n}","slice.glsl":"#ifdef SLICE\nuniform vec3 slicePlaneOrigin;\nuniform vec3 slicePlaneBasis1;\nuniform vec3 slicePlaneBasis2;\nstruct SliceFactors {\n  float front;\n  float side0;\n  float side1;\n  float side2;\n  float side3;\n};\nSliceFactors calculateSliceFactors(vec3 pos) {\n  vec3 rel = pos - slicePlaneOrigin;\n  vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);\n  float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);\n  float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);\n  float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);\n  float basis1Dot = dot(slicePlaneBasis1, rel);\n  float basis2Dot = dot(slicePlaneBasis2, rel);\n  return SliceFactors(\n    dot(slicePlaneNormal, pos) + slicePlaneW,\n    -basis1Dot - basis1Len2,\n    basis1Dot - basis1Len2,\n    -basis2Dot - basis2Len2,\n    basis2Dot - basis2Len2\n  );\n}\nbool sliceByFactors(SliceFactors factors) {\n  return factors.front < 0.0\n    && factors.side0 < 0.0\n    && factors.side1 < 0.0\n    && factors.side2 < 0.0\n    && factors.side3 < 0.0;\n}\nbool sliceByPlane(vec3 pos) {\n  return sliceByFactors(calculateSliceFactors(pos));\n}\n#ifdef EXTENSIONS_ENABLED\nvec4 applySliceHighlight(vec4 color, vec3 pos) {\n  SliceFactors factors = calculateSliceFactors(pos);\n  if (sliceByFactors(factors)) {\n    return color;\n  }\n  const float HIGHLIGHT_WIDTH = 1.0;\n  const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);\n  factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);\n  factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);\n  factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);\n  factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);\n  factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);\n  float highlightFactor = (1.0 - step(0.5, factors.front))\n    * (1.0 - step(0.5, factors.side0))\n    * (1.0 - step(0.5, factors.side1))\n    * (1.0 - step(0.5, factors.side2))\n    * (1.0 - step(0.5, factors.side3));\n  return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);\n}\n#else\n#endif\n#define rejectBySlice(_pos_) sliceByPlane(_pos_)\n#define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }\n#ifdef SLICE_HIGHLIGHT_DISABLED\n#define highlightSlice(_color_, _pos_) (_color_)\n#else\n#define highlightSlice(_color_, _pos_) applySliceHighlight(_color_, _pos_)\n#endif\n#else\n#define rejectBySlice(_pos_) false\n#define discardBySlice(_pos_) {}\n#define highlightSlice(_color_, _pos_) (_color_)\n#endif","transform.glsl":"vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {\n  return proj * (view * vec4(pos, 1.0));\n}\nvec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {\n  vec4 eye = view * vec4(pos, 1.0);\n  depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\n  return proj * eye;\n}","visualVariables.glsl":"#ifdef VV_COLOR\n  #define VV_COLOR_N 8\n  uniform float vvColorValues[VV_COLOR_N];\n  uniform vec4 vvColorColors[VV_COLOR_N];\n#endif\n#ifdef VV_SIZE\n  uniform vec3 vvSizeMinSize;\n  uniform vec3 vvSizeMaxSize;\n  uniform vec3 vvSizeOffset;\n  uniform vec3 vvSizeFactor;\n  uniform mat3 vvSymbolRotationMatrix;\n  uniform vec3 vvSymbolAnchor;\n  vec3 vvGetScale(vec4 featureAttribute) {\n    return clamp(vvSizeOffset + featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);\n  }\n  vec4 vvTransformPosition(vec3 position, vec4 featureAttribute) {\n    return vec4(vvSymbolRotationMatrix * (vvGetScale(featureAttribute) * (position + vvSymbolAnchor)), 1.0);\n  }\n  vec4 vvTransformNormal(vec3 normal, vec4 featureAttribute) {\n    return vec4(vvSymbolRotationMatrix * normal / vvGetScale(featureAttribute), 1.0);\n  }\n#endif\n#ifdef VV_COLOR\n  vec4 vvGetColor(vec4 featureAttribute, float values[VV_COLOR_N], vec4 colors[VV_COLOR_N]) {\n    float value = featureAttribute.y;\n    if (value <= values[0]) {\n      return colors[0];\n    }\n    for (int i = 1; i < VV_COLOR_N; ++i) {\n      if (values[i] >= value) {\n        float f = (value - values[i-1]) / (values[i] - values[i-1]);\n        return mix(colors[i-1], colors[i], f);\n      }\n    }\n    return colors[VV_COLOR_N - 1];\n  }\n#endif","vsPrecision.glsl":"precision highp float;\nprecision highp sampler2D;"}}}.apply(null,i))||(e.exports=r)},2721:function(i,r,o){(function(e){var t,n;t=[o.dj.c(i.i),r,o(1628),o(2722),o(1967),o(1971),o(2723),o(1679),o(1693),o(2724),o(1975),o(1859),o(2725),o(2728),o(2730),o(2731),o(1977),o(2732),o(1978),o(2735),o(1855),o(1973),o(1854),o(1858),o(1976),o(2736),o(1629),o(1744)],void 0===(n=function(e,t,r,o,a,s,l,c,u,d,p,f,h,v,m,g,y,b,_,x,S,P,w,A,C,O,M,D){var T,R,I,z,L,E,V,N,j,F,G,H,B,U,k,q,W,Z,X,Y,K,J,Q,$,ee,te,ne,ie,re,oe,ae,se,le,ce,ue,de,pe,fe,he,ve,me,ge,ye,be,_e,xe,Se,Pe,we,Ae,Ce,Oe,Me,De,Te,Re,Ie,ze,Le,Ee,Ve;Object.defineProperty(t,"__esModule",{value:!0}),t.build=function(e){var t=new D.ShaderBuilder,n=t.vertex.code,i=t.fragment.code;return n.add(M.glsl(T=T||r(["\n    // --- Default Material:\n    // ","\n    // ---\n  "],["\n    // --- Default Material:\n    // ","\n    // ---\n  "]),JSON.stringify(e))),i.add(M.glsl(R=R||r(["\n    // --- Default Material:\n    // ","\n    // ---\n  "],["\n    // --- Default Material:\n    // ","\n    // ---\n  "]),JSON.stringify(e))),t.vertex.uniforms.add("proj","mat4").add("view","mat4").add("camPos","vec3").add("localOrigin","vec3"),t.include(d.PositionAttribute),t.varyings.add("vpos","vec3"),t.include(A.VisualVariables,e),e.instanced&&e.instancedDoublePrecision?(t.attributes.add("modelOriginHi","vec3"),t.attributes.add("modelOriginLo","vec3"),t.attributes.add("model","mat3"),t.attributes.add("modelNormal","mat3")):(t.vertex.uniforms.add("model","mat4"),t.vertex.uniforms.add("modelNormal","mat4")),e.instancedDoublePrecision?(t.include(C.DoublePrecision,e),t.vertex.uniforms.add("viewOriginHi","vec3"),t.vertex.uniforms.add("viewOriginLo","vec3"),n.add(M.glsl(I=I||r(["\n    vec3 calculateVPos() {\n      return model * localPosition().xyz;\n    }\n    "],["\n    vec3 calculateVPos() {\n      return model * localPosition().xyz;\n    }\n    "])))):n.add(M.glsl(z=z||r(["\n    vec3 calculateVPos() {\n      return (model * localPosition()).xyz;\n    }\n    "],["\n    vec3 calculateVPos() {\n      return (model * localPosition()).xyz;\n    }\n    "]))),t.include(v.VerticalOffset,e),0===e.output&&(t.include(u.Transform,{linearDepth:!1}),0===e.normalType&&e.offsetBackfaces&&t.include(l.Offset),t.include(g.ComputeNormalTexture,e),t.include(h.VertexNormal,e),e.instancedColor&&t.attributes.add("instanceColor","vec4"),t.varyings.add("localvpos","vec3"),t.include(p.TextureCoordinateAttribute,e),t.include(s.ForwardLinearDepth,e),e.symbolColor?(t.include(o.DecodeSymbolColor),t.attributes.add("symbolColor","vec4"),t.varyings.add("colorMixMode","mediump float")):t.fragment.uniforms.add("colorMixMode","int"),t.include(f.VertexColor,e),t.vertex.uniforms.add("externalColor","vec4"),t.varyings.add("vcolorExt","vec4"),t.vertex.defines.addFloat("SYMBOL_ALPHA_CUTOFF",.001),n.add(M.glsl(L=L||r(["\n      void main(void) {\n        forwardNormalizedVertexColor();\n        vcolorExt = externalColor;\n        ","\n        vcolorExt *= vvColor();\n    "],["\n      void main(void) {\n        forwardNormalizedVertexColor();\n        vcolorExt = externalColor;\n        ","\n        vcolorExt *= vvColor();\n    "]),e.instancedColor?"vcolorExt *= instanceColor;":"")),e.symbolColor&&n.add(M.glsl(E=E||r(["\n        int symbolColorMixMode;\n        vcolorExt *= decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451; // = 1/255;\n        colorMixMode = float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\n      "],["\n        int symbolColorMixMode;\n        vcolorExt *= decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451; // = 1/255;\n        colorMixMode = float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\n      "]))),n.add(M.glsl(V=V||r(["\n        if (vcolorExt.a < SYMBOL_ALPHA_CUTOFF) {\n          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        }\n        else {\n          vpos = calculateVPos();\n          localvpos = vpos - view[3].xyz;\n    "],["\n        if (vcolorExt.a < SYMBOL_ALPHA_CUTOFF) {\n          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        }\n        else {\n          vpos = calculateVPos();\n          localvpos = vpos - view[3].xyz;\n    "]))),e.instancedDoublePrecision?(0===e.normalType&&n.add(M.glsl(N=N||r(["\n          vNormalWorld = normalize(modelNormal * vvLocalNormal(normalModel()).xyz);\n        "],["\n          vNormalWorld = normalize(modelNormal * vvLocalNormal(normalModel()).xyz);\n        "]))),n.add(M.glsl(j=j||r(["\n          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n          vpos -= originDelta;\n      "],["\n          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n          vpos -= originDelta;\n      "])))):0===e.normalType&&n.add(M.glsl(F=F||r(["\n          vNormalWorld = normalize((modelNormal * vvLocalNormal(normalModel())).xyz);\n        "],["\n          vNormalWorld = normalize((modelNormal * vvLocalNormal(normalModel())).xyz);\n        "]))),n.add(M.glsl(G=G||r(["\n          ","\n          ","\n          gl_Position = transformPosition(proj, view, vpos);\n          ","\n        }\n        forwardLinearDepth();\n        forwardTextureCoordinates();\n      }\n    "],["\n          ","\n          ","\n          gl_Position = transformPosition(proj, view, vpos);\n          ","\n        }\n        forwardLinearDepth();\n        forwardTextureCoordinates();\n      }\n    "]),e.verticalOffsetEnabled?"vpos += calculateVerticalOffset(vpos, localOrigin);":"",e.vertexTangets?"transformVertexTangent(mat3(modelNormal));":"",0===e.normalType&&e.offsetBackfaces?"gl_Position = offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, camPos);":"")),t.include(c.Slice,e),t.include(b.EvaluateSceneLighting,e),t.include(y.EvaluateAmbientOcclusion,e),t.include(a.DiscardOrAdjustAlpha,e),e.receiveShadows&&t.include(w.ReadShadowMap,e),t.fragment.uniforms.add("camPos","vec3").add("localOrigin","vec3").add("ambient","vec3").add("diffuse","vec3").add("specular","vec3").add("opacity","float").add("layerOpacity","float"),e.treeRendering&&t.fragment.uniforms.add("view","mat4"),e.hasColorTexture&&t.fragment.uniforms.add("tex","sampler2D"),3===e.normalType&&t.extensions.add("GL_OES_standard_derivatives"),t.include(P.PhysicallyBasedRenderingParameters,e),t.include(S.PhysicallyBasedRendering,e),t.include(O.MixExternalColor,{stages:1}),t.include(x.Normals,e),i.add(M.glsl(H=H||r(["\n        void main() {\n          discardBySlice(vpos);\n    "],["\n        void main() {\n          discardBySlice(vpos);\n    "]))),e.hasColorTexture?(i.add(M.glsl(B=B||r(["\n          vec4 texColor = texture2D(tex, vuv0);\n      "],["\n          vec4 texColor = texture2D(tex, vuv0);\n      "]))),e.textureAlphaPremultiplied&&i.add(M.glsl(U=U||r(["\n            texColor.rgb /= texColor.a;\n        "],["\n            texColor.rgb /= texColor.a;\n        "]))),i.add(M.glsl(k=k||r(["\n            discardOrAdjustAlpha(texColor);\n      "],["\n            discardOrAdjustAlpha(texColor);\n      "])))):i.add(M.glsl(q=q||r(["\n            vec4 texColor = vec4(1.0);\n      "],["\n            vec4 texColor = vec4(1.0);\n      "]))),i.add(M.glsl(W=W||r(["\n            shadingParams.viewDirection = normalize(vpos - camPos);\n    "],["\n            shadingParams.viewDirection = normalize(vpos - camPos);\n    "]))),3===e.normalType?i.add(M.glsl(Z=Z||r(["\n        vec3 normal = normalize(cross(dFdx(localvpos),dFdy(localvpos)));\n      "],["\n        vec3 normal = normalize(cross(dFdx(localvpos),dFdy(localvpos)));\n      "]))):i.add(M.glsl(X=X||r(["\n        shadingParams.normalView = vNormalWorld;\n        vec3 normal = shadingNormal(shadingParams);\n      "],["\n        shadingParams.normalView = vNormalWorld;\n        vec3 normal = shadingNormal(shadingParams);\n      "]))),e.usePBR&&i.add(M.glsl(Y=Y||r(["applyPBRFactors();"],["applyPBRFactors();"]))),i.add(M.glsl(K=K||r(["\n        float ssao = evaluateAmbientOcclusionInverse();\n        ssao *= getBakedOcclusion();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n    "],["\n        float ssao = evaluateAmbientOcclusionInverse();\n        ssao *= getBakedOcclusion();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n    "]))),e.receiveShadows?t.fragment.code.add(M.glsl(J=J||r(["\n        float shadow = readShadowMap(vpos, linearDepth);\n      "],["\n        float shadow = readShadowMap(vpos, linearDepth);\n      "]))):0===e.viewingMode?t.fragment.code.add(M.glsl(Q=Q||r(["\n        float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n      "],["\n        float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n      "]))):t.fragment.code.add(M.glsl($=$||r(["\n        float shadow = 0.0;\n      "],["\n        float shadow = 0.0;\n      "]))),i.add(M.glsl(ee=ee||r(["\n        vec3 matColor = max(ambient, diffuse);\n    "],["\n        vec3 matColor = max(ambient, diffuse);\n    "]))),e.attributeColor?i.add(M.glsl(te=te||r(["\n        vec3 albedo_ = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "],["\n        vec3 albedo_ = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "]))):(i.add(M.glsl(ne=ne||r(["\n        vec3 albedo_ = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "],["\n        vec3 albedo_ = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "]))),e.usePBR&&i.add(M.glsl(ie=ie||r(["\n          if (int(colorMixMode) == 3 /* replace */) {\n            reflectance = 0.2;\n            roughness = 0.6;\n            metalness = 0.0;\n          }\n        "],["\n          if (int(colorMixMode) == 3 /* replace */) {\n            reflectance = 0.2;\n            roughness = 0.6;\n            metalness = 0.0;\n          }\n        "])))),e.hasNormalTexture?(e.vertexTangets?i.add(M.glsl(re=re||r(["\n        mat3 tangentSpace = computeTangentSpace(normal);\n        "],["\n        mat3 tangentSpace = computeTangentSpace(normal);\n        "]))):i.add(M.glsl(oe=oe||r(["\n        mat3 tangentSpace = computeTangentSpace(normal, vpos, vuv0);\n        "],["\n        mat3 tangentSpace = computeTangentSpace(normal, vpos, vuv0);\n        "]))),i.add(M.glsl(ae=ae||r(["\n        vec3 shadedNormal = computeTextureNormal(tangentSpace, vuv0);\n      "],["\n        vec3 shadedNormal = computeTextureNormal(tangentSpace, vuv0);\n      "])))):i.add(M.glsl(se=se||r(["\n        vec3 shadedNormal = normal;\n      "],["\n        vec3 shadedNormal = normal;\n      "]))),e.treeRendering&&i.add(M.glsl(le=le||r(["\n        shadedNormal = normalize(vNormalWorld);\n        albedo_ *= 1.2;\n        vec3 viewForward = - vec3(view[0][2], view[1][2], view[2][2]);\n        float alignmentLightView = clamp(dot(-viewForward, lightingMainDirection), 0.0, 1.0);\n\n        float transmittance = 1.0 - clamp(dot(-viewForward, shadedNormal), 0.0, 1.0);\n        float treeRadialFalloff = vColor.r;\n        float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\n        additionalLight += backLightFactor * lightingMainIntensity;\n    "],["\n        shadedNormal = normalize(vNormalWorld);\n        albedo_ *= 1.2;\n        vec3 viewForward = - vec3(view[0][2], view[1][2], view[2][2]);\n        float alignmentLightView = clamp(dot(-viewForward, lightingMainDirection), 0.0, 1.0);\n\n        float transmittance = 1.0 - clamp(dot(-viewForward, shadedNormal), 0.0, 1.0);\n        float treeRadialFalloff = vColor.r;\n        float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\n        additionalLight += backLightFactor * lightingMainIntensity;\n    "]))),e.usePBR?i.add(M.glsl(ce=ce||r(["\n        float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n        vec3 normalGround = normalize(vpos + localOrigin);\n        vec3 shadedColor = evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, roughness, metalness, emission, reflectance, additionalAmbientIrradiance);\n      "],["\n        float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n        vec3 normalGround = normalize(vpos + localOrigin);\n        vec3 shadedColor = evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, roughness, metalness, emission, reflectance, additionalAmbientIrradiance);\n      "]))):i.add(M.glsl(ue=ue||r(["\n        vec3 shadedColor = evaluateSceneLighting(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight);\n      "],["\n        vec3 shadedColor = evaluateSceneLighting(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight);\n      "]))),i.add(M.glsl(de=de||r(["\n        gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "],["\n        gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "])))),1!==e.output&&3!==e.output||(t.include(u.Transform,{linearDepth:!0}),t.include(p.TextureCoordinateAttribute,e),t.include(A.VisualVariables,e),t.include(m.OutputDepth,e),t.include(c.Slice,e),t.vertex.uniforms.add("nearFar","vec2"),t.varyings.add("depth","float"),e.hasColorTexture&&t.fragment.uniforms.add("tex","sampler2D"),n.add(M.glsl(pe=pe||r(["\n      void main(void) {\n        vpos = calculateVPos();\n    "],["\n      void main(void) {\n        vpos = calculateVPos();\n    "]))),e.instancedDoublePrecision&&n.add(M.glsl(fe=fe||r(["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "],["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "]))),e.verticalOffsetEnabled&&n.add(M.glsl(he=he||r(["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "],["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "]))),n.add(M.glsl(ve=ve||r(["\n        gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        forwardTextureCoordinates();\n      }\n    "],["\n        gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        forwardTextureCoordinates();\n      }\n    "]))),t.include(a.DiscardOrAdjustAlpha,e),i.add(M.glsl(me=me||r(["\n      void main(void) {\n        discardBySlice(vpos);\n    "],["\n      void main(void) {\n        discardBySlice(vpos);\n    "]))),e.hasColorTexture&&i.add(M.glsl(ge=ge||r(["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "],["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "]))),i.add(M.glsl(ye=ye||r(["\n        outputDepth(depth);\n      }\n    "],["\n        outputDepth(depth);\n      }\n    "])))),2===e.output&&(3===e.normalType&&t.extensions.add("GL_OES_standard_derivatives"),t.include(u.Transform,{linearDepth:!1}),t.include(h.VertexNormal,e),t.include(p.TextureCoordinateAttribute,e),t.include(A.VisualVariables,e),e.hasColorTexture&&t.fragment.uniforms.add("tex","sampler2D"),t.vertex.uniforms.add("viewNormal","mat4"),t.varyings.add("vPositionView","vec3"),n.add(M.glsl(be=be||r(["\n      void main(void) {\n        vpos = calculateVPos();\n    "],["\n      void main(void) {\n        vpos = calculateVPos();\n    "]))),e.instancedDoublePrecision?(0===e.normalType&&n.add(M.glsl(_e=_e||r(["\n        vNormalWorld = normalize((viewNormal * vec4(modelNormal * vvLocalNormal(normalModel()).xyz, 1.0)).xyz);\n        "],["\n        vNormalWorld = normalize((viewNormal * vec4(modelNormal * vvLocalNormal(normalModel()).xyz, 1.0)).xyz);\n        "]))),n.add(M.glsl(xe=xe||r(["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "],["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "])))):0===e.normalType&&n.add(M.glsl(Se=Se||r(["\n        vNormalWorld = normalize((viewNormal * modelNormal * vvLocalNormal(normalModel())).xyz);\n        "],["\n        vNormalWorld = normalize((viewNormal * modelNormal * vvLocalNormal(normalModel())).xyz);\n        "]))),e.verticalOffsetEnabled&&n.add(M.glsl(Pe=Pe||r(["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "],["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "]))),n.add(M.glsl(we=we||r(["\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "],["\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "]))),t.include(c.Slice,e),t.include(a.DiscardOrAdjustAlpha,e),i.add(M.glsl(Ae=Ae||r(["\n      void main() {\n        discardBySlice(vpos);\n    "],["\n      void main() {\n        discardBySlice(vpos);\n    "]))),e.hasColorTexture&&i.add(M.glsl(Ce=Ce||r(["\n          vec4 texColor = texture2D(tex, vuv0);\n          discardOrAdjustAlpha(texColor);\n      "],["\n          vec4 texColor = texture2D(tex, vuv0);\n          discardOrAdjustAlpha(texColor);\n      "]))),3===e.normalType?i.add(M.glsl(Oe=Oe||r(["\n        vec3 normal = normalize(cross(dFdx(vPositionView),dFdy(vPositionView)));\n      "],["\n        vec3 normal = normalize(cross(dFdx(vPositionView),dFdy(vPositionView)));\n      "]))):i.add(M.glsl(Me=Me||r(["\n        vec3 normal = normalize(vNormalWorld);\n        if (gl_FrontFacing == false) normal = -normal;\n      "],["\n        vec3 normal = normalize(vNormalWorld);\n        if (gl_FrontFacing == false) normal = -normal;\n      "]))),i.add(M.glsl(De=De||r(["\n        gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n      }\n    "],["\n        gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n      }\n    "])))),4===e.output&&(t.include(u.Transform,{linearDepth:!1}),t.include(p.TextureCoordinateAttribute,e),t.include(A.VisualVariables,e),e.hasColorTexture&&t.fragment.uniforms.add("tex","sampler2D"),n.add(M.glsl(Te=Te||r(["\n      void main(void) {\n        vpos = calculateVPos();\n    "],["\n      void main(void) {\n        vpos = calculateVPos();\n    "]))),e.instancedDoublePrecision&&n.add(M.glsl(Re=Re||r(["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "],["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "]))),e.verticalOffsetEnabled&&n.add(M.glsl(Ie=Ie||r(["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "],["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "]))),n.add(M.glsl(ze=ze||r(["\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "],["\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "]))),t.include(c.Slice,e),t.include(a.DiscardOrAdjustAlpha,e),t.include(_.HighlightData),t.fragment.uniforms.add("depthTex","sampler2D"),t.fragment.uniforms.add("highlightViewportPixelSz","vec4"),i.add(M.glsl(Le=Le||r(["\n      void main() {\n        discardBySlice(vpos);\n    "],["\n      void main() {\n        discardBySlice(vpos);\n    "]))),e.hasColorTexture&&i.add(M.glsl(Ee=Ee||r(["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "],["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "]))),i.add(M.glsl(Ve=Ve||r(["\n        gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n      }\n    "],["\n        gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n      }\n    "])))),t}}.apply(null,t))||(i.exports=n)}).call(this,require("jquery"))},2722:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.DecodeSymbolColor=function(e){e.vertex.code.add(i.glsl(r=r||n(["\n    vec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {\n      float symbolAlpha = 0.0;\n\n      const float maxTint = 85.0;\n      const float maxReplace = 170.0;\n      const float scaleAlpha = 3.0;\n\n      if (symbolColor.a > maxReplace) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * (symbolColor.a - maxReplace);\n      } else if (symbolColor.a > maxTint) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * (symbolColor.a - maxTint);\n      } else if (symbolColor.a > 0.0) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * symbolColor.a;\n      } else {\n        colorMixMode = ",";\n        symbolAlpha = 0.0;\n      }\n\n      return vec4(symbolColor.r, symbolColor.g, symbolColor.b, symbolAlpha);\n    }\n  "],["\n    vec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {\n      float symbolAlpha = 0.0;\n\n      const float maxTint = 85.0;\n      const float maxReplace = 170.0;\n      const float scaleAlpha = 3.0;\n\n      if (symbolColor.a > maxReplace) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * (symbolColor.a - maxReplace);\n      } else if (symbolColor.a > maxTint) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * (symbolColor.a - maxTint);\n      } else if (symbolColor.a > 0.0) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * symbolColor.a;\n      } else {\n        colorMixMode = ",";\n        symbolAlpha = 0.0;\n      }\n\n      return vec4(symbolColor.r, symbolColor.g, symbolColor.b, symbolAlpha);\n    }\n  "]),i.glsl.int(1),i.glsl.int(3),i.glsl.int(4),i.glsl.int(1)))}}.apply(null,i))||(e.exports=r)},2723:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.Offset=function(e){e.vertex.code.add(i.glsl(r=r||n(["\n    vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {\n      vec3 camToVert = posWorld - camPosWorld;\n\n      bool isBackface = dot(camToVert, normalWorld) > 0.0;\n      if (isBackface) {\n        posClip.z += 0.0000003 * posClip.w;\n      }\n      return posClip;\n    }\n  "],["\n    vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {\n      vec3 camToVert = posWorld - camPosWorld;\n\n      bool isBackface = dot(camToVert, normalWorld) > 0.0;\n      if (isBackface) {\n        posClip.z += 0.0000003 * posClip.w;\n      }\n      return posClip;\n    }\n  "])))}}.apply(null,i))||(e.exports=r)},2724:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.PositionAttribute=function(e){e.attributes.add("position","vec3"),e.vertex.code.add(i.glsl(r=r||n(["\n    vec3 positionModel() { return position; }\n  "],["\n    vec3 positionModel() { return position; }\n  "])))}}.apply(null,i))||(e.exports=r)},2725:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(2726),n(1629)],void 0===(r=function(e,t,n,i,r){function o(e,t){0===t.normalType||1===t.normalType?(e.include(i.NormalAttribute,t),e.varyings.add("vNormalWorld","vec3"),e.varyings.add("vNormalView","vec3"),e.vertex.uniforms.add("uTransformNormal_GlobalFromModel","mat3"),e.vertex.uniforms.add("uTransformNormal_ViewFromGlobal","mat3"),e.vertex.code.add(r.glsl(a=a||n(["\n      void forwardNormal() {\n        vNormalWorld = uTransformNormal_GlobalFromModel * normalModel();\n        vNormalView = uTransformNormal_ViewFromGlobal * vNormalWorld;\n      }\n    "],["\n      void forwardNormal() {\n        vNormalWorld = uTransformNormal_GlobalFromModel * normalModel();\n        vNormalView = uTransformNormal_ViewFromGlobal * vNormalWorld;\n      }\n    "])))):e.vertex.code.add(r.glsl(s=s||n(["\n      void forwardNormal() {}\n    "],["\n      void forwardNormal() {}\n    "])))}var a,s;Object.defineProperty(t,"__esModule",{value:!0}),t.VertexNormal=o,(o=t.VertexNormal||(t.VertexNormal={})).bindUniforms=function(e,t){e.setUniformMatrix4fv("viewNormal",t.viewInvTransp)}}.apply(null,i))||(e.exports=r)},2726:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(2727),n(1629)],void 0===(r=function(e,t,n,i,r){var o,a;Object.defineProperty(t,"__esModule",{value:!0}),t.NormalAttribute=function(e,t){0===t.normalType&&(e.attributes.add("normal","vec3"),e.vertex.code.add(r.glsl(o=o||n(["\n      vec3 normalModel() {\n        return normal;\n      }\n    "],["\n      vec3 normalModel() {\n        return normal;\n      }\n    "])))),1===t.normalType&&(e.include(i.DecodeNormal),e.attributes.add("normalCompressed","vec2"),e.vertex.code.add(r.glsl(a=a||n(["\n      vec3 normalModel() {\n        return decodeNormal(normalCompressed);\n      }\n    "],["\n      vec3 normalModel() {\n        return decodeNormal(normalCompressed);\n      }\n    "]))))}}.apply(null,i))||(e.exports=r)},2727:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.DecodeNormal=function(e){var t=i.glsl(r=r||n(["\n    vec3 decodeNormal(vec2 f) {\n      float z = 1.0 - abs(f.x) - abs(f.y);\n      return vec3(f + sign(f) * min(z, 0.0), z);\n    }\n  "],["\n    vec3 decodeNormal(vec2 f) {\n      float z = 1.0 - abs(f.x) - abs(f.y);\n      return vec3(f + sign(f) * min(z, 0.0), z);\n    }\n  "]));e.fragment.code.add(t),e.vertex.code.add(t)}}.apply(null,i))||(e.exports=r)},2728:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(2729),n(1629)],void 0===(r=function(e,t,i,r,o){var a,s,l,c,u,d;Object.defineProperty(t,"__esModule",{value:!0}),t.VerticalOffset=function(e,t){var n=e.vertex.code;t.verticalOffsetEnabled&&(e.vertex.uniforms.add("verticalOffset","vec4"),t.screenSizePerspectiveEnabled&&(e.include(r.ScreenSizePerspective),e.vertex.uniforms.add("screenSizePerspectiveAlignment","vec4")),n.add(o.glsl(a=a||i(["\n    vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);\n    "],["\n    vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);\n    "]))),0===t.viewingMode?n.add(o.glsl(s=s||i(["\n      vec3 worldNormal = normalize(worldPos + localOrigin);\n    "],["\n      vec3 worldNormal = normalize(worldPos + localOrigin);\n    "]))):n.add(o.glsl(l=l||i(["\n      vec3 worldNormal = vec3(0.0, 0.0, 1.0);\n    "],["\n      vec3 worldNormal = vec3(0.0, 0.0, 1.0);\n    "]))),t.screenSizePerspectiveEnabled?n.add(o.glsl(c=c||i(["\n      float cosAngle = dot(worldNormal, normalize(worldPos - camPos));\n      float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);\n    "],["\n      float cosAngle = dot(worldNormal, normalize(worldPos - camPos));\n      float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);\n    "]))):n.add(o.glsl(u=u||i(["\n      float verticalOffsetScreenHeight = verticalOffset.x;\n    "],["\n      float verticalOffsetScreenHeight = verticalOffset.x;\n    "]))),n.add(o.glsl(d=d||i(["\n      float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\n      return worldNormal * worldOffset;\n    }\n    "],["\n      float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\n      return worldNormal * worldOffset;\n    }\n    "]))))}}.apply(null,i))||(e.exports=r)},2729:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r,o,a,s,l,c,u;Object.defineProperty(t,"__esModule",{value:!0}),t.ScreenSizePerspective=function(e){e.vertex.code.add(i.glsl(r=r||n(["\n    float screenSizePerspectiveMinSize(float size, vec4 factor) {\n      float nonZeroSize = 1.0 - step(size, 0.0);\n\n      return (\n        factor.z * (\n          1.0 +\n          nonZeroSize *                // Multiply by nzs ensures if size is 0, then we ignore\n                                      // proportionally scaled padding\n          2.0 * factor.w / (\n            size + (1.0 - nonZeroSize) // Adding 1 - nzs ensures we divide either by size, or by 1\n          )\n        )\n      );\n    }\n  "],["\n    float screenSizePerspectiveMinSize(float size, vec4 factor) {\n      float nonZeroSize = 1.0 - step(size, 0.0);\n\n      return (\n        factor.z * (\n          1.0 +\n          nonZeroSize *                // Multiply by nzs ensures if size is 0, then we ignore\n                                      // proportionally scaled padding\n          2.0 * factor.w / (\n            size + (1.0 - nonZeroSize) // Adding 1 - nzs ensures we divide either by size, or by 1\n          )\n        )\n      );\n    }\n  "]))),e.vertex.code.add(i.glsl(o=o||n(["\n    float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {\n      return absCosAngle * absCosAngle * absCosAngle;\n    }\n  "],["\n    float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {\n      return absCosAngle * absCosAngle * absCosAngle;\n    }\n  "]))),e.vertex.code.add(i.glsl(a=a||n(["\n    vec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {\n      return vec4(min(params.x / (distanceToCamera - params.y), 1.0), screenSizePerspectiveViewAngleDependentFactor(absCosAngle), params.z, params.w);\n    }\n  "],["\n    vec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {\n      return vec4(min(params.x / (distanceToCamera - params.y), 1.0), screenSizePerspectiveViewAngleDependentFactor(absCosAngle), params.z, params.w);\n    }\n  "]))),e.vertex.code.add(i.glsl(s=s||n(["\n    float applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {\n      return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));\n    }\n  "],["\n    float applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {\n      return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));\n    }\n  "]))),e.vertex.code.add(i.glsl(l=l||n(["\n    float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {\n      return applyScreenSizePerspectiveScaleFactorFloat(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n    }\n  "],["\n    float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {\n      return applyScreenSizePerspectiveScaleFactorFloat(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n    }\n  "]))),e.vertex.code.add(i.glsl(c=c||n(["\n    vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {\n      return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / size.y, 1.0), size, factor.y);\n    }\n  "],["\n    vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {\n      return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / size.y, 1.0), size, factor.y);\n    }\n  "]))),e.vertex.code.add(i.glsl(u=u||n(["\n    vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {\n      return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n    }\n  "],["\n    vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {\n      return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n    }\n  "])))}}.apply(null,i))||(e.exports=r)},2730:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1972),n(1629)],void 0===(r=function(e,t,n,i,r){var o,a;Object.defineProperty(t,"__esModule",{value:!0}),t.OutputDepth=function(e,t){e.include(i.RgbaFloatEncoding),3===t.output?(e.extensions.add("GL_OES_standard_derivatives"),e.fragment.code.add(r.glsl(o=o||n(["\n      float _calculateFragDepth(const in float depth) {\n        // calc polygon offset\n        const float SLOPE_SCALE = 2.0;\n        const float BIAS = 2.0 * .000015259;    // 1 / (2^16 - 1)\n        float m = max(abs(dFdx(depth)), abs(dFdy(depth)));\n        float result = depth + SLOPE_SCALE * m + BIAS;\n        return clamp(result, .0, .999999);\n      }\n\n      void outputDepth(float _linearDepth) {\n        gl_FragColor = float2rgba(_calculateFragDepth(_linearDepth));\n      }\n    "],["\n      float _calculateFragDepth(const in float depth) {\n        // calc polygon offset\n        const float SLOPE_SCALE = 2.0;\n        const float BIAS = 2.0 * .000015259;    // 1 / (2^16 - 1)\n        float m = max(abs(dFdx(depth)), abs(dFdy(depth)));\n        float result = depth + SLOPE_SCALE * m + BIAS;\n        return clamp(result, .0, .999999);\n      }\n\n      void outputDepth(float _linearDepth) {\n        gl_FragColor = float2rgba(_calculateFragDepth(_linearDepth));\n      }\n    "])))):1===t.output&&e.fragment.code.add(r.glsl(a=a||n(["\n      void outputDepth(float _linearDepth) {\n        gl_FragColor = float2rgba(_linearDepth);\n      }\n    "],["\n      void outputDepth(float _linearDepth) {\n        gl_FragColor = float2rgba(_linearDepth);\n      }\n    "])))}}.apply(null,i))||(e.exports=r)},2731:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1974),n(1629)],void 0===(r=function(e,t,i,r,o){var a,s,l,c,u;Object.defineProperty(t,"__esModule",{value:!0}),t.ComputeNormalTexture=function(e,t){var n=e.fragment;n.uniforms.add("normalTexture","sampler2D"),n.uniforms.add("normalTextureSize","vec2"),t.vertexTangets?(e.attributes.add("tangent","vec4"),e.varyings.add("vTangent","vec4"),e.vertex.code.add(o.glsl(a=a||i(["\n      void transformVertexTangent(mat3 modelTransformForNormals) {\n        vTangent.xyz = modelTransformForNormals * tangent.xyz;\n        vTangent.w = tangent.w;\n      }\n    "],["\n      void transformVertexTangent(mat3 modelTransformForNormals) {\n        vTangent.xyz = modelTransformForNormals * tangent.xyz;\n        vTangent.w = tangent.w;\n      }\n    "]))),2===t.doubleSidedMode?n.code.add(o.glsl(s=s||i(["\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;\n        vec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);\n        vec3 bitangent = cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    "],["\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;\n        vec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);\n        vec3 bitangent = cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    "]))):n.code.add(o.glsl(l=l||i(["\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness = vTangent.w;\n        vec3 tangent = normalize(vTangent.xyz);\n        vec3 bitangent = cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    "],["\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness = vTangent.w;\n        vec3 tangent = normalize(vTangent.xyz);\n        vec3 bitangent = cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    "])))):(e.extensions.add("GL_OES_standard_derivatives"),n.code.add(o.glsl(c=c||i(['\n    mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {\n\n      vec3 Q1 = dFdx(pos);\n      vec3 Q2 = dFdy(pos);\n\n      vec2 stx = dFdx(st);\n      vec2 sty = dFdy(st);\n\n      float det = stx.t * sty.s - sty.t * stx.s;\n\n      vec3 T = stx.t * Q2 - sty.t * Q1; // compute tangent\n      T = T - normal * dot(normal, T); // orthogonalize tangent\n      T *= inversesqrt(max(dot(T,T), 1.e-10)); // "soft" normalize - goes to 0 when T goes to 0\n      vec3 B = sign(det) * cross(normal, T); // assume normal is normalized, B has the same lenght as B\n      return mat3(T, B, normal); // T and B go to 0 when the tangent space is not well defined by the uv coordinates\n    }\n  '],['\n    mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {\n\n      vec3 Q1 = dFdx(pos);\n      vec3 Q2 = dFdy(pos);\n\n      vec2 stx = dFdx(st);\n      vec2 sty = dFdy(st);\n\n      float det = stx.t * sty.s - sty.t * stx.s;\n\n      vec3 T = stx.t * Q2 - sty.t * Q1; // compute tangent\n      T = T - normal * dot(normal, T); // orthogonalize tangent\n      T *= inversesqrt(max(dot(T,T), 1.e-10)); // "soft" normalize - goes to 0 when T goes to 0\n      vec3 B = sign(det) * cross(normal, T); // assume normal is normalized, B has the same lenght as B\n      return mat3(T, B, normal); // T and B go to 0 when the tangent space is not well defined by the uv coordinates\n    }\n  '])))),0!==t.attributeTextureCoordinates&&(e.include(r.VertexTextureCoordinates,t),n.code.add(o.glsl(u=u||i(["\n    vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {\n      vtc.uv = uv;\n      ","\n      vec3 rawNormal = textureLookup(normalTexture, vtc).rgb * 2.0 - 1.0;\n      return tangentSpace * rawNormal;\n    }\n  "],["\n    vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {\n      vtc.uv = uv;\n      ","\n      vec3 rawNormal = textureLookup(normalTexture, vtc).rgb * 2.0 - 1.0;\n      return tangentSpace * rawNormal;\n    }\n  "]),t.supportsTextureAtlas?"vtc.size = normalTextureSize;":"")))}}.apply(null,i))||(e.exports=r)},2732:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(2733),n(1977),n(2734),n(1855),n(1856),n(1854),n(1629)],void 0===(r=function(e,t,i,r,o,a,s,l,c,u){var d,p,f,h,v,m,g,y,b,_,x;Object.defineProperty(t,"__esModule",{value:!0}),t.EvaluateSceneLighting=function(e,t){var n=e.fragment;e.include(a.EvaluateMainLighting),e.include(o.EvaluateAmbientOcclusion,t),t.usePBR&&e.include(s.PhysicallyBasedRendering,t),e.include(r.EvaluateAmbientLighting,t),t.receiveShadows&&e.include(c.ReadShadowMap,t),n.uniforms.add("lightingGlobalFactor","float"),n.uniforms.add("ambientBoostFactor","float"),t.useOldSceneLightInterface?(e.include(l.PiUtils),n.code.add(u.glsl(d=d||i(["\n    const float GAMMA_SRGB = 2.1;\n    const float INV_GAMMA_SRGB = 0.4761904;  // 1 / GAMMA_SRGB\n\n    vec3 evaluateSceneLightingExt(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight) {\n      // evaluate the main light\n      #if defined(TREE_RENDERING)\n        // Special case for tree rendering:\n        // We shift the Lambert lobe to the back, allowing it to reach part of the hemisphere\n        // facing away from the light. The idea is to get an effect where light is transmitted\n        // through the tree.\n        float minDot = -0.5;\n        float dotRange = 1.0 - minDot;\n        float dotNormalization = 0.66; // guessed & hand tweaked value, for an exact value we could precompute an integral over the sphere\n\n        float dotVal = dotNormalization * (clamp(-dot(normal, lightingMainDirection), 1.0 - dotRange, 1.0) - minDot) * (1.0 / dotRange);\n      #else\n        float dotVal = clamp(-dot(normal, lightingMainDirection), 0.0, 1.0);\n      #endif\n\n      // move lighting towards (1.0, 1.0, 1.0) if requested\n      dotVal = mix(dotVal, 1.0, lightingFixedFactor);\n\n      vec3 mainLight = (1.0 - shadow) * lightingMainIntensity * dotVal;\n      vec3 ambientLight = calculateAmbientIrradiance(normal, ssao);\n\n      // inverse gamma correction on the albedo color\n      vec3 albedoGammaC = pow(albedo, vec3(GAMMA_SRGB));\n\n      // physically correct BRDF normalizes by PI\n      vec3 totalLight = mainLight + ambientLight + additionalLight;\n      totalLight = min(totalLight, vec3(PI, PI, PI));\n      vec3 outColor = vec3((albedoGammaC / PI) * (totalLight));\n\n      // apply gamma correction to the computed color\n      outColor = pow(outColor, vec3(1.0/GAMMA_SRGB));\n\n      return outColor;\n    }\n  "],["\n    const float GAMMA_SRGB = 2.1;\n    const float INV_GAMMA_SRGB = 0.4761904;  // 1 / GAMMA_SRGB\n\n    vec3 evaluateSceneLightingExt(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight) {\n      // evaluate the main light\n      #if defined(TREE_RENDERING)\n        // Special case for tree rendering:\n        // We shift the Lambert lobe to the back, allowing it to reach part of the hemisphere\n        // facing away from the light. The idea is to get an effect where light is transmitted\n        // through the tree.\n        float minDot = -0.5;\n        float dotRange = 1.0 - minDot;\n        float dotNormalization = 0.66; // guessed & hand tweaked value, for an exact value we could precompute an integral over the sphere\n\n        float dotVal = dotNormalization * (clamp(-dot(normal, lightingMainDirection), 1.0 - dotRange, 1.0) - minDot) * (1.0 / dotRange);\n      #else\n        float dotVal = clamp(-dot(normal, lightingMainDirection), 0.0, 1.0);\n      #endif\n\n      // move lighting towards (1.0, 1.0, 1.0) if requested\n      dotVal = mix(dotVal, 1.0, lightingFixedFactor);\n\n      vec3 mainLight = (1.0 - shadow) * lightingMainIntensity * dotVal;\n      vec3 ambientLight = calculateAmbientIrradiance(normal, ssao);\n\n      // inverse gamma correction on the albedo color\n      vec3 albedoGammaC = pow(albedo, vec3(GAMMA_SRGB));\n\n      // physically correct BRDF normalizes by PI\n      vec3 totalLight = mainLight + ambientLight + additionalLight;\n      totalLight = min(totalLight, vec3(PI, PI, PI));\n      vec3 outColor = vec3((albedoGammaC / PI) * (totalLight));\n\n      // apply gamma correction to the computed color\n      outColor = pow(outColor, vec3(1.0/GAMMA_SRGB));\n\n      return outColor;\n    }\n  "])))):(0===t.viewingMode?n.code.add(u.glsl(p=p||i(["\n      float _oldHeuristicLighting(vec3 vPosWorld) {\n        vec3 shadingNormalWorld = normalize(vPosWorld);\n        float vndl = -dot(shadingNormalWorld, lightingMainDirection);\n\n        return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n      }\n    "],["\n      float _oldHeuristicLighting(vec3 vPosWorld) {\n        vec3 shadingNormalWorld = normalize(vPosWorld);\n        float vndl = -dot(shadingNormalWorld, lightingMainDirection);\n\n        return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n      }\n    "]))):n.code.add(u.glsl(f=f||i(["\n      float _oldHeuristicLighting(vec3 vPosWorld) {\n        float vndl = -dot(vec3(0.0, 0.0, 1.0), lightingMainDirection);\n        return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n      }\n    "],["\n      float _oldHeuristicLighting(vec3 vPosWorld) {\n        float vndl = -dot(vec3(0.0, 0.0, 1.0), lightingMainDirection);\n        return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n      }\n    "]))),n.code.add(u.glsl(h=h||i(["\n      vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\n        float additionalAmbientScale = _oldHeuristicLighting(vPosWorld);\n        return (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * lightingMainIntensity;\n      }\n    "],["\n      vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\n        float additionalAmbientScale = _oldHeuristicLighting(vPosWorld);\n        return (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * lightingMainIntensity;\n      }\n    "]))),t.usePBR?(n.code.add(u.glsl(m=m||i(["\n      // The albedo color of the ground used in the environment illumination algorithm\n      const float GROUND_REFLECTANCE = 0.2; //This is the set value of the diffuse reflectance of the ground surface\n\n      const float GAMMA_SRGB = 2.1;\n      const float INV_GAMMA_SRGB = 0.4761904;  // 1 / GAMMA_SRGB\n      "],["\n      // The albedo color of the ground used in the environment illumination algorithm\n      const float GROUND_REFLECTANCE = 0.2; //This is the set value of the diffuse reflectance of the ground surface\n\n      const float GAMMA_SRGB = 2.1;\n      const float INV_GAMMA_SRGB = 0.4761904;  // 1 / GAMMA_SRGB\n      "]))),n.code.add(u.glsl(g=g||i(["\n      vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, float _roughness, float _metalness, vec3 _emission, float _reflectance, float additionalAmbientIrradiance)\n      {\n        // Calculate half vector between view and light direction\n        vec3 viewDirection = -viewDir;\n        vec3 mainLightDirection = -lightingMainDirection;\n        vec3 h = normalize(viewDirection + mainLightDirection);\n\n        PBRShadingInfo inputs;\n        inputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\n        inputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\n        inputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\n        inputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\n        inputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\n        vec3 reflectedView = normalize(reflect(viewDirection, normal));\n        inputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\n\n        inputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\n        inputs.groundReflectance = vec3(GROUND_REFLECTANCE);\n        inputs.ssao = ssao;\n\n        inputs.roughness = clamp(_roughness * _roughness, 0.001, 0.99);\n        inputs.metalness = _metalness;\n      "],["\n      vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, float _roughness, float _metalness, vec3 _emission, float _reflectance, float additionalAmbientIrradiance)\n      {\n        // Calculate half vector between view and light direction\n        vec3 viewDirection = -viewDir;\n        vec3 mainLightDirection = -lightingMainDirection;\n        vec3 h = normalize(viewDirection + mainLightDirection);\n\n        PBRShadingInfo inputs;\n        inputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\n        inputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\n        inputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\n        inputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\n        inputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\n        vec3 reflectedView = normalize(reflect(viewDirection, normal));\n        inputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\n\n        inputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\n        inputs.groundReflectance = vec3(GROUND_REFLECTANCE);\n        inputs.ssao = ssao;\n\n        inputs.roughness = clamp(_roughness * _roughness, 0.001, 0.99);\n        inputs.metalness = _metalness;\n      "]))),n.code.add(u.glsl(y=y||i(["\n        inputs.f0 = (0.16 * _reflectance * _reflectance) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\n        inputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0)); // more accurate then using  f90 = 1.0\n        inputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);\n      "],["\n        inputs.f0 = (0.16 * _reflectance * _reflectance) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\n        inputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0)); // more accurate then using  f90 = 1.0\n        inputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);\n      "]))),n.code.add(u.glsl(b=b||i(["\n        vec3 ambientDir = normalize(vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2],\n                                      - 5.0 * normalGround[0] - normalGround[2] * normalGround[1],\n                                        normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]));\n\n        inputs.NdotAmbDir = abs(dot(normal, ambientDir));\n\n        // Calculate the irradiance components: sun, fill lights and the sky.\n        vec3 mainLightIrradianceComponent  = inputs.NdotL * (1.0 - shadow) * lightingMainIntensity;\n        vec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * lightingMainIntensity * fillLightIntensity;\n        // calculateAmbientIrradiance for localView and additionalLight for gloabalView\n        vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\n\n        // Assemble the overall irradiance of the sky that illuminates the surface\n        inputs.skyIrradianceToSurface    = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\n        // Assemble the overall irradiance of the ground that illuminates the surface. for this we use the simple model that changes only the sky irradiance by the groundReflectance\n        inputs.groundIrradianceToSurface = inputs.groundReflectance * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\n      "],["\n        vec3 ambientDir = normalize(vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2],\n                                      - 5.0 * normalGround[0] - normalGround[2] * normalGround[1],\n                                        normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]));\n\n        inputs.NdotAmbDir = abs(dot(normal, ambientDir));\n\n        // Calculate the irradiance components: sun, fill lights and the sky.\n        vec3 mainLightIrradianceComponent  = inputs.NdotL * (1.0 - shadow) * lightingMainIntensity;\n        vec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * lightingMainIntensity * fillLightIntensity;\n        // calculateAmbientIrradiance for localView and additionalLight for gloabalView\n        vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\n\n        // Assemble the overall irradiance of the sky that illuminates the surface\n        inputs.skyIrradianceToSurface    = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\n        // Assemble the overall irradiance of the ground that illuminates the surface. for this we use the simple model that changes only the sky irradiance by the groundReflectance\n        inputs.groundIrradianceToSurface = inputs.groundReflectance * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\n      "]))),n.code.add(u.glsl(_=_||i(["\n        vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\n        vec3 horizonRingH = normalize(viewDirection + horizonRingDir);\n        inputs.NdotH_Horizon = dot(normal, horizonRingH);\n\n        vec3 mainLightRadianceComponent  = normalDistribution(inputs.NdotH, inputs.roughness) * lightingMainIntensity * (1.0 - shadow);\n        vec3 horizonLightRadianceComponent = normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * lightingMainIntensity * fillLightIntensity;\n        vec3 ambientLightRadianceComponent = calculateAmbientRadiance(ssao) + additionalLight; // calculateAmbientRadiance for localView and additionalLight for gloabalView\n\n        // Assemble the overall radiance of the sky that illuminates the surface\n        inputs.skyRadianceToSurface    =  ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;\n        // Assemble the overall radiance of the ground that illuminates the surface. for this we use the simple model that changes only the sky radince by the groundReflectance\n        inputs.groundRadianceToSurface = inputs.groundReflectance * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;\n\n        // Calculate average ambient radiance - this is used int the gamut mapping part to deduce the black level that is soft compressed\n        inputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + inputs.groundReflectance[1]);\n        "],["\n        vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\n        vec3 horizonRingH = normalize(viewDirection + horizonRingDir);\n        inputs.NdotH_Horizon = dot(normal, horizonRingH);\n\n        vec3 mainLightRadianceComponent  = normalDistribution(inputs.NdotH, inputs.roughness) * lightingMainIntensity * (1.0 - shadow);\n        vec3 horizonLightRadianceComponent = normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * lightingMainIntensity * fillLightIntensity;\n        vec3 ambientLightRadianceComponent = calculateAmbientRadiance(ssao) + additionalLight; // calculateAmbientRadiance for localView and additionalLight for gloabalView\n\n        // Assemble the overall radiance of the sky that illuminates the surface\n        inputs.skyRadianceToSurface    =  ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;\n        // Assemble the overall radiance of the ground that illuminates the surface. for this we use the simple model that changes only the sky radince by the groundReflectance\n        inputs.groundRadianceToSurface = inputs.groundReflectance * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;\n\n        // Calculate average ambient radiance - this is used int the gamut mapping part to deduce the black level that is soft compressed\n        inputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + inputs.groundReflectance[1]);\n        "]))),n.code.add(u.glsl(x=x||i(["\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));\n        return outColor;\n      }\n    "],["\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));\n        return outColor;\n      }\n    "])))):n.code.add(u.glsl(v=v||i(["\n      vec3 evaluateSceneLighting(vec3 normalWorld, vec3 baseColor, float mainLightShadow, float ambientOcclusion, vec3 additionalLight)\n      {\n        vec3 mainLighting = evaluateMainLighting(normalWorld, mainLightShadow);\n        vec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ambientOcclusion);\n        // inverse gamma correction on the base color\n        float gamma = 2.1;\n        vec3 baseColorLinear = pow(baseColor, vec3(gamma));\n\n        // physically correct BRDF normalizes by PI\n        const float PI = 3.14159;\n        vec3 totalLight = mainLighting + ambientLighting + additionalLight;\n        totalLight = min(totalLight, vec3(PI, PI, PI));\n        vec3 outColor = vec3((baseColorLinear / PI) * totalLight);\n\n        // apply gamma correction to the computed color\n        outColor = pow(outColor, vec3(1.0/gamma));\n\n        return outColor;\n      }\n      "],["\n      vec3 evaluateSceneLighting(vec3 normalWorld, vec3 baseColor, float mainLightShadow, float ambientOcclusion, vec3 additionalLight)\n      {\n        vec3 mainLighting = evaluateMainLighting(normalWorld, mainLightShadow);\n        vec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ambientOcclusion);\n        // inverse gamma correction on the base color\n        float gamma = 2.1;\n        vec3 baseColorLinear = pow(baseColor, vec3(gamma));\n\n        // physically correct BRDF normalizes by PI\n        const float PI = 3.14159;\n        vec3 totalLight = mainLighting + ambientLighting + additionalLight;\n        totalLight = min(totalLight, vec3(PI, PI, PI));\n        vec3 outColor = vec3((baseColorLinear / PI) * totalLight);\n\n        // apply gamma correction to the computed color\n        outColor = pow(outColor, vec3(1.0/gamma));\n\n        return outColor;\n      }\n      "]))))}}.apply(null,i))||(e.exports=r)},2733:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,r,o){var a,s,l,c;Object.defineProperty(t,"__esModule",{value:!0}),t.EvaluateAmbientLighting=function(e,t){var n=e.fragment,i=void 0!==t.lightingSphericalHarmonicsOrder?t.lightingSphericalHarmonicsOrder:2;0===i?(n.uniforms.add("lightingAmbientSH0","vec3"),n.code.add(o.glsl(a=a||r(["\n      /**\n       * @param normal            shading normal in global coordinate space\n       * @param ambientOcclusion  amount of occlusion of the ambient light (1 => full occlusion)\n       */\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight = 0.282095 * lightingAmbientSH0;\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "],["\n      /**\n       * @param normal            shading normal in global coordinate space\n       * @param ambientOcclusion  amount of occlusion of the ambient light (1 => full occlusion)\n       */\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight = 0.282095 * lightingAmbientSH0;\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "])))):1===i?(n.uniforms.add("lightingAmbientSH_R","vec4"),n.uniforms.add("lightingAmbientSH_G","vec4"),n.uniforms.add("lightingAmbientSH_B","vec4"),n.code.add(o.glsl(s=s||r(["\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec4 sh0 = vec4(\n          0.282095,\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y\n        );\n        vec3 ambientLight = vec3(\n          dot(lightingAmbientSH_R, sh0),\n          dot(lightingAmbientSH_G, sh0),\n          dot(lightingAmbientSH_B, sh0)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "],["\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec4 sh0 = vec4(\n          0.282095,\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y\n        );\n        vec3 ambientLight = vec3(\n          dot(lightingAmbientSH_R, sh0),\n          dot(lightingAmbientSH_G, sh0),\n          dot(lightingAmbientSH_B, sh0)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "])))):2===i&&(n.uniforms.add("lightingAmbientSH0","vec3"),n.uniforms.add("lightingAmbientSH_R1","vec4"),n.uniforms.add("lightingAmbientSH_G1","vec4"),n.uniforms.add("lightingAmbientSH_B1","vec4"),n.uniforms.add("lightingAmbientSH_R2","vec4"),n.uniforms.add("lightingAmbientSH_G2","vec4"),n.uniforms.add("lightingAmbientSH_B2","vec4"),n.code.add(o.glsl(l=l||r(["\n      /**\n       * @param normal            shading normal in global coordinate space\n       * @param ambientOcclusion  amount of occlusion of the ambient light (1 => full occlusion)\n       */\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight = 0.282095 * lightingAmbientSH0;\n\n        vec4 sh1 = vec4(\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y,\n          1.092548 * normal.x * normal.y\n        );\n        vec4 sh2 = vec4(\n          1.092548 * normal.y * normal.z,\n          0.315392 * (3.0 * normal.z * normal.z - 1.0),\n          1.092548 * normal.x * normal.z,\n          0.546274 * (normal.x * normal.x - normal.y * normal.y)\n        );\n        ambientLight += vec3(\n          dot(lightingAmbientSH_R1, sh1),\n          dot(lightingAmbientSH_G1, sh1),\n          dot(lightingAmbientSH_B1, sh1)\n        );\n        ambientLight += vec3(\n          dot(lightingAmbientSH_R2, sh2),\n          dot(lightingAmbientSH_G2, sh2),\n          dot(lightingAmbientSH_B2, sh2)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "],["\n      /**\n       * @param normal            shading normal in global coordinate space\n       * @param ambientOcclusion  amount of occlusion of the ambient light (1 => full occlusion)\n       */\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight = 0.282095 * lightingAmbientSH0;\n\n        vec4 sh1 = vec4(\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y,\n          1.092548 * normal.x * normal.y\n        );\n        vec4 sh2 = vec4(\n          1.092548 * normal.y * normal.z,\n          0.315392 * (3.0 * normal.z * normal.z - 1.0),\n          1.092548 * normal.x * normal.z,\n          0.546274 * (normal.x * normal.x - normal.y * normal.y)\n        );\n        ambientLight += vec3(\n          dot(lightingAmbientSH_R1, sh1),\n          dot(lightingAmbientSH_G1, sh1),\n          dot(lightingAmbientSH_B1, sh1)\n        );\n        ambientLight += vec3(\n          dot(lightingAmbientSH_R2, sh2),\n          dot(lightingAmbientSH_G2, sh2),\n          dot(lightingAmbientSH_B2, sh2)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "]))),t.usePBR&&n.code.add(o.glsl(c=c||r(["\n        // calculateAmbientRadiance is used calculate specular radiance of the sky\n        // - in the night calculateAmbientRadiance gives darker color compared to calculateAmbientComponent which integrates contributions of the moon\n        // - calculateAmbientRadiance gives more predictable color compared to calculateAmbientIrradiance that depends on normal\n        // - in future more physically accurate model should be established\n        vec3 calculateAmbientRadiance(float ssao)\n        {\n          // evaluate the sh ambient light\n          vec3 ambientLight ;\n          ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2; // returning the darker value in the night\n\n          return ambientLight *= (1.0 - ssao) * skyTransmittance; // skyTransmittance is slightly bluish giving more natural look\n        }\n      "],["\n        // calculateAmbientRadiance is used calculate specular radiance of the sky\n        // - in the night calculateAmbientRadiance gives darker color compared to calculateAmbientComponent which integrates contributions of the moon\n        // - calculateAmbientRadiance gives more predictable color compared to calculateAmbientIrradiance that depends on normal\n        // - in future more physically accurate model should be established\n        vec3 calculateAmbientRadiance(float ssao)\n        {\n          // evaluate the sh ambient light\n          vec3 ambientLight ;\n          ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2; // returning the darker value in the night\n\n          return ambientLight *= (1.0 - ssao) * skyTransmittance; // skyTransmittance is slightly bluish giving more natural look\n        }\n      "]))))}}.apply(null,i))||(e.exports=r)},2734:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.EvaluateMainLighting=function(e){var t=e.fragment;t.uniforms.add("lightingMainDirection","vec3"),t.uniforms.add("lightingMainIntensity","vec3"),t.uniforms.add("lightingFixedFactor","float"),t.code.add(i.glsl(r=r||n(["\n    vec3 evaluateMainLighting(vec3 normal_global, float shadowing) {\n      float dotVal = clamp(-dot(normal_global, lightingMainDirection), 0.0, 1.0);\n\n      // move lighting towards (1.0, 1.0, 1.0) if requested\n      dotVal = mix(dotVal, 1.0, lightingFixedFactor);\n\n      return lightingMainIntensity * ((1.0 - shadowing) * dotVal);\n    }\n  "],["\n    vec3 evaluateMainLighting(vec3 normal_global, float shadowing) {\n      float dotVal = clamp(-dot(normal_global, lightingMainDirection), 0.0, 1.0);\n\n      // move lighting towards (1.0, 1.0, 1.0) if requested\n      dotVal = mix(dotVal, 1.0, lightingFixedFactor);\n\n      return lightingMainIntensity * ((1.0 - shadowing) * dotVal);\n    }\n  "])))}}.apply(null,i))||(e.exports=r)},2735:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,i,r){var o,a,s,l;Object.defineProperty(t,"__esModule",{value:!0}),t.Normals=function(e,t){var n=e.fragment;n.code.add(r.glsl(o=o||i(["\n    struct ShadingNormalParameters {\n      vec3 normalView;\n      vec3 viewDirection;\n    } shadingParams;\n    "],["\n    struct ShadingNormalParameters {\n      vec3 normalView;\n      vec3 viewDirection;\n    } shadingParams;\n    "]))),1===t.doubleSidedMode?n.code.add(r.glsl(a=a||i(["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return dot(params.normalView, params.viewDirection) > 0.0 ? normalize(-params.normalView) : normalize(params.normalView);\n      }\n    "],["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return dot(params.normalView, params.viewDirection) > 0.0 ? normalize(-params.normalView) : normalize(params.normalView);\n      }\n    "]))):2===t.doubleSidedMode?n.code.add(r.glsl(s=s||i(["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return gl_FrontFacing ? normalize(params.normalView) : normalize(-params.normalView);\n      }\n    "],["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return gl_FrontFacing ? normalize(params.normalView) : normalize(-params.normalView);\n      }\n    "]))):n.code.add(r.glsl(l=l||i(["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return normalize(params.normalView);\n      }\n    "],["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return normalize(params.normalView);\n      }\n    "])))}}.apply(null,i))||(e.exports=r)},2736:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(2737),n(1629)],void 0===(r=function(e,t,i,r,o){var a;Object.defineProperty(t,"__esModule",{value:!0}),t.MixExternalColor=function(e,t){e.include(r.ColorConversion,t);var n=o.glsl(a=a||i(["\n    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {\n      // workaround for artifacts in OSX using Intel Iris Pro\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\n      vec3 internalMixed = internalColor * textureColor;\n      vec3 allMixed = internalMixed * externalColor;\n\n      if (mode == ",") {\n        return allMixed;\n      }\n      else if (mode == ",") {\n        return internalMixed;\n      }\n      else if (mode == ",") {\n        return externalColor;\n      }\n      else {\n        // tint (or something invalid)\n        float vIn = rgb2v(internalMixed);\n        vec3 hsvTint = rgb2hsv(externalColor);\n        vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);\n        return hsv2rgb(hsvOut);\n      }\n    }\n\n    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {\n      // workaround for artifacts in OSX using Intel Iris Pro\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\n      float internalMixed = internalOpacity * textureOpacity;\n      float allMixed = internalMixed * externalOpacity;\n\n      if (mode == ",") {\n        return internalMixed;\n      }\n      else if (mode == ",") {\n        return externalOpacity;\n      }\n      else {\n        // multiply or tint (or something invalid)\n        return allMixed;\n      }\n    }\n  "],["\n    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {\n      // workaround for artifacts in OSX using Intel Iris Pro\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\n      vec3 internalMixed = internalColor * textureColor;\n      vec3 allMixed = internalMixed * externalColor;\n\n      if (mode == ",") {\n        return allMixed;\n      }\n      else if (mode == ",") {\n        return internalMixed;\n      }\n      else if (mode == ",") {\n        return externalColor;\n      }\n      else {\n        // tint (or something invalid)\n        float vIn = rgb2v(internalMixed);\n        vec3 hsvTint = rgb2hsv(externalColor);\n        vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);\n        return hsv2rgb(hsvOut);\n      }\n    }\n\n    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {\n      // workaround for artifacts in OSX using Intel Iris Pro\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\n      float internalMixed = internalOpacity * textureOpacity;\n      float allMixed = internalMixed * externalOpacity;\n\n      if (mode == ",") {\n        return internalMixed;\n      }\n      else if (mode == ",") {\n        return externalOpacity;\n      }\n      else {\n        // multiply or tint (or something invalid)\n        return allMixed;\n      }\n    }\n  "]),o.glsl.int(1),o.glsl.int(2),o.glsl.int(3),o.glsl.int(2),o.glsl.int(3));switch(t.stages){case 0:e.vertex.code.add(n);break;case 1:e.fragment.code.add(n);break;default:e.vertex.code.add(n),e.fragment.code.add(n)}}}.apply(null,i))||(e.exports=r)},2737:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,i,r){var o,a,s,l;Object.defineProperty(t,"__esModule",{value:!0}),t.ColorConversion=function(t,e){var n=[r.glsl(o=o||i(["\n      vec4 premultiplyAlpha(vec4 v) {\n        return vec4(v.rgb * v.a, v.a);\n      }\n    "],["\n      vec4 premultiplyAlpha(vec4 v) {\n        return vec4(v.rgb * v.a, v.a);\n      }\n    "])),r.glsl(a=a||i(["\n      vec3 rgb2hsv(vec3 c) {\n        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n        vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n        vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n        float d = q.x - min(q.w, q.y);\n        float e = 1.0e-10;\n        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);\n      }\n    "],["\n      vec3 rgb2hsv(vec3 c) {\n        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n        vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n        vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n        float d = q.x - min(q.w, q.y);\n        float e = 1.0e-10;\n        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);\n      }\n    "])),r.glsl(s=s||i(["\n      vec3 hsv2rgb(vec3 c) {\n        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n      }\n    "],["\n      vec3 hsv2rgb(vec3 c) {\n        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n      }\n    "])),r.glsl(l=l||i(["\n      float rgb2v(vec3 c) {\n        return max(c.x, max(c.y, c.z));\n      }\n    "],["\n      float rgb2v(vec3 c) {\n        return max(c.x, max(c.y, c.z));\n      }\n    "]))];switch(e.stages){case 0:n.forEach(function(e){return t.vertex.code.add(e)});break;case 1:n.forEach(function(e){return t.fragment.code.add(e)});break;default:n.forEach(function(e){return t.vertex.code.add(e)}),n.forEach(function(e){return t.fragment.code.add(e)})}}}.apply(null,i))||(e.exports=r)},2738:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(0),n(1),n(5),n(13),n(34),n(54),n(12),n(15),n(2),n(19),n(214),n(1654),n(484),n(1633),n(48),n(59),n(118),n(150),n(80),n(486),n(1650),n(211),n(1646),n(2739),n(1979),n(1966),n(1852)],void 0===(r=function(e,t,n,i,r,o,O,a,s,M,l,c,D,u,d,p,T,f,R,h,v,m,I,g,z,y,b,_,x){function S(e){return 0!==e[12]||0!==e[13]||0!==e[14]}Object.defineProperty(t,"__esModule",{value:!0});var P,w=(P=l.declared(o),i(A,P),A.prototype.initialize=function(){var t=this;this._intersector=new y(this.view.viewingMode),this._mapPoint=m.makeDehydratedPoint(0,0,0,this.view.spatialReference),this.events.on("drag",function(e){return t.drag(e)})},A.prototype.destroy=function(){this._removeResourcesFromStage(),this._engineResources=null,this._set("view",null),this._camera=null},Object.defineProperty(A.prototype,"alignment",{get:function(){return this._get("alignment")},set:function(e){this._set("alignment",e),this.constructed&&this._refreshMapPoint()},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"visible",{set:function(e){e!==this._get("visible")&&(this._set("visible",e),this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"radius",{get:function(){return this._radius},set:function(e){e!==this._radius&&(this._radius=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"worldSized",{get:function(){return this._worldSized},set:function(e){e!==this._worldSized&&(this._worldSized=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"focusMultiplier",{get:function(){return this._focusMultiplier},set:function(e){this._focusMultiplier=e},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"touchMultiplier",{get:function(){return this._touchMultiplier},set:function(e){this._touchMultiplier=e},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"modelTransform",{get:function(){return this._modelTransform},set:function(e){S(e)&&(this._screenPositionDirty=!0),d.mat4.copy(this._modelTransform,e),this._updateEngineObject()},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"position",{get:function(){return this._position},set:function(e){this.view.renderCoordsHelper.fromRenderCoords(e,this._mapPoint,this._mapPoint.spatialReference),this._refreshMapPoint()},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"mapPoint",{get:function(){return this._mapPoint},set:function(e){m.clonePoint(e,this._mapPoint),this._refreshMapPoint()},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"grabbing",{set:function(e){e!==this._get("grabbing")&&(this._set("grabbing",e),this._updateEngineObject()),e||(this._dragOffset=null)},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"hovering",{set:function(e){e!==this._get("hovering")&&(this._set("hovering",e),this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"selected",{set:function(e){e!==this._get("selected")&&(this._set("selected",e),this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"state",{set:function(e){e!==this._get("state")&&(this._set("state",e),this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"areAnyEngineObjectsVisible",{get:function(){return this._areAnyEngineObjectsVisible},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"surfaceType",{get:function(){return this._hitResult.onSurface?this._hitResult.surfaceType:null},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"focused",{get:function(){return this._focused},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"_focused",{get:function(){return this._get("hovering")||this._get("grabbing")},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"screenPoint",{get:function(){return this._updateScreenSpaceProperties(),this._dirtyScreenPoint},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"_screenPointArray",{get:function(){return this._updateScreenSpaceProperties(),this._dirtyScreenPointArray},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"_renderScreenPointArray",{get:function(){return this._updateScreenSpaceProperties(),this._dirtyRenderScreenPointArray},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"_originScreenPointArray",{get:function(){return this._updateScreenSpaceProperties(),this._dirtyOriginScreenPointArray},enumerable:!0,configurable:!0}),Object.defineProperty(A.prototype,"_screenPixelSize",{get:function(){return this._updateScreenSpaceProperties(),this._dirtyScreenPixelSize},enumerable:!0,configurable:!0}),A.prototype._updateScreenSpaceProperties=function(){if(this._screenPositionDirty){this._screenPositionDirty=!1,this._dirtyScreenPixelSize=this._camera.computeScreenPixelSizeAt(this._position);var e,t=S(this._modelTransform);if(t){var n=this._calculateModelTransformOffset(Z);e=R.vec3.add(n,n,this._position)}else e=this._position;this._camera.projectPoint(e,this._dirtyRenderScreenPointArray),this._camera.renderToScreen(this._dirtyRenderScreenPointArray,this._dirtyScreenPointArray),M.screenPointArrayToObject(this._dirtyScreenPointArray,this._dirtyScreenPoint),t?(this._camera.projectPoint(this._position,E),this._camera.renderToScreen(E,this._dirtyOriginScreenPointArray)):T.vec2.copy(this._dirtyOriginScreenPointArray,this._dirtyScreenPointArray)}},A.prototype.intersectionDistance=function(e,t){if(!this._get("visible"))return null;var n=M.screenPointObjectToArray(e,L),i=this._getCollisionRadius(t),r=-1*this._get("collisionPriority");switch(this.collisionType.type){case"point":if(T.vec2.squaredDistance(this._screenPointArray,n)<i*i)return this._renderScreenPointArray[2]+r;break;case"line":for(var o=this.collisionType.paths,a=this._getWorldToScreenObjectScale(),s=this._calculateObjectTransform(a,G),l=i*this._screenPixelSize,c=I.ray.fromScreen(this._camera,n,N),u=0,d=o;u<d.length;u++)if(0!==(A=d[u]).length)for(var p=R.vec3.transformMat4(B,A[0],s),f=1;f<A.length;f++){var h=R.vec3.transformMat4(U,A[f],s);if(null!=(C=I.lineSegment.closestRayDistance2(I.lineSegment.fromPoints(p,h,V),c))&&C<l*l){var v=R.vec3.add(z.sv3d.get(),p,h);R.vec3.scale(v,v,.5);var m=M.castRenderScreenPointArray(z.sv3d.get());return this._camera.projectPoint(v,m),m[2]+r}R.vec3.copy(p,h)}break;case"disc":var g=this.collisionType.direction,y=(a=this._getWorldToScreenObjectScale(),s=this._calculateObjectTransform(a,G),l=i*this._screenPixelSize,c=I.ray.fromScreen(this._camera,n,N),D.mat3.fromMat4(j,s)),b=R.vec3.transformMat3(q,g,y),_=this._calculateModelTransformPosition(W);I.plane.fromPositionAndNormal(_,b,H);var x=k;if(I.plane.intersectRay(H,c,x)&&R.vec3.squaredDistance(x,_)<l*l)return this._renderScreenPointArray[2]+r;break;case"ribbon":var S=this.collisionType;if(o=S.paths,g=S.direction,a=this._getWorldToScreenObjectScale(),s=this._calculateObjectTransform(a,G),l=i*this._camera.computeScreenPixelSizeAt(this._position),c=I.ray.fromScreen(this._camera,n,N),y=D.mat3.fromMat4(j,s),b=R.vec3.transformMat3(q,g,y),_=this._calculateModelTransformPosition(W),I.plane.fromPositionAndNormal(_,b,H),x=k,!I.plane.intersectRay(H,c,x))break;for(var P=0,w=o;P<w.length;P++){var A;if(0!==(A=w[P]).length)for(p=R.vec3.transformMat4(B,A[0],s),f=1;f<A.length;f++){var C;if(h=R.vec3.transformMat4(U,A[f],s),null!=(C=I.lineSegment.distance2(I.lineSegment.fromPoints(p,h,V),x))&&C<l*l)return v=R.vec3.add(z.sv3d.get(),p,h),R.vec3.scale(v,v,.5),m=M.castRenderScreenPointArray(z.sv3d.get()),this._camera.projectPoint(v,m),m[2]+r;R.vec3.copy(p,h)}}break;default:O.neverReached(this.collisionType)}return null},A.prototype.drag=function(e){if(this.moveOnDrag){var t=M.screenPointObjectToArray(e.screenPoint,L);s.isNone(this._dragOffset)&&this.grabbing&&!this.snapToPointer&&(this._dragOffset=T.vec2.subtract(f.vec2f32.create(),t,this._originScreenPointArray)),s.isSome(this._dragOffset)&&T.vec2.subtract(t,t,this._dragOffset),this.view.sceneIntersectionHelper.intersectToolIntersectorScreen(t,this._intersector,"on-the-ground"===this.alignment?C:null);var n=this._intersector.results.min,i=k;n.getIntersectionPoint(i)?(this.position=i,this._hitResult.onSurface=!0,this._hitResult.surfaceType="TerrainRenderer"===n.intersector?"ground":"feature"):this._hitResult.onSurface=!1}},A.prototype.attach=function(e){if(void 0===e&&(e={manipulator3D:{}}),this.view._stage){var t=e.manipulator3D;if(this._engineLayerId=t.engineLayerId,s.isNone(this._engineLayerId)){var n=new _("manipulator-3d",{isPickable:!1});this.view._stage.add(0,n),this.view._stage.addToViewContent([n.id]),this._engineLayerId=n.id,t.engineLayerId=n.id}t.engineLayerReferences=(t.engineLayerReferences||0)+1,this._materialIdReferences=t.materialIdReferences,s.isNone(this._materialIdReferences)&&(this._materialIdReferences=new Map,t.materialIdReferences=this._materialIdReferences),this._camera=this.view.state.camera,this._attached=!0,this._updateEngineObject(),g.canProject(this._mapPoint.spatialReference,this.view.spatialReference)||(this.mapPoint=m.makeDehydratedPoint(0,0,0,this.view.spatialReference))}},A.prototype.detach=function(e){void 0===e&&(e={manipulator3D:{}});var t=e.manipulator3D;t.engineLayerReferences--;var n=0===t.engineLayerReferences;n&&(t.engineLayerId=null),this._removeResourcesFromStage(n),this._engineResources=null,this._engineLayerId=null,this._materialIdReferences=null,this._camera=null,this._attached=!1},A.prototype.onViewChange=function(){this._camera=this.view.state.camera,this._screenPositionDirty=!0,this._updateEngineObject()},A.prototype.onElevationChange=function(e){this.view.renderCoordsHelper.fromRenderCoords(this.position,X,e.spatialReference)&&v.containsPoint(e.extent,X)&&this._refreshMapPoint(!0)},A.prototype._refreshMapPoint=function(e){switch(void 0===e&&(e=!1),this.alignment){case"none":break;case"on-the-ground":var t=this.view.elevationProvider.getElevation(this.mapPoint,"ground");if(t===this._mapPoint.z&&e)return;this._mapPoint.z=t;break;default:O.neverReached(this.alignment)}this._screenPositionDirty=!0,this._hitResult.onSurface=!1,this.view.renderCoordsHelper.toRenderCoords(this._mapPoint,this._position),this._updateEngineObject()},A.prototype._updateEngineObject=function(){if(this._areAnyEngineObjectsVisible=!1,this._attached){if(!1===this._get("visible"))return void this._removeResourcesFromStage();var e=this._getWorldToScreenObjectScale(),t=G;if(!0===this._get("autoScaleRenderObjects")){var n=this._getFocusedSize(this._radius,this._focused)*e;this._calculateObjectTransform(n,t)}else this._calculateObjectTransform(e,t);for(var i=this._ensureEngineResources().objectsByState,r=(this._focused?2:1)|(this._get("selected")?8:4),o=this._get("hideOnGrab")&&this._get("grabbing"),a=0,s=i;a<s.length;a++){var l=s[a],c=l.stateMask,u=l.objects;if(o)for(var d=0,p=u;d<p.length;d++)(b=p[d]).hideAllComponents();else{var f=!(0!=(15&c))||(r&c)==(15&c),h=!(0!=(65520&c))||(this._get("state")&c)==(65520&c);if(f&&h)for(var v=0,m=u;v<m.length;v++)(b=m[v]).unhideAllComponents(),b.objectTransformation=t,this._areAnyEngineObjectsVisible=!0;else for(var g=0,y=u;g<y.length;g++){var b;(b=y[g]).hideAllComponents()}}}}},A.prototype._ensureEngineResources=function(){if(s.isNone(this._engineResources)){var e=this.view._stage.getContent(0,s.expect(this._engineLayerId)),n=[],i=new Set;this.renderObjects.forEach(function(e){var t=e.material;i.has(t)||(n.push(t),i.add(t))});var c=new Map;this.renderObjects.forEach(function(e){var t,n,i,r,o,a=new x({idHint:"manipulator"});t=a,i=(n=e).geometry,r=n.material,o=n.transform,Array.isArray(i)?i.forEach(function(e){return t.addGeometry(e,r,o)}):t.addGeometry(i,r,o);var s=e.stateMask||0,l=c.get(s)||[];l.push(a),c.set(s,l)});var r=[];c.forEach(function(e,t){r.push({stateMask:t,objects:e})}),this._engineResources={objectsByState:r,layer:e,materials:n}}return this._addResourcesToStage(),this._engineResources},A.prototype._addResourcesToStage=function(){var i=this;if(!this._engineResourcesAddedToStage&&!s.isNone(this._engineResources)){var e=this._engineResources,t=e.objectsByState,n=e.layer;e.materials.forEach(function(e){var t=s.expect(i._materialIdReferences),n=t.get(e.id)||0;0===n&&i.view._stage.add(3,e),t.set(e.id,n+1)}),t.forEach(function(e){e.objects.forEach(function(e){n.addObject(e),i.view._stage.add(1,e)})}),this._engineResourcesAddedToStage=!0}},A.prototype._removeResourcesFromStage=function(e){var i=this;if(void 0===e&&(e=!1),this._engineResourcesAddedToStage&&!s.isNone(this._engineResources)){var t=this._engineResources,n=t.objectsByState,r=t.layer,o=t.materials;n.forEach(function(e){e.objects.forEach(function(e){r.removeObject(e),i.view._stage.remove(1,e.id)})}),o.forEach(function(e){var t=s.expect(i._materialIdReferences),n=t.get(e.id);1===n?(i.view._stage.remove(3,e.id),t.delete(e.id)):t.set(e.id,n-1)}),e&&this.view._stage.remove(0,r.id),this._engineResourcesAddedToStage=!1}},A.prototype._getCollisionRadius=function(e){return this._getFocusedSize(this._radius,!0)*("touch"===e?this._touchMultiplier:1)},A.prototype._getFocusedSize=function(e,t){return e*(t?this._focusMultiplier:1)},A.prototype._getWorldToScreenObjectScale=function(){return this._worldSized?1:this._screenPixelSize},A.prototype._calculateModelTransformPosition=function(e){var t=this._getWorldToScreenObjectScale(),n=this._calculateObjectTransform(t,F);return R.vec3.set(e,n[12],n[13],n[14])},A.prototype._calculateModelTransformOffset=function(e){var t=this._calculateModelTransformPosition(e);return R.vec3.subtract(e,t,this._position)},A.prototype._calculateObjectTransform=function(e,t){return d.mat4.set(t,e,0,0,0,0,e,0,0,0,0,e,0,0,0,0,1),d.mat4.multiply(t,t,this._modelTransform),t[12]+=this._position[0],t[13]+=this._position[1],t[14]+=this._position[2],t[15]=1,t},n([l.property({constructOnly:!0,nonNullable:!0})],A.prototype,"view",void 0),n([l.property({value:"none",nonNullable:!0})],A.prototype,"alignment",null),n([l.property()],A.prototype,"hideOnGrab",void 0),n([l.property()],A.prototype,"moveOnDrag",void 0),n([l.property()],A.prototype,"snapToPointer",void 0),n([l.property()],A.prototype,"collisionType",void 0),n([l.property({type:c.Integer})],A.prototype,"collisionPriority",void 0),n([l.property({constructOnly:!0})],A.prototype,"renderObjects",void 0),n([l.property()],A.prototype,"autoScaleRenderObjects",void 0),n([l.property({value:!0})],A.prototype,"visible",null),n([l.property()],A.prototype,"radius",null),n([l.property()],A.prototype,"worldSized",null),n([l.property()],A.prototype,"focusMultiplier",null),n([l.property()],A.prototype,"touchMultiplier",null),n([l.property()],A.prototype,"interactive",void 0),n([l.property()],A.prototype,"selectable",void 0),n([l.property()],A.prototype,"cursor",void 0),n([l.property({value:!1})],A.prototype,"grabbing",null),n([l.property()],A.prototype,"dragging",void 0),n([l.property({value:!1})],A.prototype,"hovering",null),n([l.property({value:!1})],A.prototype,"selected",null),n([l.property({value:0})],A.prototype,"state",null),n([l.property({dependsOn:["hovering","grabbing"]})],A.prototype,"focused",null),n([l.subclass("esri.views.interactive.Manipulator3D")],A));function A(e){var t=P.call(this,e)||this;return t.hideOnGrab=!1,t.moveOnDrag=!0,t.snapToPointer=!0,t.collisionType={type:"point"},t.collisionPriority=0,t.renderObjects=[],t.autoScaleRenderObjects=!0,t._radius=10,t._worldSized=!1,t._focusMultiplier=2,t._touchMultiplier=2.5,t.interactive=!0,t.selectable=!1,t.cursor=null,t.dragging=!1,t._areAnyEngineObjectsVisible=!1,t.events=new a({target:t}),t._position=h.vec3f64.create(),t._modelTransform=p.mat4f64.create(),t._dragOffset=null,t._dirtyScreenPoint=M.createScreenPoint(),t._dirtyScreenPointArray=M.createScreenPointArray(),t._dirtyRenderScreenPointArray=M.createRenderScreenPointArray3(),t._dirtyOriginScreenPointArray=M.createScreenPointArray(),t._dirtyScreenPixelSize=1,t._screenPositionDirty=!0,t._engineResourcesAddedToStage=!1,t._engineResources=null,t._attached=!1,t._engineLayerId=null,t._materialIdReferences=null,t._hitResult={onSurface:!1,surfaceType:"ground"},t}t.Manipulator3D=w;var C={include:new Set};C.include.add(b.TERRAIN_ID);var L=M.createScreenPointArray(),E=M.createRenderScreenPointArray3(),V=I.lineSegment.create(),N=I.ray.create(),j=u.mat3f64.create(),F=p.mat4f64.create(),G=p.mat4f64.create(),H=I.plane.create(),B=h.vec3f64.create(),U=h.vec3f64.create(),k=h.vec3f64.create(),q=h.vec3f64.create(),W=h.vec3f64.create(),Z=h.vec3f64.create(),X=h.vec3f64.create()}.apply(null,i))||(e.exports=r)},2739:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(14),n(12),n(106),n(1633),n(118),n(150),n(1650),n(1979)],void 0===(r=function(e,t,n,m,g,f,s,i,r,h){var y=n("dojo-debug-messages");return Object.defineProperty(o.prototype,"ray",{get:function(){return this._ray},enumerable:!0,configurable:!0}),Object.defineProperty(o.prototype,"rayBeginPoint",{get:function(){return this._ray.origin},enumerable:!0,configurable:!0}),Object.defineProperty(o.prototype,"rayEndPoint",{get:function(){return this._rayEndPoint},enumerable:!0,configurable:!0}),o.prototype.reset=function(e,t){this.resetWithRay(r.ray.fromPoints(e,t,this._ray))},o.prototype.resetWithRay=function(e){e!==this._ray&&r.ray.copy(e,this._ray),s.vec3.add(this._rayEndPoint,this._ray.origin,this._ray.direction),this._numObjectsTested=0,this.results.init(this._ray)},o.prototype.intersect=function(e,t,n,i,r,o){var a=this;this.point=t,this.camera=n,this.filterPredicate=r,this.tolerance=null==i?1e-5:i;var s,l=m.isSome(this.options.verticalOffset)?this.options.verticalOffset.object3D:null;y&&(s=g());var c=o?function(e){o(e)&&a.intersectObject(e)}:function(e){a.intersectObject(e)};if(e&&0<e.length)for(var u=0,d=e;u<d.length;u++){var p=d[u],f=p.getSpatialQueryAccelerator?p.getSpatialQueryAccelerator():void 0;if(f)l?f.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,c,l):f.forEachAlongRay(this._ray.origin,this._ray.direction,c),this.options.selectionMode&&this.options.hud&&f.forEachDegenerateObject(c);else for(var h=0,v=p.getObjects();h<v.length;h++)c(v[h])}this.sortResults(),y&&(this.performanceInfo.queryDuration=g()-s,this.performanceInfo.numObjectsTested=this._numObjectsTested)},o.prototype.intersectObject=function(c){var u=this;this._numObjectsTested++;var e=c.geometryRecords;if(e)for(var d,p=c.id,r=c.objectTransformation,o=m.isSome(this.options.verticalOffset)?this.options.verticalOffset.object3D:null,a=this,t=0,n=e;t<n.length;t++)!function(e){var t=e.geometry,n=e.material,i=e.instanceParameters;if(!i.hidden){d=t.id,a.transform.setAndInvalidateLazyTransforms(r,e.getShaderTransformation()),s.vec3.transformMat4(a._rayStartPointTransformed,a._ray.origin,a.transform.inverse),s.vec3.transformMat4(a._rayEndPointTransformed,a._rayEndPoint,a.transform.inverse);var l=a.transform.transform;m.isSome(o)&&(o.objectTransform=a.transform),n.intersect(t,i,a.transform.transform,a,a._rayStartPointTransformed,a._rayEndPointTransformed,function(t,n,i,r,e,o){if(0<=t){if(null!=u.filterPredicate&&!u.filterPredicate(u._ray.origin,u._rayEndPoint,t))return;if(e)return void((null==u.results.hud.dist||t<u.results.hud.dist)&&u.results.hud.set(c,p,t,n,f.mat4f64.IDENTITY,r,o,d,i));function a(e){return e.set(c,p,t,n,l,r,null,d,i)}if((null==u.results.min.drapedLayerOrder||r>=u.results.min.drapedLayerOrder)&&(null==u.results.min.dist||t<u.results.min.dist)&&a(u.results.min),0!==u.options.store&&(null==u.results.max.drapedLayerOrder||r<u.results.max.drapedLayerOrder)&&(null==u.results.max.dist||t>u.results.max.dist)&&a(u.results.max),2===u.options.store){var s=new h.IntersectorResult(u._ray);a(s),u.results.all.push(s)}}},e.shaderTransformation)}}(n[t])},o.prototype.sortResults=function(){this.results.all.sort(function(e,t){return e.dist!==t.dist?e.dist-t.dist:e.drapedLayerOrder!==t.drapedLayerOrder?(void 0!==e.drapedLayerOrder?e.drapedLayerOrder:Number.MAX_VALUE)-(void 0!==t.drapedLayerOrder?t.drapedLayerOrder:Number.MAX_VALUE):(void 0!==t.drapedLayerGraphicOrder?t.drapedLayerGraphicOrder:Number.MIN_VALUE)-(void 0!==e.drapedLayerGraphicOrder?e.drapedLayerGraphicOrder:Number.MIN_VALUE)})},o.DEFAULT_TOLERANCE=1e-5,o;function o(e){this.options=new h.IntersectorOptions,this.results=new h.IntersectorResults,this.transform=new h.IntersectorTransform,this.performanceInfo={queryDuration:0,numObjectsTested:0},this.tolerance=1e-5,this._ray={origin:i.vec3f64.create(),direction:i.vec3f64.create()},this._rayEndPoint=i.vec3f64.create(),this._rayStartPointTransformed=i.vec3f64.create(),this._rayEndPointTransformed=i.vec3f64.create(),this.viewingMode=e||"global"}}.apply(null,i))||(e.exports=r)},2740:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(5),n(33),n(12),n(15)],void 0===(r=function(e,t,u,d,n,p){Object.defineProperty(t,"__esModule",{value:!0}),t.dragAtLocation=function(r,o,a){if(n.isNone(o))return null;var s=null,l=0,c=0;return function(e){if("start"===e.action&&((s=r.toScreen(a)).x<0||s.x>r.width||s.y<0||s.y>r.height?s=null:(l=e.start.x-s.x,c=e.start.y-s.y)),null==s)return null;var t=d.clamp(e.screenPoint.x-l,0,r.width),n=d.clamp(e.screenPoint.y-c,0,r.height),i=p.createScreenPoint(t,n);return o(u({},e,{start:s,screenPoint:i}))}}}.apply(null,i))||(e.exports=r)},2741:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(11),n(5),n(3),n(12),n(15),n(48),n(118),n(150),n(1650),n(1763),n(1673),n(1721),n(1740),n(1778),n(1642),n(1853),n(1980),n(1678),n(1779),n(2742)],void 0===(r=function(e,t,n,i,r,o,a,g,y,s,b,_,x,l,c,u,S,d,p,f,h,v){var m,P,w,A,C=r.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial"),O=(A=u.Material,n(ee,A),ee.prototype.setParameterValues=function(e){var t=this.params;for(var n in e)t[n]=e[n];this.notifyDirty("matChanged")},ee.prototype.getParameters=function(){return this.params},ee.prototype.getTechniqueConfig=function(e){this.techniqueConfig.output=e,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.transparent=this.params.color[3]<1||this.params.width<1;var t=o.isSome(this.params.stipplePattern);return this.techniqueConfig.stippleEnabled=t,this.techniqueConfig.stippleOffColorEnabled=t&&o.isSome(this.params.stippleOffColor),this.techniqueConfig.stippleIntegerRepeatsEnabled=t&&this.params.stippleIntegerRepeats,this.techniqueConfig},ee.prototype.getPassParameters=function(){return this.params},ee.prototype.intersect=function(e,t,n,i,r,o,a,s,l){l?this.intersectLineGeometry(e,t,n,i,a):f.intersectDrapedRenderLineGeometry(e,i,o,1,a)},ee.prototype.intersectLineGeometry=function(e,t,n,i,r){if(i.options.selectionMode&&!x.isAllHidden(t.componentVisibilities,e.componentOffsets)){if(!S.isTranslationMatrix(n))return void C.error("intersection assumes a translation-only matrix");var o=e.data.getVertexAttr().position.data,a=i.camera,s=U;g.vec2.copy(s,i.point),y.vec3.set(k[0],s[0]-2,s[1]+2,0),y.vec3.set(k[1],s[0]+2,s[1]+2,0),y.vec3.set(k[2],s[0]+2,s[1]-2,0),y.vec3.set(k[3],s[0]-2,s[1]-2,0);for(var l=0;l<4;l++)a.unprojectPoint(k[l],q[l]);b.plane.fromPoints(a.eye,q[0],q[1],W),b.plane.fromPoints(a.eye,q[1],q[2],Z),b.plane.fromPoints(a.eye,q[2],q[3],X),b.plane.fromPoints(a.eye,q[3],q[0],Y);var c=Number.MAX_VALUE;for(l=0;l<o.length-5;l+=3)if(z[0]=o[l]+n[12],z[1]=o[l+1]+n[13],z[2]=o[l+2]+n[14],L[0]=o[l+3]+n[12],L[1]=o[l+4]+n[13],L[2]=o[l+5]+n[14],!(b.plane.signedDistance(W,z)<0&&b.plane.signedDistance(W,L)<0||b.plane.signedDistance(Z,z)<0&&b.plane.signedDistance(Z,L)<0||b.plane.signedDistance(X,z)<0&&b.plane.signedDistance(X,L)<0||b.plane.signedDistance(Y,z)<0&&b.plane.signedDistance(Y,L)<0)){if(a.projectPoint(z,N),a.projectPoint(L,j),N[2]<0&&0<j[2]){y.vec3.subtract(E,z,L);var u=a.frustum,d=-b.plane.signedDistance(u.planes[4],z)/y.vec3.dot(E,u.planes[4]);y.vec3.scale(E,E,d),y.vec3.add(z,z,E),a.projectPoint(z,N)}else if(0<N[2]&&j[2]<0)y.vec3.subtract(E,L,z),u=a.frustum,d=-b.plane.signedDistance(u.planes[4],L)/y.vec3.dot(E,u.planes[4]),y.vec3.scale(E,E,d),y.vec3.add(L,L,E),a.projectPoint(L,j);else if(N[2]<0&&j[2]<0)continue;N[2]=0,j[2]=0;var p=b.lineSegment.distance2(b.lineSegment.fromPoints(N,j,H),s);p<c&&(c=p,y.vec3.copy(F,z),y.vec3.copy(G,L))}var f=i.rayBeginPoint,h=i.rayEndPoint;if(c<4){var v=Number.MAX_VALUE;if(b.lineSegment.closestLineSegmentPoint(b.lineSegment.fromPoints(F,G,H),b.lineSegment.fromPoints(f,h,B),V)){y.vec3.subtract(V,V,f);var m=y.vec3.length(V);y.vec3.scale(V,V,1/m),v=m/y.vec3.distance(f,h)}r(v,V)}}},ee.prototype.computeAttachmentOrigin=function(e,t){var n=e.data,i="getVertexAttr"in n?n.getVertexAttr():"vertexAttr"in n?n.vertexAttr:null;if(!i)return null;var r=i[S.VertexAttrConstants.POSITION];return l.computeAttachmentOriginLines(r,null,t)},ee.prototype.createBufferWriter=function(){var e=this.params.vertexColors?p.PositionColorLayout:p.PositionLayout;return o.isNone(this.params.stipplePattern)?new p.DefaultBufferWriter(e):new R(e.clone().vec3f(S.VertexAttrConstants.AUXPOS1))},ee.prototype.createRenderer=function(e,t){return new h(e,t,this)},ee.prototype.getGLMaterials=function(){return{color:D,depthShadowMap:void 0,normal:void 0,depth:void 0,highlight:T}},ee),M=(w=c.GLMaterial,n($,w),$.prototype.updateParameters=function(){this.technique=this.techniqueRep.acquireAndReleaseExisting(v.NativeLineTechnique,this.material.getTechniqueConfig(this.output),this.technique)},$.prototype.beginSlot=function(e){return 4===e},$.prototype.getProgram=function(){return this.technique.program},$.prototype.getPrograms=function(){return null},$.prototype.bind=function(e,t){e.bindProgram(this.technique.program),this.technique.bindPipelineState(e),this.technique.bindPass(e,this.material.getPassParameters(),t)},$.prototype.release=function(){},$.prototype.bindView=function(e){this.technique.bindDraw(e)},$.prototype.bindInstance=function(e){this.technique.program.setUniformMatrix4fv("model",e.transformation)},$.prototype.getDrawMode=function(){return 1},$),D=(n(Q,P=M),Q),T=(n(J,m=M),J),R=(K.prototype.allocate=function(e){return this.vertexBufferLayout.createBuffer(e)},K.prototype.elementCount=function(e){return e.indices[S.VertexAttrConstants.POSITION].length},K.prototype.write=function(e,t,n,i){d.writeDefaultAttributes(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,n,i),this.writeAuxpos1(e,t,n,i)},K.prototype.writeAuxpos1=function(e,t,n,i){var r=n.getField(S.VertexAttrConstants.AUXPOS1,_.BufferViewVec3f),o=t.indices[S.VertexAttrConstants.POSITION],a=t.vertexAttr[S.VertexAttrConstants.POSITION].data,s=e.transformation,l=r.typedBufferStride,c=r.typedBuffer;i*=l;for(var u=0;u<o.length;u+=2)for(var d=3*o[u],p=a[d],f=a[1+d],h=a[2+d],v=s[0]*p+s[4]*f+s[8]*h+s[12],m=s[1]*p+s[5]*f+s[9]*h+s[13],g=s[2]*p+s[6]*f+s[10]*h+s[14],y=0;y<2;++y)c[i]=v,c[i+1]=m,c[i+2]=g,i+=l},K),I={color:[1,1,1,1],vertexColors:!1,slicePlaneEnabled:!1,width:1,stipplePattern:null,stippleIntegerRepeats:!1,stippleOffColor:null},z=s.vec3f64.create(),L=s.vec3f64.create(),E=s.vec3f64.create(),V=s.vec3f64.create(),N=a.createRenderScreenPointArray3(),j=a.createRenderScreenPointArray3(),F=s.vec3f64.create(),G=s.vec3f64.create(),H=b.lineSegment.create(),B=b.lineSegment.create(),U=s.vec3f64.create(),k=[a.createRenderScreenPointArray3(),a.createRenderScreenPointArray3(),a.createRenderScreenPointArray3(),a.createRenderScreenPointArray3()],q=[s.vec3f64.create(),s.vec3f64.create(),s.vec3f64.create(),s.vec3f64.create()],W=b.plane.create(),Z=b.plane.create(),X=b.plane.create(),Y=b.plane.create();function K(e){this.vertexBufferLayout=e}function J(e){return m.call(this,i({},e,{output:4}))||this}function Q(e){return P.call(this,i({},e,{output:0}))||this}function $(e){var t=w.call(this,e)||this;return t.output=e.output,t.updateParameters(),t}function ee(e,t){var n=A.call(this,t)||this;return n.techniqueConfig=new v.NativeLineTechniqueConfiguration,n.params=f.copyParameters(e,I),n}return O}.apply(null,i))||(e.exports=r)},2742:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(11),n(0),n(5),n(12),n(1679),n(1693),n(1857),n(1741),n(1742),n(1743),n(1704),n(2743),n(314),n(502)],void 0===(r=function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v){Object.defineProperty(t,"__esModule",{value:!0});var m,g=(m=u.ShaderTechnique,n(y,m),y.prototype.initializeProgram=function(e){var t=y.shader.get(),n=this.configuration,i=t.build({output:n.output,attributeColor:n.vertexColors,slicePlaneEnabled:n.slicePlaneEnabled,sliceHighlightDisabled:n.sliceHighlightDisabled,stippleEnabled:n.stippleEnabled,stippleOffColorEnabled:n.stippleOffColorEnabled,stippleUVMaxEnabled:!1,stippleIntegerRepeatsEnabled:n.stippleIntegerRepeatsEnabled});return new h(e.rctx,i.generateSource("vertex"),i.generateSource("fragment"),p.Default3D)},y.prototype.dispose=function(){m.prototype.dispose.call(this),this.stippleTextureRepository.release(this.stipplePattern),this.stipplePattern=null,this.stippleTextureBind=null},y.prototype.bindPass=function(e,t,n){if(this.stipplePattern!==t.stipplePattern){var i=t.stipplePattern;this.stippleTextureBind=this.stippleTextureRepository.swap(this.stipplePattern,i),this.stipplePattern=i}if(this.configuration.stippleEnabled){var r=a.isSome(this.stippleTextureBind)?this.stippleTextureBind(e,0)*n.pixelRatio:1;this.program.setUniform1i("stipplePatternTexture",0),this.program.setUniform1f("stipplePatternPixelSizeInv",1/r),this.program.setUniform2f("ndcToPixel",n.viewport[2]/2,n.viewport[3]/2)}if(0===this.configuration.output){if(this.program.setUniform4fv("constantColor",t.color),this.program.setUniform1f("alphaCoverage",Math.min(1,t.width*n.pixelRatio)),this.configuration.stippleOffColorEnabled){var o=a.expect(t.stippleOffColor);this.program.setUniform4f("stippleOffColor",o[0],o[1],o[2],3<o.length?o[3]:1)}}else l.OutputHighlight.bindOutputHighlight(e,this.program,n)},y.prototype.bindDraw=function(e){s.Transform.bindUniforms(this.program,e),o.Slice.bindUniformsWithOrigin(this.program,this.configuration,e)},y.prototype.initializePipeline=function(){var e=this.configuration;return 0===e.output?v.makePipelineState({blending:e.transparent||e.stippleEnabled?v.separateBlendingParams(770,1,771,771):null,depthTest:{func:513},depthWrite:v.defaultDepthWriteParams,colorWrite:v.defaultColorWriteParams}):v.makePipelineState({depthTest:{func:513},colorWrite:v.defaultColorWriteParams})},y.prototype.bindPipelineState=function(e){e.setPipelineState(this.pipeline)},y.shader=new c.ReloadableShaderModule(f,"./NativeLine.glsl",e),y);function y(e,t){var n=m.call(this,e,t)||this;return n.stipplePattern=null,n.stippleTextureBind=null,n.stippleTextureRepository=e.stippleTextureRepository,n}t.NativeLineTechnique=g;var b,_=(b=d.ShaderTechniqueConfiguration,n(x,b),i([d.parameter({count:6})],x.prototype,"output",void 0),i([d.parameter()],x.prototype,"slicePlaneEnabled",void 0),i([d.parameter()],x.prototype,"sliceHighlightDisabled",void 0),i([d.parameter()],x.prototype,"vertexColors",void 0),i([d.parameter()],x.prototype,"transparent",void 0),i([d.parameter()],x.prototype,"stippleEnabled",void 0),i([d.parameter()],x.prototype,"stippleOffColorEnabled",void 0),i([d.parameter()],x.prototype,"stippleIntegerRepeatsEnabled",void 0),x);function x(){var e=null!==b&&b.apply(this,arguments)||this;return e.output=0,e.slicePlaneEnabled=!1,e.sliceHighlightDisabled=!1,e.vertexColors=!1,e.transparent=!1,e.stippleEnabled=!1,e.stippleOffColorEnabled=!1,e.stippleIntegerRepeatsEnabled=!1,e}t.NativeLineTechniqueConfiguration=_}.apply(null,i))||(e.exports=r)},2743:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1679),n(1693),n(1859),n(1978),n(1981),n(1629),n(1744)],void 0===(r=function(e,t,n,i,r,o,a,s,l,c){var u,d,p,f,h;Object.defineProperty(t,"__esModule",{value:!0}),t.build=function(e){var t=new c.ShaderBuilder;return t.include(r.Transform,{linearDepth:!1}),t.include(o.VertexColor,e),t.include(s.LineStipple,e),t.vertex.uniforms.add("proj","mat4").add("view","mat4").add("model","mat4"),t.attributes.add("position","vec3"),t.varyings.add("vpos","vec3"),t.vertex.code.add(l.glsl(u=u||n(["\n    void main(void) {\n      vpos = (model * vec4(position, 1.0)).xyz;\n      forwardNormalizedVertexColor();\n      gl_Position = transformPosition(proj, view, vpos);\n  "],["\n    void main(void) {\n      vpos = (model * vec4(position, 1.0)).xyz;\n      forwardNormalizedVertexColor();\n      gl_Position = transformPosition(proj, view, vpos);\n  "]))),e.stippleEnabled&&(t.attributes.add("auxpos1","vec3"),t.vertex.uniforms.add("ndcToPixel","vec2"),t.vertex.code.add(l.glsl(d=d||n(["\n    vec4 vpos2 = transformPosition(proj, view, (model * vec4(auxpos1, 1.0)).xyz);\n    float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);\n\n    stipplePatternUv = lineSegmentPixelSize * stipplePatternPixelSizeInv;\n    ","\n\n    // Cancel out perspective correct interpolation because we want this length the really represent\n    // the screen distance\n    stipplePatternUv *= gl_Position.w;\n    "],["\n    vec4 vpos2 = transformPosition(proj, view, (model * vec4(auxpos1, 1.0)).xyz);\n    float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);\n\n    stipplePatternUv = lineSegmentPixelSize * stipplePatternPixelSizeInv;\n    ","\n\n    // Cancel out perspective correct interpolation because we want this length the really represent\n    // the screen distance\n    stipplePatternUv *= gl_Position.w;\n    "]),e.stippleIntegerRepeatsEnabled?"stipplePatternUv = floor(stipplePatternUv + 0.5);":""))),t.vertex.code.add(l.glsl(p=p||n(["\n  }\n  "],["\n  }\n  "]))),0===e.output&&(t.include(i.Slice,e),t.fragment.uniforms.add("constantColor","vec4").add("alphaCoverage","float"),t.fragment.code.add(l.glsl(f=f||n(["\n    void main() {\n      discardBySlice(vpos);\n\n      vec4 color = ",";\n\n      float stippleAlpha = getStippleAlpha();\n      discardByStippleAlpha(stippleAlpha, STIPPLE_ALPHA_COLOR_DISCARD);\n\n      gl_FragColor = highlightSlice(blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha), vpos);\n    }\n    "],["\n    void main() {\n      discardBySlice(vpos);\n\n      vec4 color = ",";\n\n      float stippleAlpha = getStippleAlpha();\n      discardByStippleAlpha(stippleAlpha, STIPPLE_ALPHA_COLOR_DISCARD);\n\n      gl_FragColor = highlightSlice(blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha), vpos);\n    }\n    "]),e.attributeColor?"vcolor":"constantColor"))),4===e.output&&(t.include(i.Slice,e),t.include(a.HighlightData),t.fragment.uniforms.add("depthTex","sampler2D"),t.fragment.uniforms.add("highlightViewportPixelSz","vec4"),t.fragment.code.add(l.glsl(h=h||n(["\n    void main() {\n      discardBySlice(vpos);\n\n      discardByStippleAlpha(getStippleAlpha(), STIPPLE_ALPHA_HIGHLIGHT_DISCARD);\n\n      gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n    }\n    "],["\n    void main() {\n      discardBySlice(vpos);\n\n      discardByStippleAlpha(getStippleAlpha(), STIPPLE_ALPHA_HIGHLIGHT_DISCARD);\n\n      gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n    }\n    "])))),t}}.apply(null,i))||(e.exports=r)},2744:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(11),n(5),n(3),n(33),n(12),n(15),n(48),n(118),n(150),n(1650),n(1727),n(1673),n(1721),n(1740),n(1778),n(1642),n(2745),n(1678),n(1779),n(1982),n(1982)],void 0===(r=function(e,t,n,i,r,w,o,a,A,R,s,C,l,O,c,u,d,M,p,f,h,v,I){function z(e,t,n,i,r){for(var o=0;o<r;o++)n[i++]=e[t++];return i}var m,g,y,b,D=r.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial"),_=(b=d.Material,n(se,b),se.prototype.dispose=function(){},se.prototype.setParameterValues=function(e){for(var t in e)if("cap"!==t){if("join"===t&&"round"===this.params[t]!=("round"===e[t])){D.error("join cannot be changed after creation");continue}if("stipplePattern"===t&&!!this.params[t]!=!!e[t]){D.error("stippledness cannot be changed after creation");continue}this.params[t]=e[t]}else D.error("cap cannot be changed after creation");this.validateParams(),this.notifyDirty("matChanged")},se.prototype.getParameters=function(){return this.params},se.prototype.getPassParameters=function(){return this.params},se.prototype.getTechniqueConfig=function(e){this.techniqueConfig.output=e;var t=o.isSome(this.params.stipplePattern);return this.techniqueConfig.stippleEnabled=t,this.techniqueConfig.stippleIntegerRepeatsEnabled=t&&this.params.stippleIntegerRepeats,this.techniqueConfig.stippleOffColorEnabled=t&&o.isSome(this.params.stippleOffColor),this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.roundJoins="round"===this.params.join,this.techniqueConfig.roundCaps="round"===this.params.cap,this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.polygonOffset=this.params.polygonOffset,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig.vvColor=this.params.vvColorEnabled,this.techniqueConfig.vvOpacity=this.params.vvOpacityEnabled,this.techniqueConfig.vvSize=this.params.vvSizeEnabled,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig},se.prototype.intersect=function(e,t,n,i,r,o,a,s,l){l?f.intersectDrapedRenderLineGeometry(e,i,o,this.params.width,a):this.intersectLineGeometry(e,t,n,i,this.params.width,a)},se.prototype.intersectLineGeometry=function(e,t,n,i,r,o){if(i.options.selectionMode&&!O.isAllHidden(t.componentVisibilities,e.componentOffsets)){if(!M.isTranslationMatrix(n))return void D.error("intersection assumes a translation-only matrix");var a=e.data.getVertexAttr(),s=a[I.RibbonVertexAttributeConstants.POSITION].data,l=r;if(this.params.vvSizeEnabled){var c=a[I.RibbonVertexAttributeConstants.SIZEFEATUREATTRIBUTE].data[0];l*=w.clamp(this.params.vvSizeOffset[0]+c*this.params.vvSizeFactor[0],this.params.vvSizeMinSize[0],this.params.vvSizeMaxSize[0])}else a[I.RibbonVertexAttributeConstants.SIZE]&&(l*=a[I.RibbonVertexAttributeConstants.SIZE].data[0]);var u=i.camera,d=H;A.vec2.copy(d,i.point);var p=l*u.pixelRatio/2+4*u.pixelRatio;R.vec3.set(J[0],d[0]-p,d[1]+p,0),R.vec3.set(J[1],d[0]+p,d[1]+p,0),R.vec3.set(J[2],d[0]+p,d[1]-p,0),R.vec3.set(J[3],d[0]-p,d[1]-p,0);for(var f=0;f<4;f++)u.unprojectPoint(J[f],Q[f]);C.plane.fromPoints(u.eye,Q[0],Q[1],$),C.plane.fromPoints(u.eye,Q[1],Q[2],ee),C.plane.fromPoints(u.eye,Q[2],Q[3],te),C.plane.fromPoints(u.eye,Q[3],Q[0],ne);var h=Number.MAX_VALUE,v=this.params.isClosed?s.length-2:s.length-5;for(f=0;f<v;f+=3){N[0]=s[f]+n[12],N[1]=s[f+1]+n[13],N[2]=s[f+2]+n[14];var m=(f+3)%s.length;if(j[0]=s[m]+n[12],j[1]=s[1+m]+n[13],j[2]=s[2+m]+n[14],!(C.plane.signedDistance($,N)<0&&C.plane.signedDistance($,j)<0||C.plane.signedDistance(ee,N)<0&&C.plane.signedDistance(ee,j)<0||C.plane.signedDistance(te,N)<0&&C.plane.signedDistance(te,j)<0||C.plane.signedDistance(ne,N)<0&&C.plane.signedDistance(ne,j)<0)){if(u.projectPoint(N,B),u.projectPoint(j,U),B[2]<0&&0<U[2]){R.vec3.subtract(F,N,j);var g=u.frustum,y=-C.plane.signedDistance(g.planes[4],N)/R.vec3.dot(F,g.planes[4]);R.vec3.scale(F,F,y),R.vec3.add(N,N,F),u.projectPoint(N,B)}else if(0<B[2]&&U[2]<0)R.vec3.subtract(F,j,N),g=u.frustum,y=-C.plane.signedDistance(g.planes[4],j)/R.vec3.dot(F,g.planes[4]),R.vec3.scale(F,F,y),R.vec3.add(j,j,F),u.projectPoint(j,U);else if(B[2]<0&&U[2]<0)continue;B[2]=0,U[2]=0;var b=C.lineSegment.distance2(C.lineSegment.fromPoints(B,U,W),d);b<h&&(h=b,R.vec3.copy(k,N),R.vec3.copy(q,j))}}var _=i.rayBeginPoint,x=i.rayEndPoint;if(h<p*p){var S=Number.MAX_VALUE;if(C.lineSegment.closestLineSegmentPoint(C.lineSegment.fromPoints(k,q,W),C.lineSegment.fromPoints(_,x,Z),G)){R.vec3.subtract(G,G,_);var P=R.vec3.length(G);R.vec3.scale(G,G,1/P),S=P/R.vec3.distance(_,x)}o(S,G)}}},se.prototype.computeAttachmentOrigin=function(e,t){var n=e.data,i="getVertexAttr"in n?n.getVertexAttr():"vertexAttr"in n?n.vertexAttr:null;if(!i)return null;var r=i[I.RibbonVertexAttributeConstants.POSITION];return c.computeAttachmentOriginLines(r,null,t)},se.prototype.createLayout=function(){var e=l.newLayout().vec3f(I.RibbonVertexAttributeConstants.POSITION).f32(I.RibbonVertexAttributeConstants.SUBDIVISIONFACTOR).vec2f(I.RibbonVertexAttributeConstants.UV0).vec3f(I.RibbonVertexAttributeConstants.AUXPOS1).vec3f(I.RibbonVertexAttributeConstants.AUXPOS2);return this.params.vvSizeEnabled?e.f32(I.RibbonVertexAttributeConstants.SIZEFEATUREATTRIBUTE):e.f32(I.RibbonVertexAttributeConstants.SIZE),this.params.vvColorEnabled?e.f32(I.RibbonVertexAttributeConstants.COLORFEATUREATTRIBUTE):e.vec4f(I.RibbonVertexAttributeConstants.COLOR),this.params.vvOpacityEnabled&&e.f32(I.RibbonVertexAttributeConstants.OPACITYFEATUREATTRIBUTE),e},se.prototype.createBufferWriter=function(){return new L(this.layout,this.params)},se.prototype.createRenderer=function(e,t){return new h(e,t,this,I.ribbonVertexAttributeLocations)},se.prototype.getGLMaterials=function(){return{color:S,depthShadowMap:void 0,normal:void 0,depth:void 0,highlight:P}},se.prototype.validateParams=function(){this.params.width&&1<this.params.width&&(this.params.width=Math.round(this.params.width)),"miter"!==this.params.join&&(this.params.miterLimit=0)},se),x=(y=u.GLMaterial,n(ae,y),ae.prototype.updateParameters=function(){this.technique=this.techniqueRep.acquireAndReleaseExisting(v.RibbonLineTechnique,this.material.getTechniqueConfig(this.output),this.technique)},ae.prototype.beginSlot=function(e){return 0===this.output?e===(this.technique.configuration.writeDepth?6:9):4===e},ae.prototype.getProgram=function(){return this.technique.program},ae.prototype.getPrograms=function(){return null},ae.prototype.bind=function(e,t){e.bindProgram(this.technique.program),this.technique.bindPipelineState(e),this.technique.bindPass(e,this.material.getPassParameters(),t)},ae.prototype.release=function(){},ae.prototype.bindView=function(e){this.technique.bindDraw(e)},ae.prototype.bindInstance=function(e){this.technique.bindInstance(e)},ae.prototype.getDrawMode=function(){return 5},ae),S=(n(oe,g=x),oe),P=(n(re,m=x),re),T=i({width:0,color:[1,1,1,1],join:"miter",cap:"butt",miterLimit:5,writeDepth:!0,polygonOffset:!1,stipplePattern:null,stippleIntegerRepeats:!1,stippleOffColor:null,slicePlaneEnabled:!1,vvFastUpdate:!1,transparent:!1,isClosed:!1},p.Default),L=(ie.prototype.allocate=function(e){return this.vertexBufferLayout.createBuffer(e)},ie.prototype.elementCount=function(e){var t=2*this.numCapSubdivisions+2,n=e.indices[I.RibbonVertexAttributeConstants.POSITION].length/2+1,i=this.params.isClosed,r=i?2:2*t,o=i?0:1,a=i?n:n-1;if(e.vertexAttr[I.RibbonVertexAttributeConstants.SUBDIVISIONS])for(var s=e.vertexAttr[I.RibbonVertexAttributeConstants.SUBDIVISIONS].data,l=o;l<a;++l)r+=4+2*s[l];else r+=a*(2*this.numJoinSubdivisions+4);return r+2},ie.prototype.write=function(e,t,n,i){var a=this,r=X,o=Y,s=K,l=t.vertexAttr[I.RibbonVertexAttributeConstants.POSITION].data,c=t.indices&&t.indices[I.RibbonVertexAttributeConstants.POSITION];c&&c.length!==2*(l.length/3-1)&&console.warn("RibbonLineMaterial does not support indices");var u=null;t.vertexAttr[I.RibbonVertexAttributeConstants.SUBDIVISIONS]&&(u=t.vertexAttr[I.RibbonVertexAttributeConstants.SUBDIVISIONS].data);var d=1,p=0;this.params.vvSizeEnabled?p=t.vertexAttr[I.RibbonVertexAttributeConstants.SIZEFEATUREATTRIBUTE].data[0]:t.vertexAttr[I.RibbonVertexAttributeConstants.SIZE]&&(d=t.vertexAttr[I.RibbonVertexAttributeConstants.SIZE].data[0]);var f=[1,1,1,1],h=0;this.params.vvColorEnabled?h=t.vertexAttr[I.RibbonVertexAttributeConstants.COLORFEATUREATTRIBUTE].data[0]:t.vertexAttr[I.RibbonVertexAttributeConstants.COLOR]&&(f=t.vertexAttr[I.RibbonVertexAttributeConstants.COLOR].data);var v=0;function m(e,t,n,i,r,o){b[x++]=t[0],b[x++]=t[1],b[x++]=t[2],b[x++]=i,b[x++]=r,b[x++]=o,b[x++]=e[0],b[x++]=e[1],b[x++]=e[2],b[x++]=n[0],b[x++]=n[1],b[x++]=n[2],a.params.vvSizeEnabled?b[x++]=p:b[x++]=d,a.params.vvColorEnabled?b[x++]=h:(b[x++]=f[0],b[x++]=f[1],b[x++]=f[2],b[x++]=f[3]),a.params.vvOpacityEnabled&&(b[x++]=v)}this.params.vvOpacityEnabled&&(v=t.vertexAttr[I.RibbonVertexAttributeConstants.OPACITYFEATUREATTRIBUTE].data[0]);var g=l.length/3,y=e.transformation,b=new Float32Array(n.buffer),_=this.vertexBufferLayout.stride/4,x=i*_,S=x;x+=_,R.vec3.set(o,l[0],l[1],l[2]),y&&R.vec3.transformMat4(o,o,y);var P=this.params.isClosed;if(P){var w=l.length-3;R.vec3.set(r,l[w],l[1+w],l[2+w]),y&&R.vec3.transformMat4(r,r,y)}else{R.vec3.copy(r,o),R.vec3.set(s,l[3],l[4],l[5]),y&&R.vec3.transformMat4(s,s,y);for(var A=0;A<this.numCapSubdivisions;++A)m(r,o,s,T=1-A/this.numCapSubdivisions,1,-4),m(r,o,s,T,1,4);m(r,o,s,0,0,-4),m(r,o,s,0,0,4),R.vec3.copy(r,o),R.vec3.copy(o,s)}var C=P?g:g-1;for(A=P?0:1;A<C;A++){var O=(A+1)%g*3;R.vec3.set(s,l[0+O],l[1+O],l[2+O]),y&&R.vec3.transformMat4(s,s,y),m(r,o,s,0,1,-1),m(r,o,s,0,1,1);for(var M=u?u[A]:this.numJoinSubdivisions,D=0;D<M;++D)m(r,o,s,T=(D+1)/(M+1),1,-2),m(r,o,s,T,1,2);m(r,o,s,1,0,-2),m(r,o,s,1,0,2),R.vec3.copy(r,o),R.vec3.copy(o,s)}if(P)x=z(b,S+_,b,x,2*_);else for(m(r,o,s,0,1,-5),m(r,o,s,0,1,5),A=0;A<this.numCapSubdivisions;++A){var T;m(r,o,s,T=(A+1)/this.numCapSubdivisions,1,-5),m(r,o,s,T,1,5)}z(b,S+_,b,S,_),x=z(b,x-_,b,x,_)},ie),E=3,V=1,N=s.vec3f64.create(),j=s.vec3f64.create(),F=s.vec3f64.create(),G=s.vec3f64.create(),H=s.vec3f64.create(),B=a.createRenderScreenPointArray3(),U=a.createRenderScreenPointArray3(),k=s.vec3f64.create(),q=s.vec3f64.create(),W=C.lineSegment.create(),Z=C.lineSegment.create(),X=s.vec3f64.create(),Y=s.vec3f64.create(),K=s.vec3f64.create(),J=[a.createRenderScreenPointArray3(),a.createRenderScreenPointArray3(),a.createRenderScreenPointArray3(),a.createRenderScreenPointArray3()],Q=[s.vec3f64.create(),s.vec3f64.create(),s.vec3f64.create(),s.vec3f64.create()],$=C.plane.create(),ee=C.plane.create(),te=C.plane.create(),ne=C.plane.create();function ie(e,t){if(this.params=t,this.numCapSubdivisions=0,this.numJoinSubdivisions=0,this.vertexBufferLayout=e,!t.isClosed)switch(this.params.cap){case"butt":this.numCapSubdivisions=0;break;case"square":this.numCapSubdivisions=1;break;case"round":this.numCapSubdivisions=E}switch(this.params.join){case"miter":case"bevel":this.numJoinSubdivisions=t.stipplePattern?1:0;break;case"round":this.numJoinSubdivisions=V}}function re(e){return m.call(this,i({},e,{output:4}))||this}function oe(e){return g.call(this,i({},e,{output:0}))||this}function ae(e){var t=y.call(this,e)||this;return t.output=e.output,t.updateParameters(),t}function se(e,t){var n=b.call(this,t)||this;return n.techniqueConfig=new I.RibbonLineTechniqueConfiguration,n.params=f.copyParameters(e,T),n.validateParams(),n.params.transparent=n.params.color[3]<1||n.params.transparent,n.layout=n.createLayout(),n}return _}.apply(null,i))||(e.exports=r)},2745:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1654),n(1684)],void 0===(r=function(e,t,n,i){var r;return(r||(r={})).Default={vvSizeEnabled:!1,vvSizeMinSize:i.vec3f32.fromValues(1,1,1),vvSizeMaxSize:i.vec3f32.fromValues(100,100,100),vvSizeOffset:i.vec3f32.fromValues(0,0,0),vvSizeFactor:i.vec3f32.fromValues(1,1,1),vvSizeValue:i.vec3f32.fromValues(1,1,1),vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],vvOpacityEnabled:!1,vvOpacityValues:[0,0,0,0,0,0,0,0],vvOpacityOpacities:[1,1,1,1,1,1,1,1],vvSymbolAnchor:[0,0,0],vvSymbolRotationMatrix:n.mat3f64.create()},r}.apply(null,i))||(e.exports=r)},2746:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1679),n(2747),n(1981),n(1856),n(1629),n(1744)],void 0===(r=function(e,t,n,i,r,o,a,s,l){var c,u,d,p,f,h,v,m,g,y,b,_,x,S,P,w,A,C;Object.defineProperty(t,"__esModule",{value:!0}),t.build=function(e){var t=new l.ShaderBuilder;return t.extensions.add("GL_OES_standard_derivatives"),t.include(a.PiUtils),t.include(r.RibbonVertexPosition,e),t.include(o.LineStipple,e),t.vertex.uniforms.add("proj","mat4").add("view","mat4").add("model","mat4").add("nearPlane","float").add("pixelRatio","float").add("miterLimit","float").add("screenSize","vec2"),t.attributes.add("position","vec3"),t.attributes.add("subdivisionFactor","float"),t.attributes.add("uv0","vec2"),t.attributes.add("auxpos1","vec3"),t.attributes.add("auxpos2","vec3"),t.varyings.add("vColor","vec4"),t.varyings.add("vpos","vec3"),t.vertex.code.add(s.glsl(c=c||n(["\n\t\t#define PERPENDICULAR(v) vec2(v.y, -v.x);\n\t\t#define ISOUTSIDE (left.x * right.y - left.y * right.x)*uv0.y > 0.0\n\n\t\tfloat interp(float ncp, vec4 a, vec4 b) {\n\t\t\treturn (-ncp - a.z) / (b.z - a.z);\n\t\t}\n\n\t\tvec2 rotate(vec2 v, float a) {\n\t\t\tfloat s = sin(a);\n\t\t\tfloat c = cos(a);\n\t\t\tmat2 m = mat2(c, -s, s, c);\n\t\t\treturn m * v;\n\t\t}\n"],["\n\t\t#define PERPENDICULAR(v) vec2(v.y, -v.x);\n\t\t#define ISOUTSIDE (left.x * right.y - left.y * right.x)*uv0.y > 0.0\n\n\t\tfloat interp(float ncp, vec4 a, vec4 b) {\n\t\t\treturn (-ncp - a.z) / (b.z - a.z);\n\t\t}\n\n\t\tvec2 rotate(vec2 v, float a) {\n\t\t\tfloat s = sin(a);\n\t\t\tfloat c = cos(a);\n\t\t\tmat2 m = mat2(c, -s, s, c);\n\t\t\treturn m * v;\n\t\t}\n"]))),t.vertex.code.add(s.glsl(u=u||n(["\n    vec4 projectAndScale(vec4 pos) {\n      vec4 posNdc = proj * pos;\n\n      // Note that posNdc is in -1:1, scaling by screenSize converts this to a coordinate system\n      // that is twice scaled (going from -size:size).\n      posNdc.xy *= screenSize / posNdc.w;\n      return posNdc;\n    }\n"],["\n    vec4 projectAndScale(vec4 pos) {\n      vec4 posNdc = proj * pos;\n\n      // Note that posNdc is in -1:1, scaling by screenSize converts this to a coordinate system\n      // that is twice scaled (going from -size:size).\n      posNdc.xy *= screenSize / posNdc.w;\n      return posNdc;\n    }\n"]))),t.vertex.code.add(s.glsl(d=d||n(["\n    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\n      float vnp = nearPlane*0.99;\n\n      //current pos behind ncp --\x3e we need to clip\n      if(pos.z > -nearPlane) {\n        if (!isStartVertex) {\n          //previous in front of ncp\n          if(prev.z < -nearPlane) {\n            pos = mix(prev, pos, interp(vnp, prev, pos));\n            next = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n        //next in front of ncp\n        if(isStartVertex) {\n          if(next.z < -nearPlane) {\n            pos = mix(pos, next, interp(vnp, pos, next));\n            prev = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n      } else {\n        //current position visible\n        //previous behind ncp\n        if (prev.z > -nearPlane) {\n          prev = mix(pos, prev, interp(vnp, pos, prev));\n        }\n        //next behind ncp\n        if (next.z > -nearPlane) {\n          next = mix(next, pos, interp(vnp, next, pos));\n        }\n      }\n\n      pos = projectAndScale(pos);\n      next = projectAndScale(next);\n      prev = projectAndScale(prev);\n    }\n"],["\n    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\n      float vnp = nearPlane*0.99;\n\n      //current pos behind ncp --\x3e we need to clip\n      if(pos.z > -nearPlane) {\n        if (!isStartVertex) {\n          //previous in front of ncp\n          if(prev.z < -nearPlane) {\n            pos = mix(prev, pos, interp(vnp, prev, pos));\n            next = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n        //next in front of ncp\n        if(isStartVertex) {\n          if(next.z < -nearPlane) {\n            pos = mix(pos, next, interp(vnp, pos, next));\n            prev = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n      } else {\n        //current position visible\n        //previous behind ncp\n        if (prev.z > -nearPlane) {\n          prev = mix(pos, prev, interp(vnp, pos, prev));\n        }\n        //next behind ncp\n        if (next.z > -nearPlane) {\n          next = mix(next, pos, interp(vnp, next, pos));\n        }\n      }\n\n      pos = projectAndScale(pos);\n      next = projectAndScale(next);\n      prev = projectAndScale(prev);\n    }\n"]))),t.vertex.code.add(s.glsl(p=p||n(["\n  void main(void) {\n    float coverage = 1.0;\n    vpos = (model * vec4(position, 1.0)).xyz;\n\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;\n      bool isJoin = abs(uv0.y)-3.0 < 0.0;\n\n      float lineWidth = getSize() * pixelRatio;\n\n      // convert sub-pixel coverage to alpha\n      if( lineWidth<1.0 ){\n        coverage = lineWidth;\n        lineWidth = 1.0;\n      }\n\n      vec4 pos  = view * vec4((model * vec4(position.xyz, 1.0)).xyz, 1.0);\n      vec4 prev = view * vec4((model * vec4(auxpos1.xyz, 1.0)).xyz, 1.0);\n      vec4 next = view * vec4((model * vec4(auxpos2.xyz, 1.0)).xyz, 1.0);\n\n      clipAndTransform(pos, prev, next, isStartVertex);\n\n      vec2 left = (pos.xy - prev.xy);\n      vec2 right = (next.xy - pos.xy);\n\n      float leftLen = length(left);\n      float rightLen = length(right);\n  "],["\n  void main(void) {\n    float coverage = 1.0;\n    vpos = (model * vec4(position, 1.0)).xyz;\n\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;\n      bool isJoin = abs(uv0.y)-3.0 < 0.0;\n\n      float lineWidth = getSize() * pixelRatio;\n\n      // convert sub-pixel coverage to alpha\n      if( lineWidth<1.0 ){\n        coverage = lineWidth;\n        lineWidth = 1.0;\n      }\n\n      vec4 pos  = view * vec4((model * vec4(position.xyz, 1.0)).xyz, 1.0);\n      vec4 prev = view * vec4((model * vec4(auxpos1.xyz, 1.0)).xyz, 1.0);\n      vec4 next = view * vec4((model * vec4(auxpos2.xyz, 1.0)).xyz, 1.0);\n\n      clipAndTransform(pos, prev, next, isStartVertex);\n\n      vec2 left = (pos.xy - prev.xy);\n      vec2 right = (next.xy - pos.xy);\n\n      float leftLen = length(left);\n      float rightLen = length(right);\n  "]))),e.stippleEnabled&&t.vertex.code.add(s.glsl(f=f||n(["\n      // uv0.x is either 0 or 1, depending on whether this is considered the start of a line segment\n      // or the end. If start, then use pos->next, otherwise use prev->pos to define the line segment\n      // vector\n      vec4 stippleSegmentInfo = mix(vec4(pos.xy, right), vec4(prev.xy, left), uv0.x);\n      vec2 stippleSegmentOrigin = stippleSegmentInfo.xy;\n\n      // Scale s.t. it's in units of stipple pattern size.\n      vec2 stippleSegmentDirection = stippleSegmentInfo.zw;\n    "],["\n      // uv0.x is either 0 or 1, depending on whether this is considered the start of a line segment\n      // or the end. If start, then use pos->next, otherwise use prev->pos to define the line segment\n      // vector\n      vec4 stippleSegmentInfo = mix(vec4(pos.xy, right), vec4(prev.xy, left), uv0.x);\n      vec2 stippleSegmentOrigin = stippleSegmentInfo.xy;\n\n      // Scale s.t. it's in units of stipple pattern size.\n      vec2 stippleSegmentDirection = stippleSegmentInfo.zw;\n    "]))),t.vertex.code.add(s.glsl(h=h||n(['\n    left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);\n    right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);\n\n    vec2 capDisplacementDir = vec2(0, 0);\n    vec2 joinDisplacementDir = vec2(0, 0);\n    float displacementLen = lineWidth;\n\n    if (isJoin) {\n\n      // JOIN handling ---------------------------------------------------\n      // determine if vertex is on the "outside or "inside" of the join\n      bool isOutside = ISOUTSIDE;\n\n      // compute miter join position first\n      joinDisplacementDir = normalize(left + right);\n      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n\n      // computer miter stretch\n      if (leftLen > 0.001 && rightLen > 0.001) {\n        float nDotSeg = dot(joinDisplacementDir, left);\n        displacementLen /= length(nDotSeg*left - joinDisplacementDir);\n\n        // limit displacement of inner vertices\n        if (!isOutside) {\n          displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n        }\n      }\n\n      if (isOutside && (displacementLen > miterLimit*lineWidth)) {\n    '],['\n    left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);\n    right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);\n\n    vec2 capDisplacementDir = vec2(0, 0);\n    vec2 joinDisplacementDir = vec2(0, 0);\n    float displacementLen = lineWidth;\n\n    if (isJoin) {\n\n      // JOIN handling ---------------------------------------------------\n      // determine if vertex is on the "outside or "inside" of the join\n      bool isOutside = ISOUTSIDE;\n\n      // compute miter join position first\n      joinDisplacementDir = normalize(left + right);\n      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n\n      // computer miter stretch\n      if (leftLen > 0.001 && rightLen > 0.001) {\n        float nDotSeg = dot(joinDisplacementDir, left);\n        displacementLen /= length(nDotSeg*left - joinDisplacementDir);\n\n        // limit displacement of inner vertices\n        if (!isOutside) {\n          displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n        }\n      }\n\n      if (isOutside && (displacementLen > miterLimit*lineWidth)) {\n    ']))),e.roundJoins?t.vertex.code.add(s.glsl(v=v||n(["\n        vec2 startDir;\n        vec2 endDir;\n\n        if (leftLen < 0.001) {\n          startDir = right;\n        }\n        else{\n          startDir = left;\n        }\n        startDir = normalize(startDir);\n        startDir = PERPENDICULAR(startDir);\n\n        if (rightLen < 0.001) {\n          endDir = left;\n        }\n        else{\n          endDir = right;\n        }\n        endDir = normalize(endDir);\n        endDir = PERPENDICULAR(endDir);\n\n        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));\n        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * subdivisionFactor * rotationAngle);\n      "],["\n        vec2 startDir;\n        vec2 endDir;\n\n        if (leftLen < 0.001) {\n          startDir = right;\n        }\n        else{\n          startDir = left;\n        }\n        startDir = normalize(startDir);\n        startDir = PERPENDICULAR(startDir);\n\n        if (rightLen < 0.001) {\n          endDir = left;\n        }\n        else{\n          endDir = right;\n        }\n        endDir = normalize(endDir);\n        endDir = PERPENDICULAR(endDir);\n\n        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));\n        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * subdivisionFactor * rotationAngle);\n      "]))):t.vertex.code.add(s.glsl(m=m||n(["\n        // convert to bevel join if miterLimit is exceeded\n        if (leftLen < 0.001) {\n          joinDisplacementDir = right;\n        }\n        else if (rightLen < 0.001) {\n          joinDisplacementDir = left;\n        }\n        else {\n          joinDisplacementDir = isStartVertex ? right : left;\n        }\n        joinDisplacementDir = normalize(joinDisplacementDir);\n        joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n  "],["\n        // convert to bevel join if miterLimit is exceeded\n        if (leftLen < 0.001) {\n          joinDisplacementDir = right;\n        }\n        else if (rightLen < 0.001) {\n          joinDisplacementDir = left;\n        }\n        else {\n          joinDisplacementDir = isStartVertex ? right : left;\n        }\n        joinDisplacementDir = normalize(joinDisplacementDir);\n        joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n  "]))),t.vertex.code.add(s.glsl(g=g||n(["\n        displacementLen = lineWidth;\n      }\n    } else {\n    // CAP handling ---------------------------------------------------\n    if (leftLen < 0.001) {\n      joinDisplacementDir = right;\n    }\n    else if (rightLen < 0.001) {\n      joinDisplacementDir = left;\n    }\n    else {\n      joinDisplacementDir = isStartVertex ? right : left;\n    }\n    joinDisplacementDir = normalize(joinDisplacementDir);\n    joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n    displacementLen = lineWidth;\n\n    capDisplacementDir = isStartVertex ? -right : left;\n  "],["\n        displacementLen = lineWidth;\n      }\n    } else {\n    // CAP handling ---------------------------------------------------\n    if (leftLen < 0.001) {\n      joinDisplacementDir = right;\n    }\n    else if (rightLen < 0.001) {\n      joinDisplacementDir = left;\n    }\n    else {\n      joinDisplacementDir = isStartVertex ? right : left;\n    }\n    joinDisplacementDir = normalize(joinDisplacementDir);\n    joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n    displacementLen = lineWidth;\n\n    capDisplacementDir = isStartVertex ? -right : left;\n  "]))),e.roundCaps?t.vertex.code.add(s.glsl(y=y||n(["\n    float angle = subdivisionFactor*PI*0.5;\n    joinDisplacementDir *= cos(angle);\n    capDisplacementDir *= sin(angle);\n    "],["\n    float angle = subdivisionFactor*PI*0.5;\n    joinDisplacementDir *= cos(angle);\n    capDisplacementDir *= sin(angle);\n    "]))):t.vertex.code.add(s.glsl(b=b||n(["\n    capDisplacementDir *= subdivisionFactor;\n    "],["\n    capDisplacementDir *= subdivisionFactor;\n    "]))),t.vertex.code.add(s.glsl(_=_||n(["\n  }\n\n  pos.xy += joinDisplacementDir * sign(uv0.y) * displacementLen;\n  pos.xy += capDisplacementDir * displacementLen;\n  "],["\n  }\n\n  pos.xy += joinDisplacementDir * sign(uv0.y) * displacementLen;\n  pos.xy += capDisplacementDir * displacementLen;\n  "]))),e.stippleEnabled&&(t.vertex.code.add(s.glsl(x=x||n(["\n    {\n      // Compute the stipple pattern UV coordinate from the actual position, based on the origin\n      // and direction of the line segment on which the stipple pattern is based.\n\n      // Project the vector from the origin of the segment to the vertex onto the line segment.\n      // Note the 0.5 factor due to projected positions being at twice the screen size scale (see projectAndScale)\n      vec2 posVec = pos.xy - stippleSegmentOrigin;\n\n      float stippleSegmentDirectionLength = length(stippleSegmentDirection);\n    "],["\n    {\n      // Compute the stipple pattern UV coordinate from the actual position, based on the origin\n      // and direction of the line segment on which the stipple pattern is based.\n\n      // Project the vector from the origin of the segment to the vertex onto the line segment.\n      // Note the 0.5 factor due to projected positions being at twice the screen size scale (see projectAndScale)\n      vec2 posVec = pos.xy - stippleSegmentOrigin;\n\n      float stippleSegmentDirectionLength = length(stippleSegmentDirection);\n    "]))),e.stippleIntegerRepeatsEnabled&&t.vertex.code.add(s.glsl(S=S||n(["\n      float numberOfPatternRepeats = stippleSegmentDirectionLength * 0.5 * stipplePatternPixelSizeInv;\n      float roundedNumberOfPatternRepeats = max(1.0, floor(numberOfPatternRepeats + 0.5));\n      stipplePatternUvMax = roundedNumberOfPatternRepeats;\n      "],["\n      float numberOfPatternRepeats = stippleSegmentDirectionLength * 0.5 * stipplePatternPixelSizeInv;\n      float roundedNumberOfPatternRepeats = max(1.0, floor(numberOfPatternRepeats + 0.5));\n      stipplePatternUvMax = roundedNumberOfPatternRepeats;\n      "]))),t.vertex.code.add(s.glsl(P=P||n(["\n      if (stippleSegmentDirectionLength >= 0.001) {\n        // Project the vertex position onto the line segment.\n        float projectedLength = dot(stippleSegmentDirection, posVec) / stippleSegmentDirectionLength * 0.5;\n     ","\n        stipplePatternUv = projectedLength * wholeNumberOfRepeatsScale * stipplePatternPixelSizeInv * pos.w;\n        } else {\n          stipplePatternUv = 1.0;\n        }\n      }\n    "],["\n      if (stippleSegmentDirectionLength >= 0.001) {\n        // Project the vertex position onto the line segment.\n        float projectedLength = dot(stippleSegmentDirection, posVec) / stippleSegmentDirectionLength * 0.5;\n     ","\n        stipplePatternUv = projectedLength * wholeNumberOfRepeatsScale * stipplePatternPixelSizeInv * pos.w;\n        } else {\n          stipplePatternUv = 1.0;\n        }\n      }\n    "]),e.stippleIntegerRepeatsEnabled?"float wholeNumberOfRepeatsScale = roundedNumberOfPatternRepeats / numberOfPatternRepeats;":"float wholeNumberOfRepeatsScale = 1.0;"))),t.vertex.code.add(s.glsl(w=w||n(["\n      // Convert back into NDC\n      pos.xy = pos.xy / screenSize * pos.w;\n\n      vColor = getColor();\n      vColor.a *= coverage;\n\n      gl_Position = pos;\n    }\n  }\n  "],["\n      // Convert back into NDC\n      pos.xy = pos.xy / screenSize * pos.w;\n\n      vColor = getColor();\n      vColor.a *= coverage;\n\n      gl_Position = pos;\n    }\n  }\n  "]))),t.include(i.Slice,e),0===e.output&&(t.fragment.uniforms.add("symbolColor","vec4"),t.fragment.code.add(s.glsl(A=A||n(["\n    void main() {\n      discardBySlice(vpos);\n      float stippleAlpha = getStippleAlpha();\n      discardByStippleAlpha(stippleAlpha, STIPPLE_ALPHA_COLOR_DISCARD);\n      vec4 color = symbolColor * vColor;\n      gl_FragColor = highlightSlice(blendStipple(color, stippleAlpha), vpos);\n    }\n    "],["\n    void main() {\n      discardBySlice(vpos);\n      float stippleAlpha = getStippleAlpha();\n      discardByStippleAlpha(stippleAlpha, STIPPLE_ALPHA_COLOR_DISCARD);\n      vec4 color = symbolColor * vColor;\n      gl_FragColor = highlightSlice(blendStipple(color, stippleAlpha), vpos);\n    }\n    "])))),4===e.output&&t.fragment.code.add(s.glsl(C=C||n(["\n      void main() {\n        discardBySlice(vpos);\n        discardByStippleAlpha(getStippleAlpha(), STIPPLE_ALPHA_HIGHLIGHT_DISCARD);\n        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n      }\n    "],["\n      void main() {\n        discardBySlice(vpos);\n        discardByStippleAlpha(getStippleAlpha(), STIPPLE_ALPHA_HIGHLIGHT_DISCARD);\n        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n      }\n    "]))),t}}.apply(null,i))||(e.exports=r)},2747:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1629)],void 0===(r=function(e,t,n,i){var r,o,a,s,l,c;Object.defineProperty(t,"__esModule",{value:!0}),t.RibbonVertexPosition=function(e,t){e.vertex.uniforms.add("symbolLineWidth","float"),t.vvSize?(e.attributes.add("sizeFeatureAttribute","float"),e.vertex.uniforms.add("vvSizeMinSize","vec3"),e.vertex.uniforms.add("vvSizeMaxSize","vec3"),e.vertex.uniforms.add("vvSizeOffset","vec3"),e.vertex.uniforms.add("vvSizeFactor","vec3"),e.vertex.code.add(i.glsl(r=r||n(["\n    float getSize() {\n      return symbolLineWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;\n    }\n    "],["\n    float getSize() {\n      return symbolLineWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;\n    }\n    "])))):(e.attributes.add("size","float"),e.vertex.code.add(i.glsl(o=o||n(["\n    float getSize(){\n      return symbolLineWidth * size;\n    }\n    "],["\n    float getSize(){\n      return symbolLineWidth * size;\n    }\n    "])))),t.vvOpacity?(e.attributes.add("opacityFeatureAttribute","float"),e.vertex.defines.addInt("VV_OPACITY_N",8),e.vertex.code.add(i.glsl(a=a||n(["\n    uniform float vvOpacityValues[VV_OPACITY_N];\n    uniform float vvOpacityOpacities[VV_OPACITY_N];\n\n    float interpolateOpacity( float value ){\n      if (value <= vvOpacityValues[0]) {\n        return vvOpacityOpacities[0];\n      }\n\n      for (int i = 1; i < VV_OPACITY_N; ++i) {\n        if (vvOpacityValues[i] >= value) {\n          float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);\n          return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);\n        }\n      }\n\n      return vvOpacityOpacities[VV_OPACITY_N - 1];\n    }\n\n    vec4 applyOpacity( vec4 color ){\n      return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));\n    }\n    "],["\n    uniform float vvOpacityValues[VV_OPACITY_N];\n    uniform float vvOpacityOpacities[VV_OPACITY_N];\n\n    float interpolateOpacity( float value ){\n      if (value <= vvOpacityValues[0]) {\n        return vvOpacityOpacities[0];\n      }\n\n      for (int i = 1; i < VV_OPACITY_N; ++i) {\n        if (vvOpacityValues[i] >= value) {\n          float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);\n          return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);\n        }\n      }\n\n      return vvOpacityOpacities[VV_OPACITY_N - 1];\n    }\n\n    vec4 applyOpacity( vec4 color ){\n      return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));\n    }\n    "])))):e.vertex.code.add(i.glsl(s=s||n(["\n    vec4 applyOpacity( vec4 color ){\n      return color;\n    }\n    "],["\n    vec4 applyOpacity( vec4 color ){\n      return color;\n    }\n    "]))),t.vvColor?(e.attributes.add("colorFeatureAttribute","float"),e.vertex.defines.addInt("VV_COLOR_N",8),e.vertex.code.add(i.glsl(l=l||n(["\n    uniform float vvColorValues[VV_COLOR_N];\n    uniform vec4 vvColorColors[VV_COLOR_N];\n\n    vec4 interpolateColor( float value ) {\n      if (value <= vvColorValues[0]) {\n        return vvColorColors[0];\n      }\n\n      for (int i = 1; i < VV_COLOR_N; ++i) {\n        if (vvColorValues[i] >= value) {\n          float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);\n          return mix(vvColorColors[i-1], vvColorColors[i], f);\n        }\n      }\n\n      return vvColorColors[VV_COLOR_N - 1];\n    }\n\n    vec4 getColor(){\n      return applyOpacity(interpolateColor(colorFeatureAttribute));\n    }\n    "],["\n    uniform float vvColorValues[VV_COLOR_N];\n    uniform vec4 vvColorColors[VV_COLOR_N];\n\n    vec4 interpolateColor( float value ) {\n      if (value <= vvColorValues[0]) {\n        return vvColorColors[0];\n      }\n\n      for (int i = 1; i < VV_COLOR_N; ++i) {\n        if (vvColorValues[i] >= value) {\n          float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);\n          return mix(vvColorColors[i-1], vvColorColors[i], f);\n        }\n      }\n\n      return vvColorColors[VV_COLOR_N - 1];\n    }\n\n    vec4 getColor(){\n      return applyOpacity(interpolateColor(colorFeatureAttribute));\n    }\n    "])))):(e.attributes.add("color","vec4"),e.vertex.code.add(i.glsl(c=c||n(["\n    vec4 getColor(){\n      return applyOpacity(color);\n    }\n    "],["\n    vec4 getColor(){\n      return applyOpacity(color);\n    }\n    "]))))}}.apply(null,i))||(e.exports=r)},2748:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(0),n(1),n(5),n(13),n(54),n(3),n(12),n(15),n(2),n(48),n(118),n(150),n(44),n(1668),n(326),n(512),n(2749)],void 0===(r=function(e,t,n,i,r,o,a,s,d,p,l,f,c,u,h,v,m,g,y){Object.defineProperty(t,"__esModule",{value:!0});var b,_=s.getLogger("esri.views.interactive.GraphicManipulator"),x=(b=l.declared(o),i(S,b),Object.defineProperty(S.prototype,"graphic",{set:function(e){"mesh"!==d.get(e.geometry,"type")?(this._circleCollisionCache=null,this._originalSymbol=e.symbol,this._set("graphic",e)):_.error("Mesh geometries are not supported")},enumerable:!0,configurable:!0}),Object.defineProperty(S.prototype,"elevationInfo",{get:function(){var e="elevationInfo"in this.graphic.layer&&this.graphic.layer.elevationInfo,t=v.getGraphicEffectiveElevationMode(this.graphic);return new g({mode:t,offset:e?e.offset:0})},enumerable:!0,configurable:!0}),Object.defineProperty(S.prototype,"focusedSymbol",{set:function(e){e!==this._get("focusedSymbol")&&(this._set("focusedSymbol",e),this._updateGraphicSymbol(),this._circleCollisionCache=null)},enumerable:!0,configurable:!0}),Object.defineProperty(S.prototype,"grabbing",{set:function(e){if(e!==this._get("grabbing")){var t=this._focused;this._set("grabbing",e),this._updateGraphicSymbol(t)}},enumerable:!0,configurable:!0}),Object.defineProperty(S.prototype,"hovering",{set:function(e){if(e!==this._get("hovering")){var t=this._focused;this._set("hovering",e),this._updateGraphicSymbol(t)}},enumerable:!0,configurable:!0}),Object.defineProperty(S.prototype,"selected",{set:function(e){e!==this._get("selected")&&(this._set("selected",e),this._updateGraphicSymbol())},enumerable:!0,configurable:!0}),Object.defineProperty(S.prototype,"_focused",{get:function(){return this._get("hovering")||this._get("grabbing")},enumerable:!0,configurable:!0}),S.prototype.destroy=function(){this._resetGraphicSymbol(),this._set("view",null)},S.prototype.intersectionDistance=function(e){var t=this._get("graphic");if(!1===t.visible)return null;var n=this._get("focusedSymbol"),i=d.isSome(n)?n:t.symbol,r=t.geometry;if(d.isNone(r))return null;var o=this._get("view");return"2d"===o.type?this._intersectDistance2D(e,o,r,i):this._intersectDistance3D(e,o,t)},S.prototype.attach=function(){d.isNone(this.layer)||this.layer.add(this.graphic)},S.prototype.detach=function(){this._resetGraphicSymbol(),d.isNone(this.layer)||this.layer.remove(this.graphic)},S.prototype._updateGraphicSymbol=function(e){if(void 0===e&&(e=this._focused),e!==this._focused){var t=this.graphic.symbol;t!==this._originalSymbol&&t!==this.focusedSymbol&&(this._originalSymbol=t)}this.graphic.symbol=this._focused&&d.isSome(this.focusedSymbol)?this.focusedSymbol:this._originalSymbol},S.prototype._resetGraphicSymbol=function(){this.graphic.symbol=this._originalSymbol},S.prototype._intersectDistance2D=function(e,t,n,i){if(i=i||m.getDefaultSymbol2D(n),d.isNone(i))return null;var r=this._circleCollisionCache;if("point"!==n.type||"simple-marker"!==i.type){var o=y.intersectsDrapedGeometry(e,n,t);return d.isSome(o)?1:null}if(d.isNone(r)||!r.originalPoint.equals(n)){var a=n,s=t.spatialReference;h.canProject(a,s)&&(o=h.project(a,s),r={originalPoint:a.clone(),mapPoint:o,radiusPx:p.pt2px(i.size)},this._circleCollisionCache=r)}if(d.isSome(r)){var l=p.screenPointObjectToArray(e,w),c=t.state.toScreen(A,r.mapPoint.x,r.mapPoint.y),u=r.radiusPx;return f.vec2.squaredDistance(l,c)<u*u?1:null}return null},S.prototype._intersectDistance3D=function(e,t,n){var i=t.toMap(e,{include:[n]});if(!i)return null;var r=P;return t.renderCoordsHelper.toRenderCoords(i,r)?c.vec3.distance(r,t.state.camera.eye):null},n([l.property({constructOnly:!0,nonNullable:!0})],S.prototype,"graphic",null),n([l.property({readOnly:!0,dependsOn:["graphic"]})],S.prototype,"elevationInfo",null),n([l.property({constructOnly:!0,nonNullable:!0})],S.prototype,"view",void 0),n([l.property({value:null})],S.prototype,"focusedSymbol",null),n([l.property({constructOnly:!0})],S.prototype,"layer",void 0),n([l.property()],S.prototype,"interactive",void 0),n([l.property()],S.prototype,"selectable",void 0),n([l.property({value:!1})],S.prototype,"grabbing",null),n([l.property()],S.prototype,"dragging",void 0),n([l.property()],S.prototype,"hovering",null),n([l.property({value:!1})],S.prototype,"selected",null),n([l.property()],S.prototype,"cursor",void 0),n([l.subclass("esri.views.interactive.GraphicManipulator")],S));function S(e){var t=b.call(this,e)||this;return t.layer=null,t.interactive=!0,t.selectable=!1,t.dragging=!1,t.cursor=null,t.events=new a({target:t}),t._circleCollisionCache=null,t._originalSymbol=null,t}t.GraphicManipulator=x;var P=u.vec3f64.create(),w=p.createScreenPointArray(),A=p.createScreenPointArray()}.apply(null,i))||(e.exports=r)},2749:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(28),n(12),n(69),n(1687)],void 0===(r=function(e,t,f,r,h,o){function a(e,t,n,i){var r;if(void 0===i&&(i=new f.Extent),"2d"===n.type)r=t*n.resolution;else if("3d"===n.type){var o=n.basemapTerrain,a=o.overlayManager,s=a?a.overlayPixelSizeInMapUnits(e):1;r=o&&!o.spatialReference.equals(n.spatialReference)?h.getMetersPerUnitForSR(o.spatialReference)/h.getMetersPerUnitForSR(n.spatialReference):t*s}var l=e.x-r,c=e.y-r,u=e.x+r,d=e.y+r,p=n.spatialReference;return i.xmin=Math.min(l,u),i.ymin=Math.min(c,d),i.xmax=Math.max(l,u),i.ymax=Math.max(c,d),i.spatialReference=p,i}Object.defineProperty(t,"__esModule",{value:!0}),t.createQueryGeometry=a,t.intersectsDrapedGeometry=function(e,t,n){var i=n.toMap(e);return r.isNone(i)?null:a(i,o.calculateTolerance(),n,s).intersects(t)?i:null};var s=new f.Extent}.apply(null,i))||(e.exports=r)},2750:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(0),n(18),n(12)],void 0===(r=function(e,t,n,i,l){Object.defineProperty(t,"__esModule",{value:!0});var r=(Object.defineProperty(o.prototype,"isToolEditable",{set:function(e){this._isToolEditable=e},enumerable:!0,configurable:!0}),Object.defineProperty(o.prototype,"length",{get:function(){return this._manipulators.length},enumerable:!0,configurable:!0}),o.prototype.add=function(e,t){return void 0===t&&(t=0),this.addMany([e],t)[0]},o.prototype.addMany=function(e,i){var r=this;return void 0===i&&(i=0),e.map(function(e){var t=r._nextManipulatorId++,n={id:t,manipulator:e,visibilityPredicate:i,attached:!1};return r._manipulators.add(n),r._attached&&r._updateManipulatorAttachment(n),t})},o.prototype.remove=function(e){if("number"==typeof e){for(var t=e,n=0;n<this._manipulators.length;n++)if(this._manipulators.getItemAt(n).id===t){var i=this._manipulators.splice(n,1)[0];return this._detachManipulator(i),i.id}return null}var r=e;for(n=0;n<this._manipulators.length;n++)if(this._manipulators.getItemAt(n).manipulator===r)return i=this._manipulators.splice(n,1)[0],this._detachManipulator(i),i.id;return null},o.prototype.removeAll=function(){var t=this;this._manipulators.forEach(function(e){t._detachManipulator(e)}),this._manipulators.removeAll()},o.prototype.attach=function(){var t=this;this._manipulators.forEach(function(e){t._updateManipulatorAttachment(e)}),this._attached=!0},o.prototype.detach=function(){var t=this;this._manipulators.forEach(function(e){t._detachManipulator(e)}),this._attached=!1},o.prototype.destroy=function(){this._manipulators.forEach(function(e){var t=e.manipulator;t.destroy&&t.destroy()}),this._manipulators.destroy(),this._resourceContexts=null},o.prototype.on=function(e,t){return this._manipulators.on(e,function(e){t(e)})},o.prototype.forEach=function(e){for(var t=0,n=this._manipulators.items;t<n.length;t++)e(n[t])},o.prototype.intersect=function(r,o){var a=null,s=Number.MAX_VALUE;return this._manipulators.forEach(function(e){var t=e.id,n=e.manipulator;if(e.attached&&n.interactive){var i=n.intersectionDistance(r,o);l.isSome(i)&&i<s&&(s=i,a=t)}}),a},o.prototype.findById=function(e){if(l.isNone(e))return null;for(var t=0,n=this._manipulators.items;t<n.length;t++){var i=n[t];if(e===i.id)return i.manipulator}return null},o.prototype._updateManipulatorAttachment=function(e){this._isManipulatorItemVisible(e)?this._attachManipulator(e):this._detachManipulator(e)},o.prototype._attachManipulator=function(e){e.attached||(e.manipulator.attach(this._resourceContexts),e.attached=!0)},o.prototype._detachManipulator=function(e){if(e.attached){var t=e.manipulator;t.grabbing=!1,t.dragging=!1,t.hovering=!1,t.selected=!1,t.detach(this._resourceContexts),e.attached=!1}},o.prototype._isManipulatorItemVisible=function(e){return 2===e.visibilityPredicate||(this._isToolEditable?0===e.visibilityPredicate:1===e.visibilityPredicate)},o);function o(){this._isToolEditable=!0,this._manipulators=new i,this._nextManipulatorId=0,this._resourceContexts={manipulator3D:{}},this._attached=!1}t.ManipulatorCollection=r}.apply(null,i))||(e.exports=r)},2751:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(0),n(1),n(54),n(23),n(12),n(16),n(2),n(1874),n(2752),n(1983),n(1860)],void 0===(r=function(e,t,n,i,r,o,a,s,l,c,u,d,p){Object.defineProperty(t,"__esModule",{value:!0});var f,h=(f=l.declared(r.EventedMixin(p.InteractiveToolBase)),i(v,f),v.prototype.destroy=function(){this._handles.removeAll(),this._reshapeOperation&&(this._reshapeOperation.destroy(),this._reshapeOperation=null),this._set("view",null),this._set("graphic",null)},v.prototype._updateGeometry=function(){0===c.isSupportedGraphic(this.graphic)&&d.isReshapeGeometry(this.graphic.geometry)?this._reshapeOperation.inputGeometry=this.graphic.geometry.clone():this._reshapeOperation.inputGeometry=null},v.prototype._updateGraphic=function(){var e=this;if(this._handles.remove("onGraphicGeometryChange"),this._updateGeometry(),0===c.isSupportedGraphic(this.graphic)){var t=this.watch("graphic.geometry",function(){!1===e._internalGeometryUpdate&&e._updateGeometry()},!0);this._handles.add(t,"onGraphicGeometryChange")}},v.prototype.manipulatorSelectionChanged=function(){this._reshapeOperation&&this._reshapeOperation.manipulatorSelectionChanged()},v.prototype._onReshapeGeometryChanged=function(){a.isNone(this.graphic)||(this._internalGeometryUpdate=!0,this.graphic.geometry=this._reshapeOperation.outputGeometry.clone(),this._internalGeometryUpdate=!1)},v.prototype.initialize=function(){var t=this;this._reshapeOperation=new u.ReshapeOperation({view:this.view,graphic:this.graphic,manipulators:this.manipulators}),this._handles.add([this._reshapeOperation.on("reshape",function(e){"reshape"===e.type&&t._onReshapeGeometryChanged(),t.emit("reshape",e)}),this._reshapeOperation.on("move",function(e){"move"===e.type&&t._onReshapeGeometryChanged(),t.emit("move",e)}),this._reshapeOperation.on("vertex-add",function(e){t._onReshapeGeometryChanged(),t.emit("vertex-add",e)}),this._reshapeOperation.on("vertex-remove",function(e){t._onReshapeGeometryChanged(),t.emit("vertex-remove",e)}),this._reshapeOperation.on("immediate-click",function(){return t.emit("immediate-click")}),s.init(this,"graphic",function(){t._updateGraphic()},!0)])},v.prototype.handleInputEvent=function(e){"key-down"!==e.type||"Delete"!==e.key&&"Backspace"!==e.key||this._reshapeOperation.removeSelectedVertices()},v.prototype.reset=function(){},n([l.property({constructOnly:!0,nonNullable:!0})],v.prototype,"view",void 0),n([l.property({constructOnly:!0})],v.prototype,"graphic",void 0),n([l.property({readOnly:!0})],v.prototype,"type",void 0),n([l.subclass("esri.views.3d.interactive.editingTools.graphicReshape3D.GraphicReshape3DTool")],v));function v(e){var t=f.call(this,e)||this;return t._handles=new o,t._reshapeOperation=null,t._internalGeometryUpdate=!1,t.type="reshape-3d",t._emitter.target=null,t}t.GraphicReshape3DTool=h}.apply(null,i))||(e.exports=r)},2752:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(0),n(1),n(5),n(34),n(54),n(23),n(12),n(16),n(2),n(118),n(486),n(1668),n(1700),n(1677),n(1781),n(1780),n(1983),n(1646),n(1702),n(1703),n(1745),n(1782)],void 0===(r=function(e,t,n,i,r,o,a,s,g,l,c,u,d,p,f,h,v,m,y,b,_,x,S,P){function w(e){return"vertex"===e.handle.type}function A(e){return"edge"===e.handle.type}Object.defineProperty(t,"__esModule",{value:!0});var C,O=(C=c.declared(a.EventedAccessor),i(M,C),M.prototype.initialize=function(){var i=this;this._handles.add(this.watch(["graphic.visible","graphic.layer.visible"],function(){for(var e=i.graphic.visible&&i.graphic.layer.visible,t=0,n=i._manipulatorInfos;t<n.length;t++)n[t].manipulator.visible=!!e;g.isSome(i._moveZManipulator)&&(i._moveZManipulator.visible=!!e)}))},M.prototype.destroy=function(){this._clear(),this._handles.destroy()},Object.defineProperty(M.prototype,"inputGeometry",{get:function(){return g.isSome(this._reshapeHelper)?this._reshapeHelper.geometry:null},set:function(e){this._recreateManipulators(e)},enumerable:!0,configurable:!0}),M.prototype.removeSelectedVertices=function(){var e=this._manipulatorInfos.filter(function(e){return e.manipulator.selected&&"vertex"===e.handle.type});this._removeVertices(e)},M.prototype.manipulatorSelectionChanged=function(){this._updateMoveZManipulatorPosition()},M.prototype._clear=function(){this._manipulatorHandles.removeAll(),this.manipulators.removeAll(),this._manipulatorInfos=[],this._moveManipulator=null,this._reshapeHelper=null,this._numGrabbing=0},M.prototype._recreateManipulators=function(e){if(this._clear(),this._reshapeHelper=y.createReshapeHelper(e,"global"===this.view.viewingMode),!g.isNone(this._reshapeHelper)){for(var t=p.getGraphicEffectiveElevationInfo(this.graphic),n=0,i=this._reshapeHelper.components;n<i.length;n++){for(var r=i[n],o=0,a=r.vertices;o<a.length;o++){var s=a[o];this._createPerVertexManipulator(s,t)}for(var l=0,c=r.edges;l<c.length;l++){var u=c[l];this._createPerVertexManipulator(u,t)}}this._createGraphicMoveManipulators()}},M.prototype._perGraphicManipulatorDragAction=function(e,t){if("end"!==t.action){for(var n=[],i=this._manipulatorInfos.some(function(e){return"vertex"===e.handle.type&&e.manipulator.selected}),r=1===e&&i,o=g.expect(this._reshapeHelper),a=0,s=this._manipulatorInfos;a<s.length;a++)"vertex"===(u=s[a]).handle.type&&(u.manipulator.grabbing||r&&!u.manipulator.selected||(g.expect(o).addDelta(u.handle,t.deltaDeltaX,t.deltaDeltaY,t.deltaDeltaZ),n.push(u.handle.pos),this._updateManipulatorPosition(u)));if(0!==n.length){for(var l=0,c=this._manipulatorInfos;l<c.length;l++){var u;"vertex"!==(u=c[l]).handle.type&&this._updateManipulatorPosition(u)}this.outputGeometry=o.commit(),n.length===this._manipulatorInfos.length?(this._updateEventState(1),this.emit("move",{type:"move",dx:t.screenDeltaDeltaX,dy:t.screenDeltaDeltaY,mover:this.graphic})):(this._updateEventState(2),this.emit("reshape",{type:"reshape",mover:this.graphic}))}}},M.prototype._perVertexManipulatorDragAction=function(e,t){var n=A(e)?this._splitEdgeManipulator(e):e;this._updateEventState(2),!1===e.manipulator.selected&&(this._clearManipulatorSelection(),this._updateMoveZManipulatorPosition());var i=t.deltaDeltaX,r=t.deltaDeltaY,o=t.deltaDeltaZ;if(i||r||o){for(var a=[],s=0,l=this._manipulatorInfos;s<l.length;s++){var c=l[s];w(c)&&(c.manipulator.selected&&!c.manipulator.grabbing||c===n)&&a.push(c)}for(var u=g.expect(this._reshapeHelper),d=0,p=a;d<p.length;d++){var f=(m=p[d]).handle;u.addDelta(f,i,r,o),this._updateManipulatorPosition(m)}this.outputGeometry=u.commit();for(var h=0,v=a;h<v.length;h++){var m;f=(m=v[h]).handle,this._updateManipulatorPosition(this._getManipulatorInfoFromHandle(f.left)),this._updateManipulatorPosition(this._getManipulatorInfoFromHandle(f.right))}this.emit("reshape",{type:"reshape",mover:this.graphic})}},M.prototype._updateEventState=function(e){if(e===this._reshapeEventState)return!1;switch(e){case 0:if(0!==this._numGrabbing)return!1;switch(this._reshapeEventState){case 1:this.emit("move",{type:"move-stop",dx:0,dy:0,mover:this.graphic});break;case 2:this.emit("reshape",{type:"reshape-stop",mover:this.graphic})}break;case 1:switch(this._reshapeEventState){case 0:this.emit("move",{type:"move-start",dx:0,dy:0,mover:this.graphic});break;case 2:this.emit("reshape",{type:"reshape-stop",mover:this.graphic}),this.emit("move",{type:"move-start",dx:0,dy:0,mover:this.graphic})}break;case 2:switch(this._reshapeEventState){case 0:this.emit("reshape",{type:"reshape-start",mover:this.graphic});break;case 1:this.emit("move",{type:"move-stop",dx:0,dy:0,mover:this.graphic}),this.emit("reshape",{type:"reshape-start",mover:this.graphic})}}var t=this._reshapeEventState!==e;return this._reshapeEventState=e,t},M.prototype._createGraphicMoveManipulators=function(){var n=this;this._moveManipulator=m.createGraphicMoveXYManipulator(this.view,this.graphic),this._manipulatorHandles.add(S.createManipulatorDragHandler(this._moveManipulator,function(e,t){return P.withScreenHistoryInfo(P.withHistoryInfo(m.createGraphicMoveXYScreenDragToMap(n.view,e,t)))},function(e){return n._perGraphicManipulatorDragAction(0,e)})),this._manipulatorHandles.add(this._watchAndUpdateGrabState(this._moveManipulator)),this._moveManipulator.events.on("immediate-click",function(e){n.emit("immediate-click"),e.stopPropagation()}),this.manipulators.add(this._moveManipulator),this._moveZManipulator=m.createGraphicMoveZManipulator({view:this.view,graphic:this.graphic}),g.isSome(this._moveZManipulator)&&(this._manipulatorHandles.add(S.createManipulatorDragHandler(this._moveZManipulator,function(e){return P.withScreenHistoryInfo(P.withHistoryInfo(m.createGraphicMoveZScreenDragToMap(n.view,e)))},function(e){return n._perGraphicManipulatorDragAction(1,e)})),this._manipulatorHandles.add(this._watchAndUpdateGrabState(this._moveZManipulator)),this.manipulators.add(this._moveZManipulator),this._manipulatorHandles.add(l.init(this.graphic,"geometry",function(){return n._updateMoveZManipulatorPosition()})))},M.prototype._clearManipulatorSelection=function(){for(var e=0,t=this._manipulatorInfos;e<t.length;e++)t[e].manipulator.selected=!1;this._updateMoveZManipulatorPosition()},M.prototype._createPerVertexManipulator=function(e,t){var n=this;void 0===t&&(t=p.getGraphicEffectiveElevationInfo(this.graphic));var i=new f.Manipulator3D({view:this.view,renderObjects:[{geometry:this._manipulatorGeometry,material:this._vertexManipulatorMaterial,stateMask:4|D.Vertex},{geometry:this._manipulatorGeometry,material:this._edgeManipulatorMaterial,stateMask:4|D.Edge},{geometry:this._manipulatorGeometry,material:this._selectedManipulatorMaterial,stateMask:8}],radius:5,elevationInfo:t,visible:!(!this.graphic.visible||!this.graphic.layer.visible)});this._setTypeSpecificManipulatorSettings(i,e);var r={manipulator:i,handle:e};return this._manipulatorInfos.push(r),this.manipulators.add(i),this._updateManipulatorPosition(r),this._manipulatorHandles.add(this._watchAndUpdateGrabState(i),i),this._manipulatorHandles.add(S.createManipulatorDragHandler(i,function(e){return P.withHistoryInfo(P.createXYConstrainedFromProject(v.createForGraphicAtLocation(n.view,n.graphic,e.elevationAlignedLocation),e.location.spatialReference))},function(e){return n._perVertexManipulatorDragAction(r,e)})),i.events.on("immediate-click",function(e){return n._manipulatorClickCallback(e,r)}),i},M.prototype._setTypeSpecificManipulatorSettings=function(e,t){switch(t.type){case"vertex":e.state=D.Vertex,e.selectable=!0,e.cursor="move",e.collisionPriority=2,e.hideOnGrab=!0;break;case"edge":e.state=D.Edge,e.selectable=!1,e.cursor="copy",e.collisionPriority=1,e.hideOnGrab=!1;break;default:o.neverReached(t)}},M.prototype._watchAndUpdateGrabState=function(e){var t=this;return e.events.on("grab",function(e){"start"===e.action?t._numGrabbing++:(t._numGrabbing--,t._updateEventState(0))})},M.prototype._removeManipulator=function(e){e&&(this._manipulatorHandles.remove(e.manipulator),this._manipulatorInfos.splice(this._manipulatorInfos.indexOf(e),1),this.manipulators.remove(e.manipulator))},M.prototype._getManipulatorInfoFromHandle=function(e){if(e)for(var t=0,n=this._manipulatorInfos;t<n.length;t++){var i=n[t];if(e===i.handle)return i}return null},M.prototype._updateManipulatorPosition=function(e){if(e){var t=g.expect(this._reshapeHelper);"vertex"===e.handle.type?e.manipulator.location=t.getVertexPositionAsPoint(e.handle,R):"edge"===e.handle.type&&(e.manipulator.location=t.getEdgePositionAsPoint(e.handle,.5,R))}},M.prototype._splitEdgeManipulator=function(e){var t=g.expect(this._reshapeHelper).splitEdge(e.handle,.5),n=e;return n.handle=t,this._setTypeSpecificManipulatorSettings(e.manipulator,e.handle),t.left&&this._createPerVertexManipulator(t.left),t.right&&this._createPerVertexManipulator(t.right),n},M.prototype._updateMoveZManipulatorPosition=function(){if(!g.isNone(this._moveZManipulator)){var e=b.sv3d.get();u.vec3.set(e,0,0,0);for(var t=0,n=0,i=this._manipulatorInfos;n<i.length;n++){var r=i[n];w(r)&&r.manipulator.selected&&(t++,u.vec3.add(e,e,r.manipulator.renderLocation))}if(0!==t&&(u.vec3.scale(e,e,1/t),R.spatialReference=g.expect(this._reshapeHelper).geometry.spatialReference,this.view.renderCoordsHelper.fromRenderCoords(e,R)))return void(this._moveZManipulator.elevationAlignedLocation=R);h.placeManipulatorAtGraphic(this._moveZManipulator,this.graphic)}},M.prototype._removeVertices=function(e){for(var t=[],n=g.expect(this._reshapeHelper),i=0,r=e;i<r.length;i++){var o=r[i];if("vertex"===o.handle.type&&n.canRemoveVertex(o.handle)){t.push(o.handle.unnormalizedPos),this._removeManipulator(o),this._removeManipulator(this._getManipulatorInfoFromHandle(o.handle.left)),this._removeManipulator(this._getManipulatorInfoFromHandle(o.handle.right));var a=n.removeVertex(o.handle);a&&this._createPerVertexManipulator(a)}}if(0<t.length){this.outputGeometry=n.commit();var s=this._updateEventState(2);this.emit("vertex-remove",{type:"vertex-remove",removed:t}),s&&this._updateEventState(0),this._updateMoveZManipulatorPosition()}},M.prototype._manipulatorClickCallback=function(e,t){if("vertex"===t.handle.type&&2===e.button&&this._removeVertices([t]),A(t)&&0===e.button){var n=this._splitEdgeManipulator(t);this.outputGeometry=g.expect(this._reshapeHelper).commit();var i=this._updateEventState(2);this.emit("vertex-add",{type:"vertex-add",added:[n.handle.unnormalizedPos]}),i&&this._updateEventState(0)}e.stopPropagation()},n([c.property({constructOnly:!0})],M.prototype,"view",void 0),n([c.property({constructOnly:!0})],M.prototype,"graphic",void 0),n([c.property()],M.prototype,"inputGeometry",null),n([c.property()],M.prototype,"outputGeometry",void 0),n([c.property({constructOnly:!0})],M.prototype,"manipulators",void 0),n([c.subclass("esri.views.3d.interactive.editingTools.graphicReshape3D.ReshapeOperation")],M));function M(e){var t=C.call(this,e)||this;return t._vertexManipulatorMaterial=h.createManipulatorMaterial([1,.5,0],1),t._edgeManipulatorMaterial=h.createManipulatorMaterial([.5,.5,.5],1),t._selectedManipulatorMaterial=h.createManipulatorMaterial([1,1,1],1),t._manipulatorGeometry=new _(x.createSphereGeometry(1,16,16),"reshape-manipulator"),t._handles=new s,t._manipulatorHandles=new s,t._manipulatorInfos=[],t._reshapeHelper=null,t._moveManipulator=null,t._moveZManipulator=null,t._numGrabbing=0,t._reshapeEventState=0,t.view=null,t.graphic=null,t.outputGeometry=null,t.manipulators=null,t._emitter.target=null,t}t.ReshapeOperation=O;var D,T,R=d.makeDehydratedPoint(0,0,null,null);(T=D=D||{}).Vertex=16,T.Edge=32}.apply(null,i))||(e.exports=r)},2753:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(0),n(1),n(9),n(10),n(54),n(23),n(3),n(12),n(16),n(2),n(484),n(118),n(103),n(1668),n(504),n(1872),n(1780),n(2754),n(2758),n(2759),n(2760),n(1876),n(1646),n(1860)],void 0===(r=function(e,t,n,i,r,o,a,s,l,c,u,d,p,f,h,v,m,g,y,b,_,x,S,P,w,A){Object.defineProperty(t,"__esModule",{value:!0});var C,O=l.getLogger("esri.views.3d.interactive.editingTools.graphicTransform3D.GraphicTransform3DTool"),M=(C=d.declared(a.EventedMixin(A.InteractiveToolBase)),i(D,C),D.prototype.initialize=function(){if(this.xyTransform=new x.GraphicXYTransform({tool:this}),this.xyAxisTransform=new _.GraphicXYAxisTransform({tool:this}),this.enableScaling||this.enableRotation){var e=this.enableScaling&&this.enableRotation?null:this.enableScaling?"scale":"rotate";this.scaleRotate=new b.GraphicScaleRotateTransform({tool:this,mode:e})}m.enableEditing3D()&&y.canMoveZ(this.graphic,v.getGraphicEffectiveElevationInfo(this.graphic))&&(this.zTransform=new S.GraphicZTransform({tool:this})),this._recreateManipulators()},D.prototype.destroy=function(){this._clear(),this.xyTransform.destroy(),this.xyTransform=null,this.xyAxisTransform.destroy(),this.xyAxisTransform=null,c.isSome(this.scaleRotate)&&(this.scaleRotate.destroy(),this.scaleRotate=null),c.isSome(this.zTransform)&&(this.zTransform.destroy(),this.zTransform=null),this._set("view",null),this._set("graphic",null)},Object.defineProperty(D.prototype,"graphic",{set:function(e){if(null!=e){var t=P.isSupportedGraphic(e);if(0!==t)return O.error("Transform tool not supported for graphic ("+g.isSupportedGraphicResultMessage(t)+")."),void this._set("graphic",null);this._set("graphic",e)}else O.error("invalid graphic")},enumerable:!0,configurable:!0}),Object.defineProperty(D.prototype,"symbolRotationAngle",{get:function(){var e=this.graphic.symbol;if(e){var t=e.symbolLayers.find(function(e){return"object"===e.type}),n=t&&t.heading||0;return h.toRadian(-n)}return 0},enumerable:!0,configurable:!0}),D.prototype.reset=function(){},D.prototype.onDetach=function(){c.isSome(this.scaleRotate)&&this.scaleRotate.cancelActiveAnimation()},D.prototype.onHide=function(){c.isSome(this.scaleRotate)&&this.scaleRotate.cancelActiveAnimation()},D.prototype._clear=function(){this.handles.removeAll()},D.prototype._recreateManipulators=function(){var e=this;this._clear();var t=c.unwrap(this.graphic);this.xyTransform.recreateManipulators(),this.xyAxisTransform.recreateManipulators(),c.isSome(this.scaleRotate)&&this.scaleRotate.recreateManipulators(),c.isSome(this.zTransform)&&this.zTransform.recreateManipulators(),this.handles.add([u.watch(t,"geometry",function(){return e.updateManipulators()})]),this.updateManipulators()},D.prototype.updateManipulators=function(){var e=this.view.renderCoordsHelper.basisMatrixAtPosition(this.xyTransform.renderLocation,w.sm4d.get()),t="none";this.xyTransform.focused?t="xy":this.xyAxisTransform.focused?t="xy-axis":c.isSome(this.scaleRotate)&&this.scaleRotate.getFocused()&&(t="scale-rotate"),c.isSome(this.zTransform)&&this.zTransform.dragging&&(t="z"),c.isSome(this.scaleRotate)&&this.scaleRotate.dragging&&(t="scale-rotate"),this.xyAxisTransform.dragging&&(t="xy-axis"),this.xyTransform.dragging&&(t="xy");var n=e;if(c.isSome(this.scaleRotate)){this.scaleRotate.updateManipulators(e,"scale-rotate"===t);var i=this.scaleRotate.getScale(),r=p.mat4.fromScaling(w.sm4d.get(),f.vec3.set(w.sv3d.get(),i,i,i));n=p.mat4.multiply(w.sm4d.get(),e,r)}this.xyTransform.updateManipulators(n,"none"===t||"xy"===t),this.xyAxisTransform.updateManipulators(n,"xy"===t||"xy-axis"===t,"xy-axis"===t),c.isSome(this.zTransform)&&this.zTransform.updateManipulators(n)},n([d.property({constructOnly:!0,nonNullable:!0})],D.prototype,"view",void 0),n([d.property({value:null})],D.prototype,"graphic",null),n([d.property()],D.prototype,"enableRotation",void 0),n([d.property()],D.prototype,"enableScaling",void 0),n([d.property({readOnly:!0})],D.prototype,"type",void 0),n([d.subclass("esri.views.3d.interactive.editingTools.graphicTransform3D.GraphicTransform3DTool")],D));function D(e){var t=C.call(this,e)||this;return t.enableRotation=!0,t.enableScaling=!0,t.type="transform-3d",t.handles=new s,t.zTransform=null,t.scaleRotate=null,t}t.GraphicTransform3DTool=M}.apply(null,i))||(e.exports=r)},2754:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(0),n(1),n(9),n(10),n(5),n(23),n(33),n(12),n(50),n(15),n(16),n(484),n(1633),n(118),n(150),n(103),n(1700),n(1677),n(1677),n(2755),n(1861),n(1650),n(500),n(1646),n(1702),n(1703),n(1862)],void 0===(r=function(e,t,n,i,r,o,D,a,T,R,s,l,c,E,V,I,N,z,j,L,u,d,F,G,H,B,U,k,p){function q(e,t,n){var i=t.projectPoint(e,l.castRenderScreenPointArray(m)),r=t.renderToScreen(i,g);return I.vec3.set(n,r[0],r[1],0)}var W,f;Object.defineProperty(t,"__esModule",{value:!0}),(f=W=W||{}).ScaleIn=32,f.ScaleOut=64,f.RotateLeft=128,f.RotateRight=256,f.Highlighted=512,f.Unlocked=1024,f.TouchInput=32768;var h=(v.prototype.destroy=function(){this._clear()},v.prototype._clear=function(){R.isSome(this._activeAnimation)&&(this._activeAnimation.frameTask.remove(),this._activeAnimation=null),this._handles.removeAll(),this.tool.manipulators.remove(this.ringManipulator),this.ringManipulator=null},Object.defineProperty(v.prototype,"dragging",{get:function(){return this.ringManipulator.dragging},enumerable:!0,configurable:!0}),v.prototype.startAnimation=function(n){var i=this;this.cancelActiveAnimation(),n.start();var e=s.addFrameTask({update:function(e){var t=e.deltaTime;n.update(t)&&i.cancelActiveAnimation()}});this._activeAnimation=D({},n,{frameTask:e})},v.prototype.cancelActiveAnimation=function(){R.isSome(this._activeAnimation)&&(this._activeAnimation.frameTask.remove(),this._activeAnimation.destroy(),this._activeAnimation=null)},v.prototype.recreateManipulators=function(){var M=this;this._clear(),this.ringManipulator=this.createRingManipulator(),this.tool.manipulators.add(this.ringManipulator);var e=this.ringManipulator;d.createDragHandler(e,function(e){M._scaleRotateDragData=null;var t=N.vec3f64.fromValues(M.ringManipulator.modelTransform[8],M.ringManipulator.modelTransform[9],M.ringManipulator.modelTransform[10]),n=N.vec3f64.clone(M.ringManipulator.renderLocation),A=G.plane.fromPositionAndNormal(n,t),C=d.createCartesianPlaneDrag(e,M.tool.view,A);if(R.isNone(C))return null;var i=function(e,t){var n=e.allLayerViews.find(function(e){return e.layer===t.layer});if(R.isNone(t.symbol))return null;var i=t.symbol;return{symbolLayers:i.symbolLayers.map(function(e){var t=null;return"object"===e.type&&(t=e.heading),{heading:t,size:n.getSymbolLayerSize(i,e)}}).toArray()}}(M.tool.view,M.tool.graphic);if(R.isNone(i))return null;var O={mode:"none",origin:n,angle:0,startAngle:M.tool.symbolRotationAngle,angleDir:0,scale:1,scaleDir:0,startSymbolData:i};return M._scaleRotateDragData=O,function(e){var t=C(e),n=A,i=L.calculateInputRotationTransform(t.start,t.end,O.origin,n),r=H.cyclicalPI.shortestSignedDiff(O.angle,i);O.angleDir=T.clamp(O.angleDir+r,-F.ROTATE_INDICATOR_DIRECTION_BUFFER,F.ROTATE_INDICATOR_DIRECTION_BUFFER),O.angle=i;var o,a,s,l,c,u,d,p,f,h,v,m,g,y=(o=O,a=t,s=I.vec3.subtract(B.sv3d.get(),a.start,o.origin),l=I.vec3.subtract(B.sv3d.get(),a.end,o.origin),c=I.vec3.length(s),u=I.vec3.length(l),0===c?0:u/c),b=y-O.scale;if(O.scaleDir=T.clamp(O.scaleDir+b,-F.SCALE_INDICATOR_DIRECTION_BUFFER,F.SCALE_INDICATOR_DIRECTION_BUFFER),O.scale=y,"none"===O.mode){var _=M.mode||function(e,t,n,i){var r=e.start,o=e.end,a=q(r,i,B.sv3d.get()),s=q(o,i,B.sv3d.get());if(I.vec3.squaredDistance(a,s)<F.DRAG_THRESHOLD_PX*F.DRAG_THRESHOLD_PX)return null;var l=I.vec3.subtract(B.sv3d.get(),r,n),c=I.vec3.cross(B.sv3d.get(),l,t),u=r,d=I.vec3.add(B.sv3d.get(),u,c),p=q(n,i,B.sv3d.get()),f=a,h=q(d,i,B.sv3d.get()),v=I.vec3.subtract(B.sv3d.get(),h,f),m=I.vec3.subtract(B.sv3d.get(),a,p),g=G.ray.wrap(f,v),y=G.ray.wrap(p,m);return G.ray.distance2(g,s)<G.ray.distance2(y,s)?"rotate":"scale"}(t,A,O.origin,M.tool.view.state.camera);if(R.isSome(_)){switch(_){case"rotate":M.tool.emit("graphic-rotate-start",{graphic:M.tool.graphic});break;case"scale":M.tool.emit("graphic-scale-start",{graphic:M.tool.graphic})}O.mode=_}}else{if(R.isSome(M.tool.graphic.symbol)){var x=M.tool.graphic.symbol.clone(),S=0,P=1;switch(O.mode){case"scale":P=O.scale;break;case"rotate":S=O.angle}d=x,p=O.startSymbolData,f=S,h=P,d.symbolLayers.forEach(function(e,t){var n=p.symbolLayers[t],i=n.heading,r=n.size;"object"===e.type&&(e.heading=(R.isSome(i)?i:0)-z.toDegree(f),R.isSome(r)&&"width"in r&&(e.width=r.width*h,e.depth=r.depth*h,e.height=r.height*h))}),M.tool.graphic.symbol=x}if("update"===e.action)switch(O.mode){case"rotate":M.tool.emit("graphic-rotate",{graphic:M.tool.graphic,angle:O.angle,type:"rotate"});break;case"scale":M.tool.emit("graphic-scale",{graphic:M.tool.graphic,scale:O.scale,type:"scale"})}}if("end"===e.action){switch(O.mode){case"rotate":M.tool.emit("graphic-rotate-stop",{graphic:M.tool.graphic});break;case"scale":M.tool.emit("graphic-scale-stop",{graphic:M.tool.graphic})}M.startAnimation((v=M,m=null,g=1,{start:function(){g=v.getScale(),m=v.getScale,v.getScale=w},update:function(e){return g+=((g+1)/2-g)*Math.min(e*F.RING_RESET_ANIMATION_SPEED_FACTOR,1),v.tool.updateManipulators(),Math.abs(g-1)<.01?1:0},destroy:function(){v.getScale=m,v.tool.updateManipulators()}})),M._scaleRotateDragData=null}function w(){return g}return M.tool.updateManipulators(),D({},t,O)}},function(e){}),this._handles.add([c.init(this.tool.graphic,"geometry",function(){u.placeManipulatorAtGraphic(M.ringManipulator,M.tool.graphic)}),this.ringManipulator.events.on("focus",function(e){function t(){return!1}var n,i,r;"focus"===e.action?M.startAnimation((n=M,i=0,r=null,{start:function(){r=n.getFocused,n.getFocused=t,i=0},update:function(e){return i+=e,!n.ringManipulator.focused||i>F.RING_INDICATOR_DELAY_MS?1:0},destroy:function(){n.getFocused=r,n.tool.updateManipulators()}})):M.tool.updateManipulators()}),this.ringManipulator.events.on("immediate-click",function(e){e.stopPropagation()}),c.init(this.tool.graphic,["visible","layer.visible"],function(){M.ringManipulator.visible=M.tool.graphic.visible&&M.tool.graphic.layer.visible})])},v.prototype.updateManipulators=function(e,t){var n=E.mat4.identity(B.sm4d.get()),i=this.tool.symbolRotationAngle;0!==i&&E.mat4.rotate(n,n,i,N.vec3f64.fromValues(0,0,1));var r=this.getScale(),o=E.mat4.fromScaling(B.sm4d.get(),I.vec3.set(B.sv3d.get(),r,r,r)),a=E.mat4.identity(B.sm4d.get());if(E.mat4.multiply(a,e,o),E.mat4.multiply(a,a,n),this.ringManipulator.modelTransform=a,this.ringManipulator.state=0,this.ringManipulator.state|=!0===t?W.Highlighted:0,this.ringManipulator.state|=R.isSome(this._scaleRotateDragData)&&"none"!==this._scaleRotateDragData.mode?0:W.Unlocked,R.isSome(this._scaleRotateDragData))switch(this._scaleRotateDragData.mode){case"rotate":this.ringManipulator.state|=this._scaleRotateDragData.angleDir<0?W.RotateLeft:W.RotateRight;break;case"scale":this.ringManipulator.state|=this._scaleRotateDragData.scaleDir<0?W.ScaleIn:W.ScaleOut}},v.prototype.createRingManipulator=function(){function t(e,t,n){for(var i=[],r=Math.ceil(F.GEOMETRY_SEGMENTS*(t-e)/(2*Math.PI)),o=0;o<r+1;o++){var a=e+o*(t-e)/r;i.push(N.vec3f64.fromValues(n*Math.cos(a),n*Math.sin(a),0))}return i}function e(e){return t(0,2*Math.PI,e)}function n(e,t){return new U(k.createPathExtrusionGeometry([[-(n=t)/2,0],[n/2,0],[n/2,F.RING_HEIGHT/2],[-n/2,F.RING_HEIGHT/2]],e,[],[],!1),"graphic-transform-ring");var n}for(var i=e(F.RING_RADIUS),r=n(i,F.RING_THICKNESS),o={left:[],right:[]},a=[],s=0;s<2;s++){var l=(y=s*Math.PI-Math.PI/4)+(b=Math.PI/2-F.ROTATE_INDICATOR_ARC_LENGTH),c=y+Math.PI/2-b,u=n(_=t(l,c,F.INNER_INDICATOR_RADIUS),F.INDICATOR_THICKNESS);a.push(_),o.left.push(u),o.right.push(u);for(var d=0;d<2;d++){var p=0===d,f=V.mat4f64.create();if(p){E.mat4.scale(f,f,[1,-1,1]),E.mat4.rotate(f,f,-l,[0,0,1]);var h=Math.round(F.ROTATE_INDICATOR_ARROW_PLACEMENT_PERCENTAGE*(_.length-1));f[12]=_[h][0],f[13]=_[h][1],f[14]=_[h][2]}else E.mat4.rotate(f,f,c,[0,0,1]),h=Math.round((1-F.ROTATE_INDICATOR_ARROW_PLACEMENT_PERCENTAGE)*(_.length-1)),f[12]=_[h][0],f[13]=_[h][1],f[14]=_[h][2];var v=k.createExtrudedTriangle(F.ROTATE_INDICATOR_ARROW_TIP_LENGTH,0,F.ROTATE_INDICATOR_ARROW_TIP_RADIUS,F.RING_HEIGHT);k.transformInPlace(v,f);var m=new U(v,"graphic-transform-ring-rotate");(p?o.left:o.right).push(m)}}var g=[];for(s=0;s<2;s++){l=(y=s*Math.PI-Math.PI/4)+(b=Math.PI/2-F.SCALE_INDICATOR_ARC_LENGTH),c=y+Math.PI/2-b;var y,b,_=t(l,c,F.OUTER_INDICATOR_RADIUS);g.push(n(_,F.INDICATOR_THICKNESS))}var x=e(F.RING_RADIUS+F.SCALE_INDICATOR_OFFSET1),S=e(F.RING_RADIUS+F.SCALE_INDICATOR_OFFSET2),P=n(x,F.INDICATOR_THICKNESS),w=n(S,F.INDICATOR_THICKNESS),A=e(F.RING_RADIUS-F.SCALE_INDICATOR_OFFSET1),C=e(F.RING_RADIUS-F.SCALE_INDICATOR_OFFSET2),O=n(A,F.INDICATOR_THICKNESS),M=n(C,F.INDICATOR_THICKNESS),D=this.createMaterial(),T=this.createMaterial(.66),R=this.createMaterial(.5),I=this.createMaterial(.33),z=[{geometry:r,material:D,stateMask:W.Highlighted},{geometry:r,material:R}];this.mode&&"scale"!==this.mode||(z=z.concat([{geometry:g,material:D,stateMask:W.Highlighted|W.Unlocked},{geometry:P,material:T,stateMask:W.Highlighted|W.ScaleIn},{geometry:w,material:I,stateMask:W.Highlighted|W.ScaleIn},{geometry:O,material:T,stateMask:W.Highlighted|W.ScaleOut},{geometry:M,material:I,stateMask:W.Highlighted|W.ScaleOut}])),this.mode&&"rotate"!==this.mode||(z=z.concat([{geometry:o.right,material:D,stateMask:W.Highlighted|W.Unlocked},{geometry:o.left,material:D,stateMask:W.Highlighted|W.RotateLeft},{geometry:o.right,material:D,stateMask:W.Highlighted|W.RotateRight}]));var L=[i].concat(a);return new j.Manipulator3D({view:this.tool.view,renderObjects:z,autoScaleRenderObjects:!1,radius:F.RING_THICKNESS,focusMultiplier:1,touchMultiplier:1.5,elevationInfo:{mode:"on-the-ground",offset:0},collisionType:{type:"ribbon",paths:L,direction:N.vec3f64.fromValues(0,0,1)}})},v.prototype.createMaterial=function(e){void 0===e&&(e=1);var t=F.HANDLE_COLOR.concat([e]),n=new p({color:t,transparent:1!==e,cullFace:2},"graphic-transform");return n.renderOccluded=2,n},v);function v(e){var t=this;this.mode=null,this._handles=new a,this._scaleRotateDragData=null,this._activeAnimation=null,this.getFocused=function(){return t.ringManipulator.focused},this.getScale=function(){return R.isSome(t._scaleRotateDragData)&&"scale"===t._scaleRotateDragData.mode?t._scaleRotateDragData.scale:1},this.tool=e.tool,this.mode=e.mode}t.GraphicScaleRotateTransform=h;var m=N.vec3f64.create(),g=l.createScreenPointArray()}.apply(null,i))||(e.exports=r)},2755:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(12),n(15),n(150),n(1650),n(1646)],void 0===(r=function(e,t,o,s,l,c,u){Object.defineProperty(t,"__esModule",{value:!0}),t.createDragHandler=function(e,n,i){var r=null;return e.events.on("drag",function(e){if("start"===e.action&&(r=n(e)),!o.isNone(r)){var t=r(e);o.isSome(t)&&i(t),"end"===e.action&&(r=null)}})},t.createCartesianPlaneDrag=function(e,i,r){var t=s.screenPointObjectToArray(e.start,s.castScreenPointArray(u.sv2d.get())),n=c.ray.fromScreen(i.state.camera,t,d),o=l.vec3f64.create(),a=l.vec3f64.create();return c.plane.intersectRay(r,n,o)?function(e){var t=s.screenPointObjectToArray(e.screenPoint,s.castScreenPointArray(u.sv2d.get())),n=c.ray.fromScreen(i.state.camera,t,d);return c.plane.intersectRay(r,n,a)?{action:e.action,start:o,end:a}:null}:null};var d=c.ray.create()}.apply(null,i))||(e.exports=r)},2756:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(11),n(0),n(5),n(1679),n(1693),n(1741),n(1742),n(1743),n(1704),n(2757),n(314),n(502)],void 0===(r=function(e,t,n,i,r,o,a,s,l,c,u,d,p,f){Object.defineProperty(t,"__esModule",{value:!0});var h,v=(h=l.ShaderTechnique,n(m,h),m.prototype.initializeProgram=function(e){var t=m.shader.get(),n=this.configuration,i=t.build({attributeColor:n.vertexColors,slicePlaneEnabled:n.slicePlaneEnabled,sliceHighlightDisabled:n.sliceHighlightDisabled});return new p(e.rctx,i.generateSource("vertex"),i.generateSource("fragment"),u.Default3D)},m.prototype.bindPass=function(e,t,n){this.program.setUniform4fv("eColor",t.color)},m.prototype.bindDraw=function(e){a.Transform.bindUniforms(this.program,e),o.Slice.bindUniformsWithOrigin(this.program,this.configuration,e)},m.prototype.bindInstance=function(e){this.program.setUniformMatrix4fv("model",e.transformation)},m.prototype.initializePipeline=function(){var e,t=this.configuration,n=0===t.output?t.transparent&&f.separateBlendingParams(770,1,771,771):null;return f.makePipelineState({blending:n,polygonOffset:t.polygonOffset&&{factor:1,units:1},culling:0!==(e=t.cullFace)&&{face:1===e?1028:1029,mode:2305},depthTest:{func:513},depthWrite:t.writeDepth&&f.defaultDepthWriteParams,colorWrite:f.defaultColorWriteParams})},m.prototype.bindPipelineState=function(e){e.setPipelineState(this.pipeline)},m.shader=new s.ReloadableShaderModule(d,"./ColorMaterial.glsl",e),m);function m(){return null!==h&&h.apply(this,arguments)||this}t.ColorMaterialTechnique=v;var g,y=(g=c.ShaderTechniqueConfiguration,n(b,g),i([c.parameter({count:6})],b.prototype,"output",void 0),i([c.parameter({count:3})],b.prototype,"cullFace",void 0),i([c.parameter()],b.prototype,"slicePlaneEnabled",void 0),i([c.parameter()],b.prototype,"sliceHighlightDisabled",void 0),i([c.parameter()],b.prototype,"vertexColors",void 0),i([c.parameter()],b.prototype,"transparent",void 0),i([c.parameter()],b.prototype,"polygonOffset",void 0),i([c.parameter()],b.prototype,"writeDepth",void 0),b);function b(){var e=null!==g&&g.apply(this,arguments)||this;return e.output=0,e.cullFace=0,e.slicePlaneEnabled=!1,e.sliceHighlightDisabled=!1,e.vertexColors=!1,e.transparent=!1,e.polygonOffset=!1,e.writeDepth=!0,e}t.ColorMaterialTechniqueConfiguration=y}.apply(null,i))||(e.exports=r)},2757:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(1628),n(1679),n(1693),n(1859),n(1629),n(1744)],void 0===(r=function(e,t,n,i,r,o,a,s){var l,c;Object.defineProperty(t,"__esModule",{value:!0}),t.build=function(e){var t=new s.ShaderBuilder;return t.include(r.Transform,{linearDepth:!1}),t.include(o.VertexColor,e),t.vertex.uniforms.add("proj","mat4").add("view","mat4").add("model","mat4"),t.attributes.add("position","vec3"),t.varyings.add("vpos","vec3"),t.vertex.code.add(a.glsl(l=l||n(["\n    void main(void) {\n      vpos = (model * vec4(position, 1.0)).xyz;\n      forwardNormalizedVertexColor();\n      gl_Position = transformPosition(proj, view, vpos);\n    }\n  "],["\n    void main(void) {\n      vpos = (model * vec4(position, 1.0)).xyz;\n      forwardNormalizedVertexColor();\n      gl_Position = transformPosition(proj, view, vpos);\n    }\n  "]))),t.include(i.Slice,e),t.fragment.uniforms.add("eColor","vec4"),t.fragment.code.add(a.glsl(c=c||n(["\n    void main() {\n      discardBySlice(vpos);\n      ","\n      gl_FragColor = highlightSlice(gl_FragColor, vpos);\n    }\n    "],["\n    void main() {\n      discardBySlice(vpos);\n      ","\n      gl_FragColor = highlightSlice(gl_FragColor, vpos);\n    }\n    "]),e.attributeColor?"gl_FragColor = vColor * eColor;":"gl_FragColor = eColor;")),t}}.apply(null,i))||(e.exports=r)},2758:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(0),n(1),n(9),n(10),n(23),n(14),n(12),n(16),n(484),n(1633),n(118),n(150),n(1700),n(1677),n(1781),n(1861),n(1646),n(1702),n(1703),n(1862),n(1783),n(1745),n(1782)],void 0===(r=function(e,t,n,i,r,o,a,u,s,l,d,p,f,h,v,c,m,g,y,b,_,x,S,P,w){var A,C;Object.defineProperty(t,"__esModule",{value:!0}),(C=A=A||{}).Highlighted=512,C.Visible=1024;var O=(M.prototype.destroy=function(){this._clear()},M.prototype._clear=function(){var t=this;this._handles.removeAll(),this.arrowManipulatorInfos.forEach(function(e){t.tool.manipulators.remove(e.manipulator)}),this.arrowManipulatorInfos=[]},Object.defineProperty(M.prototype,"focused",{get:function(){return this.arrowManipulatorInfos.some(function(e){return e.manipulator.focused})},enumerable:!0,configurable:!0}),Object.defineProperty(M.prototype,"dragging",{get:function(){return this.arrowManipulatorInfos.some(function(e){return e.manipulator.dragging})},enumerable:!0,configurable:!0}),Object.defineProperty(M.prototype,"arrowRotationAngle",{get:function(){return"local"===this.tool.view.viewingMode||this.tool.view.scale<g.ALIGN_ARROWS_SCALE_THRESHOLD?this.tool.symbolRotationAngle:0},enumerable:!0,configurable:!0}),M.prototype.createDragAction=function(){var t=this,n=S.createGraphicDragAction(this.tool.graphic);return function(e){switch("start"===e.action&&t.tool.emit("graphic-translate-start",{graphic:t.tool.graphic}),n(e),e.action){case"update":t.tool.emit("graphic-translate",{graphic:t.tool.graphic,dx:e.deltaX,dy:e.deltaY,dz:e.deltaZ,type:"translate"});break;case"end":t.tool.emit("graphic-translate-stop",{graphic:t.tool.graphic})}}},M.prototype.recreateManipulators=function(){var n=this;this._clear();for(var e=[],t=0;t<4;t++){var i=this.createArrowManipulator(t);e.push(i),this.tool.manipulators.add(i.manipulator);var r=this.createDragAction(),o=P.createManipulatorDragHandler(i.manipulator,this.createDragEventMappingFunction(t),r);this._handles.add(o),this._handles.add([i.manipulator.events.on("focus",function(){n.tool.updateManipulators()}),i.manipulator.events.on("immediate-click",function(e){e.stopPropagation()})])}this.arrowManipulatorInfos=e,this.arrowManipulatorInfos.forEach(function(e){c.placeManipulatorAtGraphic(e.manipulator,n.tool.graphic)}),this._handles.add([l.init(this.tool.graphic,"geometry",function(){n.arrowManipulatorInfos.forEach(function(e){c.placeManipulatorAtGraphic(e.manipulator,n.tool.graphic)})}),l.init(this.tool.graphic,["visible","layer.visible"],function(){var t=n.tool.graphic.visible&&n.tool.graphic.layer.visible;n.arrowManipulatorInfos.forEach(function(e){e.manipulator.visible=t})})])},M.prototype.updateManipulators=function(e,t,n){var i=this.tool.symbolRotationAngle,r=d.mat4.identity(y.sm4d.get());0!==i&&d.mat4.rotate(r,r,i,h.vec3f64.fromValues(0,0,1));var o,a=d.mat4.multiply(y.sm4d.get(),e,r),s="local"===(o=this.tool.view).viewingMode||o.scale<g.ALIGN_ARROWS_SCALE_THRESHOLD?a:e,l=this.dragging,c=t||u("esri-mobile")?A.Visible:0;this.arrowManipulatorInfos.forEach(function(e){var t=d.mat4.multiply(y.sm4d.get(),s,e.transform);e.manipulator.state=l?c|(e.manipulator.dragging?A.Highlighted:0):c|(e.manipulator.focused&&n?A.Highlighted:0),e.manipulator.modelTransform=t})},M.prototype.createArrowManipulator=function(e){var t=Math.sqrt(g.DISC_TRANSLATE_ARROW_SIZE*g.DISC_TRANSLATE_ARROW_SIZE*3/4),n=_.createExtrudedTriangle(t,g.DISC_TRANSLATE_ARROW_SIZE/2,g.DISC_TRANSLATE_ARROW_SIZE/2,g.DISC_HEIGHT);_.transformInPlace(n,d.mat4.fromTranslation(y.sm4d.get(),f.vec3.set(y.sv3d.get(),0,-t/3,0)));var i=new b(n,"graphic-transform-disc-arrow"+e),r=this.createMaterial(),o=this.createMaterial(.5),a=this.createMaterial(0),s=new v.Manipulator3D({view:this.tool.view,renderObjects:[{geometry:i,material:r,stateMask:A.Visible|A.Highlighted},{geometry:i,material:o,stateMask:A.Visible},{geometry:i,material:a,stateMask:0}],autoScaleRenderObjects:!1,radius:t,focusMultiplier:1,touchMultiplier:1,elevationInfo:{mode:"on-the-ground",offset:0},collisionType:{type:"disc",direction:h.vec3f64.fromValues(0,0,1)}}),l=d.mat4.identity(y.sm4d.get());d.mat4.fromZRotation(l,e*Math.PI/2);var c=d.mat4.identity(y.sm4d.get());d.mat4.fromTranslation(c,f.vec3.set(y.sv3d.get(),0,g.DISC_TRANSLATE_ARROW_OFFSET,0));var u=p.mat4f64.create();return d.mat4.multiply(u,l,c),{manipulator:s,transform:u}},M.prototype.createMaterial=function(e){void 0===e&&(e=1);var t=g.HANDLE_COLOR.concat([e]),n=new x({color:t,transparent:1!==e,cullFace:2},"graphic-transform");return n.renderOccluded=2,n},M.prototype.createDragEventMappingFunction=function(o){var a=this;return function(e){var t=a.arrowRotationAngle,n=[Math.cos(t),Math.sin(t),0],i=[-n[1],n[0],0],r=w.createMapAxisConstrainedScreenToMapDrag(m.createForGraphicAtLocation(a.tool.view,a.tool.graphic,e.elevationAlignedLocation),o%2==0?i:n,s.expect(a.tool.graphic.geometry).spatialReference);return s.isNone(r)?null:function(e){var t=r(e);return s.isNone(t)?null:t}}},M);function M(e){this._handles=new a,this.arrowManipulatorInfos=[],this.tool=e.tool}t.GraphicXYAxisTransform=O}.apply(null,i))||(e.exports=r)},2759:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(0),n(1),n(9),n(10),n(23),n(12),n(16),n(484),n(1633),n(150),n(1700),n(1677),n(1781),n(1861),n(1702),n(1703),n(1862),n(1783),n(1745),n(1782)],void 0===(r=function(e,t,n,i,r,o,a,s,l,c,u,d,p,f,h,v,m,g,y,b,_,x){var S;Object.defineProperty(t,"__esModule",{value:!0}),(S||(S={})).Highlighted=512;var P=(w.prototype.destroy=function(){this._clear()},w.prototype._clear=function(){this._handles.removeAll(),this.tool.manipulators.remove(this.discManipulator),this.discManipulator=null},Object.defineProperty(w.prototype,"focused",{get:function(){return this.discManipulator.focused},enumerable:!0,configurable:!0}),Object.defineProperty(w.prototype,"dragging",{get:function(){return this.discManipulator.dragging},enumerable:!0,configurable:!0}),Object.defineProperty(w.prototype,"renderLocation",{get:function(){return this.discManipulator.renderLocation},enumerable:!0,configurable:!0}),w.prototype.recreateManipulators=function(){var e=this;this._clear(),this.discManipulator=this.createDiscManipulator(),this.tool.manipulators.add(this.discManipulator);var t=this.createDragAction(),n=_.createManipulatorDragHandler(this.discManipulator,this.createDragEventMappingFunction(),t);this._handles.add(n),this._handles.add([l.init(this.tool.graphic,"geometry",function(){f.placeManipulatorAtGraphic(e.discManipulator,e.tool.graphic)}),this.discManipulator.events.on("immediate-click",function(e){e.stopPropagation()}),l.init(this.tool.graphic,["visible","layer.visible"],function(){e.discManipulator.visible=e.tool.graphic.visible&&e.tool.graphic.layer.visible})]),this._handles.add([this.discManipulator.events.on("focus",function(){e.tool.updateManipulators()})])},w.prototype.updateManipulators=function(e,t){this.discManipulator.modelTransform=e,this.discManipulator.state=t?S.Highlighted:0},w.prototype.createDiscManipulator=function(){var e=this.tool.view,t=new m(g.createCylinderGeometry(v.DISC_HEIGHT,1,v.GEOMETRY_SEGMENTS,d.vec3f64.fromValues(0,0,1),d.vec3f64.fromValues(0,0,0)),"graphic-transform-disc"),n=c.mat4.fromScaling(u.mat4f64.create(),d.vec3f64.fromValues(v.DISC_RADIUS,v.DISC_RADIUS,v.DISC_RADIUS)),i=this.createMaterial(),r=this.createMaterial(.5);return new p.Manipulator3D({view:e,renderObjects:[{geometry:t,material:i,transform:n,stateMask:S.Highlighted},{geometry:t,material:r,transform:n}],worldSized:!1,autoScaleRenderObjects:!1,focusMultiplier:1,touchMultiplier:1,radius:v.DISC_COLLISION_RADIUS,elevationInfo:{mode:"on-the-ground",offset:0},collisionType:{type:"disc",direction:d.vec3f64.fromValues(0,0,1)}})},w.prototype.createMaterial=function(e){void 0===e&&(e=1);var t=v.HANDLE_COLOR.concat([e]),n=new y({color:t,transparent:1!==e,cullFace:2},"graphic-transform");return n.renderOccluded=2,n},w.prototype.createDragEventMappingFunction=function(){var t=this;return function(e){var n=x.createXYConstrainedFromProject(h.createForGraphicAtLocation(t.tool.view,t.tool.graphic,e.elevationAlignedLocation),s.expect(t.tool.graphic.geometry).spatialReference);return s.isNone(n)?null:function(e){var t=n(e);return s.isNone(t)?null:t}}},w.prototype.createDragAction=function(){var t=this,n=b.createGraphicDragAction(this.tool.graphic);return function(e){switch("start"===e.action&&t.tool.emit("graphic-translate-start",{graphic:t.tool.graphic}),n(e),e.action){case"update":t.tool.emit("graphic-translate",{graphic:t.tool.graphic,dx:e.deltaX,dy:e.deltaY,dz:e.deltaZ,type:"translate"});break;case"end":t.tool.emit("graphic-translate-stop",{graphic:t.tool.graphic})}}},w);function w(e){this._handles=new a,this.tool=e.tool}t.GraphicXYTransform=P}.apply(null,i))||(e.exports=r)},2760:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n(0),n(1),n(9),n(10),n(23),n(12),n(16),n(1677),n(1780),n(1783),n(1745)],void 0===(r=function(e,t,n,i,r,o,a,s,l,c,u,d,p){Object.defineProperty(t,"__esModule",{value:!0});var f=(h.prototype.destroy=function(){this._clear()},h.prototype._clear=function(){this._handles.removeAll(),s.isSome(this.zManipulator)&&this.tool.manipulators.remove(this.zManipulator),this.zManipulator=null},Object.defineProperty(h.prototype,"dragging",{get:function(){return s.isSome(this.zManipulator)&&this.zManipulator.dragging},enumerable:!0,configurable:!0}),h.prototype.recreateManipulators=function(){var e=this;if(this._clear(),this.zManipulator=u.createGraphicMoveZManipulator({view:this.tool.view,graphic:this.tool.graphic,worldOriented:!1}),s.isSome(this.zManipulator)){this.tool.manipulators.add(this.zManipulator);var t=this.createDragEventMappingFunction(),n=d.createGraphicDragAction(this.tool.graphic),i=p.createManipulatorDragHandler(this.zManipulator,t,n);this._handles.add(i),this._handles.add([l.init(this.tool.graphic,"geometry",function(){s.isSome(e.zManipulator)&&c.placeManipulatorAtGraphic(e.zManipulator,e.tool.graphic)}),this.zManipulator.events.on("immediate-click",function(e){e.stopPropagation()}),l.init(this.tool.graphic,["visible","layer.visible"],function(){s.isSome(e.zManipulator)&&(e.zManipulator.visible=e.tool.graphic.visible&&e.tool.graphic.layer.visible)})])}},h.prototype.updateManipulators=function(e){s.isSome(this.zManipulator)&&(this.zManipulator.modelTransform=e)},h.prototype.createDragEventMappingFunction=function(){var i=this;return function(e){var n=u.createGraphicMoveZScreenDragToMap(i.tool.view,e);return s.isNone(n)?null:function(e){var t=n(e);if(s.isNone(t))return null;switch(e.action){case"start":i.tool.emit("graphic-translate-start",{graphic:i.tool.graphic});break;case"update":i.tool.emit("graphic-translate",{graphic:i.tool.graphic,dx:t.deltaX,dy:t.deltaY,dz:t.deltaZ});break;case"end":i.tool.emit("graphic-translate-stop",{graphic:i.tool.graphic})}return t}}},h);function h(e){this._handles=new a,this.zManipulator=null,this.tool=e.tool}t.GraphicZTransform=f}.apply(null,i))||(e.exports=r)}}]);